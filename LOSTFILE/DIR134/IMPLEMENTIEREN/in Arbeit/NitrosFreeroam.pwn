#include <a_samp>
#include <core>
#include <float>
#include <file>
#include <dudb>
#include <dini>
#include <dutils>

#define FILE_SETTINGS "settings.ini"
#define FILE_COMMANDLOG "lastcommand.log"
#define FILE_LOCATIONS "locations.txt"
#define FILE_PIZZABOARD "pizzaboard.txt"
#define FILE_TAXIBOARD "taxiboard.txt"

#define COLOR_GM_REG 0xFFFFFFAA		// WHITE (FFFFFF) normal chat to everyone (registered users)
#define COLOR_GM_UNREG 0xFF9999AA	// LIGHT RED(FF9999) normal chat to everyone (unregistered users)
#define COLOR_GM_ADMIN 0xFFCC66AA	// LIGHT ORANGE (FFCC66) normal chat to everyone (admins)
#define COLOR_IRC 0x66CCFFAA		// LIGHT BLUE (66CCFF) irc messages (/me /query (!) /slap)
#define COLOR_ADMINCHAT 0xFF9933AA	// BRIGHT ORANGE (FF9933) admin only chat (@)
#define COLOR_SYSTEM_PM 0x66CC00AA	// LIGHT GREEN (66CC00) system generated personal message (logged in, progress saved, function disabled)
#define COLOR_SYSTEM_GM 0xFF9966AA	// LIGHT ORANGE-RED (FF9966) system generated general message ("x just bought the four dragons!")
#define COLOR_SYSTEM_PW 0xFFFF33AA	// YELLOW (FFFF33) system personal warning ("you must be in a bank")
#define COLOR_SYSTEM_GW 0xCCCCCCAA	// GRAY (CCCCCC) system general warning ("x used a money cheat")
#define COLOR_MONEY_INC 0x00CC66AA	// GREEN (00CC66) money increase related system message ("you earned x money")
#define COLOR_MONEY_DEC 0xFF6600AA	// RED (FF6600) money decrease related system message ("your property has been bought out")
#define COLOR_MENU 0xFFFFFFAA		// WHITE (FFFFFF) menu's (/help)
#define COLOR_CMD 0xFFFFFFAA		// WHITE (FFFFFF)commands (Usage: ...)
#define COLOR_ADMIN_CMD 0xCC6666AA	// RED BROWN (CC6666) admin commands (Usage: ...)
#define COLOR_ADMIN_PM 0x6699CCAA	// GREEN BLUE (6699CC) admin personal message (your money has been set to X)
#define COLOR_ADMIN_PW 0x99CCFFAA	// BLUE (99CCFF) admin personal warning (x is not an active player)
#define COLOR_ADMIN_GM 0xFF6633AA	// LIGHT RED (FF6633) admin general message (was jailed by admin x)
#define COLOR_STATS 0xCCCCFFAA		// LIGHT  PURPLE (CCCCFF) stats (/stat /totalstat)
#define COLOR_MESSAGE 0xFFCCFFAA	// PURPLE (FFCCFF) Message system (anticheat, blog address)
#define COLOR_RULES 0xDC143CAA      // RED
#define COLOR_ADMIN_TOALL 0x00FFFFAA// CYAN
#define COLOR_GROUPTALK 0x87CEEBAA  // SKYBLUE
#define COLOR_ADMIN_REPORT 0xFF69B4AA // HOTPINK
#define COLOR_ADMIN_SPYREPORT 0xB0E0E6AA //POWDERBLUE
#define COLOR_ADMIN 0xFF8200FF
#define COLOR_CARDIVE 0xEE82EEAA //VIOLET
#define COLOR_BLACK_PD 0x000000FF
#define COLOR_WHITE_PD 0xFFFFFFFF
#define COLOR_DISARMING 0xEE82EEBB

#define COLOR_WHITE 0xFFFFFFAA
#define COLOR_ORANGE 0xFF9900AA
#define COLOR_IVORY 0xFFFF82FF
#define COLOR_BLUE 0x0000FFFF
#define COLOR_PURPLE 0x800080FF
#define COLOR_RED 0xFF0000FF
#define COLOR_LIGHTGREEN 0x00FF7FFF
#define COLOR_VIOLET 0xEE82EEFF
#define COLOR_YELLOW 0xFFFF00FF
#define COLOR_SILVER 0xC0C0C0FF
#define COLOR_LIGHTBLUE 0x87CEFAFF
#define COLOR_PINK 0xFFB6C1FF
#define COLOR_INDIGO 0x4B00B0FF
#define COLOR_GOLD 0xFFD700FF
#define COLOR_FIREBRICK 0xB22222FF
#define COLOR_GREEN 0x008000FF
#define COLOR_LIGHTYELLOW 0xFAFA02FF
#define COLOR_GREY 0x778899FF
#define COLOR_MAGENTA 0xFF00FFFF
#define COLOR_BRIGHTGREEN 0x7CFC00FF
#define COLOR_DARKBLUE 0x000080AFF
#define COLOR_VIOLETRED 0xDB7093FF
#define COLOR_BROWN 0x8B4513FF
#define COLOR_GREENYELLOW 0xADFF2FFF
#define COLOR_THISTLE 0xD8BFD8FF
#define COLOR_TURQUISE 0x48D1CCFF
#define COLOR_MAROON 0x800000FF
#define COLOR_STEELBLUE 0xB0C4DEFF

//30 player colors
#define COLOR_PLAYER_LIGHTBLUE 0x9292FFDD
#define COLOR_PLAYER_BLUE 0x0000FFDD
#define COLOR_PLAYER_DARKBLUE 0x000096DD
#define COLOR_PLAYER_SPECIALBLUE 0x4169FFDD
#define COLOR_PLAYER_LIGHTRED 0xFFB0B0DD
#define COLOR_PLAYER_RED 0xFF0000DD
#define COLOR_PLAYER_DARKRED 0xA10000DD
#define COLOR_PLAYER_SPECIALRED 0xB22222DD
#define COLOR_PLAYER_LIGHTGREEN 0x92FF92DD
#define COLOR_PLAYER_GREEN 0x00FF00DD
#define COLOR_PLAYER_DARKGREEN 0x009600DD
#define COLOR_PLAYER_SPECIALGREEN 0x7ACA7ADD
#define COLOR_PLAYER_LIGHTYELLOW 0xFFFF5EDD
#define COLOR_PLAYER_YELLOW 0xFFFF00DD
#define COLOR_PLAYER_DARKYELLOW 0xD3D300DD
#define COLOR_PLAYER_SPECIALYELLOW 0xCFAE00DD
#define COLOR_PLAYER_LIGHTPURPLE 0xFF92FFDD
#define COLOR_PLAYER_PURPLE 0xFF00FFDD
#define COLOR_PLAYER_DARKPURPLE 0x800080DD
#define COLOR_PLAYER_SPECIALPURPLE 0xDA70D6DD
#define COLOR_PLAYER_LIGHTBROWN 0xBA9072DD
#define COLOR_PLAYER_BROWN 0x8B4513DD
#define COLOR_PLAYER_DARKBROWN 0x6D360EDD
#define COLOR_PLAYER_LIGHTGREY 0xC7C7C7DD
#define COLOR_PLAYER_GREY 0x8B8B8BDD
#define COLOR_PLAYER_DARKGREY 0x656565DD
#define COLOR_PLAYER_WHITE 0xFFFFFFDD
#define COLOR_PLAYER_BLACK 0x000000DD
#define COLOR_PLAYER_AQUAMARINE 0x7FFFD4DD
#define COLOR_PLAYER_CYAN 0x00FFFFDD

#define MAX_CLASS 300

#define PocketMoney 5000
#define INACTIVE_PLAYER_ID 255
#define MAX_JAILTIME 10 // minutes
#define JAILTIME_ON_SHIP 5
#define ANNOUNCE_SECONDS 10
#define SLAP_HEALTH 20 //percent
#define MAX_COUNTDOWN_SEC 999
#define MAX_ADMIN_LEVEL 3
#define FLOG_PROP_PERC 50 //percent
#define BUYOUT_PERC 50
#define BUYOUTOWNER_PERC 100
#define MAX_OWNED_PROPERTIES 8
#define MAX_OWNED_TIME 60
#define MAX_AMMO 3000
#define MAX_TAXI_FEE 500
#define GAMBLE_LICENCE 2500000
#define ADMIN_PENALTY 100000
//bug in dini
#define MAX_MONEY 100000000

#define NUMVALUES 4

#define MAX_KMPRICE 250
#define TAXI_STARTER 100000
#define TAXI_FACTOR 500

#define CREDITCOST 30 //percent
#define BANKPERCENTAGE 25 //percent

#define CP_BANK 	0
#define CP_PIRATE 	1
#define CP_AMMU     2
#define CP_DRAGON   3
#define CP_SEXSHOP  4
#define CP_BAR      5
#define CP_CALIGULA 6
#define CP_ZIP      7
#define CP_BINCO    8
#define CP_TATOO    9
#define CP_BOTIQUE  10
#define CP_JIZZY    11
#define CP_PIZZA    12
#define CP_VICTIM   13
#define CP_STRIPCLUB	14
#define CP_WANGCARS	15
#define CP_EMERALD	16
#define CP_VISAGE	17
#define CP_SUBURBAN	18
#define CP_PROLAPS	19
#define CP_BURGER	20
#define CP_CLUCKIN	21
#define CP_CLUB		22
#define CP_DS		23
#define CP_ZOMBO	24

#define CP_MADD_D       25
#define CP_LV_AP        26
#define CP_SF_HOTEL     27
#define CP_BS_RANCH     28
#define CP_CITY_PL_D    29
#define CP_ROCK_HOTEL   30
#define CP_CLOWN_HOTEL    31
#define CP_LV_STADIUM   32
#define CP_S_DAM        33
#define CP_ZERO_RC      34
#define CP_E_BASIN      35
#define CP_OTTO_AUTO	36
#define CP_PH_LIQUOR    37

#define CP_LS_POLICE 38
#define CP_BETTING 39
#define CP_SA_BANK 40
#define CP_LS_MOTEL 41
#define CP_GYM 42
#define CP_UFO_RES 43
#define CP_BARTS_BEER 44

#define CP_BANKADMIN 45
#define CP_ISPOFFICE 46
#define CP_INSURANCE 47
#define CP_FOREIGN 48
#define CP_LSCARGOTRNS 49
#define CP_LSCARGOCMP 50
#define CP_LSCARGODCK 51
#define CP_LSCONTAINER 52
#define CP_LSMARKET 53
#define CP_DONUT 54
#define CP_LEREGALLE 55
#define CP_SEXCINEMA 56
#define CP_ROYAL 57
#define CP_MOVIE 58
#define CP_TELEVISION 59
#define CP_YACHT 60
#define CP_TOMCR 61
#define CP_ELPACM 62
#define CP_GEORGET 63
#define CP_MELTRIP 64
#define CP_WHITENAG 65
#define CP_RUSSEL 66
#define CP_SYLVESTER 67
#define CP_DITRINA 68
#define CP_BILLFENCE 69
#define CP_OPRAH 70
#define CP_GARDENER 71
#define CP_GLITTON 72
#define CP_PIGFARM 73
#define CP_SOLARADM 74
#define CP_DILLGAS 75
#define CP_WELCOME 76
#define CP_PALDICK 77
#define CP_PALLIBR 78
#define CP_BIOENG 79
#define CP_MONTGAS 80
#define CP_SPRUNK 81
#define CP_BARTHIDE 82
#define CP_BLUETRUCK 83
#define CP_COTTON 84
#define CP_LOGGING 85
#define CP_FLINTRANCH 86
#define CP_RSHAUL 87
#define CP_FALLENTREE 88
#define CP_HUNTING 89
#define CP_GRASS 90
#define CP_JUNKYARD 91
#define CP_ANGELMOT 92
#define CP_SAWMILL 93
#define CP_WHETGAS 94
#define CP_FLINTMOT 95
#define CP_ANGELGAS 96
#define CP_EASTCHEM 97
#define CP_TOBACCO 98
#define CP_DIARY 99
#define CP_SABROAD 100
#define CP_RETIRE 101
#define CP_FBI 102
#define CP_SADIRT 103
#define CP_AVISPA 104
#define CP_HIPPY 105
#define CP_ARTMUS 106
#define CP_SFTOWN 107
#define CP_SAHOSP 108
#define CP_SAMINT 109
#define CP_CITY 110
#define CP_QUEENS 111
#define CP_BIFFIN 112
#define CP_DOJO 113
#define CP_DRUGS 114
#define CP_PUBLICTRAN 115
#define CP_DEA 116
#define CP_SFCONT 117
#define CP_CARINEX 118
#define CP_SOLARFAC 119
#define CP_SFGAS 120
#define CP_SUPERMARK 121
#define CP_CIAOFFICE 122
#define CP_BAYYACHT 123
#define CP_JAYDINER 124
#define CP_CIAHID 125
#define CP_CARSHOTEL 126
#define CP_HIK69 127
#define CP_DRIVEINN 128
#define CP_BOWLED 129
#define CP_KINGRING 130
#define CP_LOOKOUT 131
#define CP_BIGEAR 132
#define CP_REGULAR 133
#define CP_BARRGIFT 134
#define CP_BARTEE 135
#define CP_RONNIECRIB 136
#define CP_BAIT 137
#define CP_ELQUEHOTEL 138
#define CP_ELQUEGAS 139
#define CP_PEUBLOMUS 140
#define CP_VALTEE 141
#define CP_AIRMUS 142
#define CP_LASCHICK 143
#define CP_BONEGAS 144
#define CP_OILREF 145
#define CP_HUNTER 146
#define CP_SHOOTING 147
#define CP_COLLEGE 148
#define CP_SABIKE 149
#define CP_CUSTOMS 150
#define CP_MEATFAC 151
#define CP_LVCARGO 152
#define CP_AIRCONTR 153
#define CP_FIREBRIG 154
#define CP_RIMSHINE 155
#define CP_LVGAS 156
#define CP_STARBUCK 157
#define CP_BEHIND 158
#define CP_LVSOURV 159
#define CP_CENTER 160
#define CP_YELLOWBELL 161
#define CP_TRANSMAIN 162
#define CP_AZTECMOT 163
#define CP_CONCA 164
#define CP_MIDEVAL 165
#define CP_OLDCOWBOY 166
#define CP_KICKHEELS 167
#define CP_ROYALCAS 168
#define CP_COMEALOT 169
#define CP_LVCARGOHAR 170
#define CP_PHEELY 171
#define CP_CHUCKUP 172
#define CP_FINALBUILD 173
#define CP_SHOODY 174
#define CP_TAXICOMP 175
#define CP_BANKHACKING 176
#define CP_JAILBREAK 177
#define CP_JOSDJCON 178
#define CP_ADMWEAP 179
#define CP_SECRWEAP 180
#define CP_BEERTENDER 181
#define CP_WARMEMORIAL 182
#define CP_LSSEXXSHOP 183
#define CP_BAHAMAS 184
#define CP_ANGELMED 185
#define CP_ELQMED 186
#define CP_GOLDMINE 187
#define CP_VORTEX 188
#define CP_SPEEDO 189
#define CP_SFBANK 190
#define CP_GASEMER 191
#define CP_GASBEHCAM 192
#define CP_GASBESCAM 193
#define CP_GASSPINY 194
#define CP_GASTIERRA 195
#define CP_GASJUNIP 196
#define CP_GASIDLE 197
#define CP_GASFLINT 198
#define CP_LSTOWN   199
#define CP_SAGOVERN 200
#define CP_LVTOWN   201
#define CP_FORTCARSONPD 202
#define CP_LIFTMECHIL   203
#define CP_LIFTMEGATE   204
#define CP_LUIGIS 205
#define CP_GOLD00 206
#define CP_GOLD01 207
#define CP_GOLD02 208
#define CP_GOLD03 209
#define CP_GOLD04 210
#define CP_GOLD05 211
#define CP_GOLD06 212
#define CP_GOLD07 213
#define CP_GOLD08 214
#define CP_GOLD09 215
#define CP_GOLD10 216
#define CP_GOLD11 217
#define CP_GOLD12 218
#define CP_GOLD13 219
#define CP_GOLD14 220
#define CP_GOLD15 221
#define CP_GOLD16 222
#define CP_GOLD17 223
#define CP_GOLD18 224
#define CP_GOLD19 225
#define CP_GOLD20 226
#define CP_GOLD21 227
#define CP_GOLD22 228
#define CP_GOLD23 229
#define CP_GOLD24 230
#define CP_GOLD25 231
#define CP_GOLD26 232
#define CP_GOLD27 233
#define CP_GOLD28 234
#define CP_GOLD29 235
#define CP_GOLD30 236
#define CP_GOLD31 237

#define CP_ADMINTELEPORT 238
#define CP_ADMINRENTCAR 239

#define P_NONE      0
#define P_DRAGON    1
#define P_SEXSHOP   2
#define P_BAR       3
#define P_CALIGULA  4
#define P_ZIP       5
#define P_BINCO     6
#define P_TATOO     7
#define P_BOTIQUE   8
#define P_JIZZY     9
#define P_PIZZA     10
#define P_VICTIM    11
#define P_STRIPCLUB	12
#define P_WANGCARS	13
#define P_EMERALD	14
#define P_VISAGE	15
#define P_SUBURBAN	16
#define P_PROLAPS	17
#define P_BURGER	18
#define P_CLUCKIN	19
#define P_CLUB		20
#define P_DS		21
#define P_ZOMBO		22

#define P_MADD_D		23
#define P_LV_AP        	24
#define P_SF_HOTEL     	25
#define P_BS_RANCH     	26
#define P_CITY_PL_D    	27
#define P_ROCK_HOTEL   	28
#define P_CLOWN_HOTEL   29
#define P_LV_STADIUM   	30
#define P_S_DAM        	31
#define P_ZERO_RC      	32
#define P_E_BASIN      	33
#define P_OTTO_AUTO		34
#define P_PH_LIQUOR    	35

#define P_LS_POLICE 	36
#define P_BETTING 		37
#define P_SA_BANK 		38
#define P_LS_MOTEL 		39
#define P_GYM 			40
#define P_UFO_RES 		41
#define P_BARTS_BEER 	42

#define P_BANKADMIN 	43
#define P_ISPOFFICE 	44
#define P_INSURANCE 	45
#define P_FOREIGN 		46
#define P_LSCARGOTRNS 	47
#define P_LSCARGOCMP 	48
#define P_LSCARGODCK 	49
#define P_LSCONTAINER 	50
#define P_LSMARKET 		51
#define P_DONUT 		52
#define P_LEREGALLE 	53
#define P_SEXCINEMA 	54
#define P_ROYAL 		55
#define P_MOVIE 		56
#define P_TELEVISION 	57
#define P_YACHT 		58
#define P_TOMCR 		59
#define P_ELPACM 		60
#define P_GEORGET 		61
#define P_MELTRIP 		62
#define P_WHITENAG 		63
#define P_RUSSEL 		64
#define P_SYLVESTER 	65
#define P_DITRINA 		66
#define P_BILLFENCE 	67
#define P_OPRAH 		68
#define P_GARDENER 		69
#define P_GLITTON 		70
#define P_PIGFARM 		71
#define P_SOLARADM 		72
#define P_DILLGAS 		73
#define P_WELCOME 		74
#define P_PALDICK 		75
#define P_PALLIBR 		76
#define P_BIOENG 		77
#define P_MONTGAS 		78
#define P_SPRUNK 		79
#define P_BARTHIDE 		80
#define P_BLUETRUCK 	81
#define P_COTTON 		82
#define P_LOGGING 		83
#define P_FLINTRANCH 	84
#define P_RSHAUL 		85
#define P_FALLENTREE 	86
#define P_HUNTING 		87
#define P_GRASS 		88
#define P_JUNKYARD 		89
#define P_ANGELMOT 		90
#define P_SAWMILL 		91
#define P_WHETGAS 		92
#define P_FLINTMOT 		93
#define P_ANGELGAS 		94
#define P_EASTCHEM 		95
#define P_TOBACCO 		96
#define P_DIARY 		97
#define P_SABROAD 		98
#define P_RETIRE 		99
#define P_FBI 			100
#define P_SADIRT 		101
#define P_AVISPA 		102
#define P_HIPPY 		103
#define P_ARTMUS 		104
#define P_SFTOWN 		105
#define P_SAHOSP 		106
#define P_SAMINT 		107
#define P_CITY 			108
#define P_QUEENS 		109
#define P_BIFFIN 		110
#define P_DOJO 			111
#define P_DRUGS 		112
#define P_PUBLICTRAN 	113
#define P_DEA 			114
#define P_SFCONT 		115
#define P_CARINEX 		116
#define P_SOLARFAC 		117
#define P_SFGAS 		118
#define P_SUPERMARK 	119
#define P_CIAOFFICE 	120
#define P_BAYYACHT 		121
#define P_JAYDINER 		122
#define P_CIAHID 		123
#define P_CARSHOTEL 	124
#define P_HIK69 		125
#define P_DRIVEINN 		126
#define P_BOWLED 		127
#define P_KINGRING 		128
#define P_LOOKOUT 		129
#define P_BIGEAR 		130
#define P_REGULAR 		131
#define P_BARRGIFT 		132
#define P_BARTEE 		133
#define P_RONNIECRIB 	134
#define P_BAIT 			135
#define P_ELQUEHOTEL 	136
#define P_ELQUEGAS 		137
#define P_PEUBLOMUS 	138
#define P_VALTEE 		139
#define P_AIRMUS 		140
#define P_LASCHICK 		141
#define P_BONEGAS 		142
#define P_OILREF 		143
#define P_HUNTER 		144
#define P_SHOOTING 		145
#define P_COLLEGE 		146
#define P_SABIKE 		147
#define P_CUSTOMS 		148
#define P_MEATFAC 		149
#define P_LVCARGO 		150
#define P_AIRCONTR 		151
#define P_FIREBRIG 		152
#define P_RIMSHINE 		153
#define P_LVGAS 		154
#define P_STARBUCK 		155
#define P_BEHIND 		156
#define P_LVSOURV 		157
#define P_CENTER 		158
#define P_YELLOWBELL 	159
#define P_TRANSMAIN 	160
#define P_AZTECMOT 		161
#define P_CONCA 		162
#define P_MIDEVAL 		163
#define P_OLDCOWBOY 	164
#define P_KICKHEELS 	165
#define P_ROYALCAS 		166
#define P_COMEALOT 		167
#define P_LVCARGOHAR 	168
#define P_PHEELY 		169
#define P_CHUCKUP 		170
#define P_FINALBUILD 	171
#define P_SHOODY 		172
#define P_TAXICOMP      173
#define P_BANKHACKING   174
#define P_JAILBREAK		175
#define P_JOSDJCON 		176
#define P_ADMWEAP 		177
#define P_SECRWEAP 		178
#define P_BEERTENDER	179
#define P_WARMEMORIAL 	180
#define P_LSSEXXSHOP 	181
#define P_BAHAMAS 		182
#define P_ANGELMED 		183
#define P_ELQMED 		184
#define P_GOLDMINE 		185
#define P_VORTEX 		186
#define P_SPEEDO        187
#define P_SFBANK        188
#define P_GASEMER 		189
#define P_GASBEHCAM 	190
#define P_GASBESCAM 	191
#define P_GASSPINY 		192
#define P_GASTIERRA 	193
#define P_GASJUNIP 		194
#define P_GASIDLE 		195
#define P_GASFLINT 		196
#define P_LSTOWN        197
#define P_SAGOVERN      198
#define P_LVTOWN        199
#define P_FORTCARSONPD  200
#define P_LIFTMECHIL    201
#define P_LIFTMEGATE    202
#define P_LUIGIS        203
#define P_GOLD00 204
#define P_GOLD01 205
#define P_GOLD02 206
#define P_GOLD03 207
#define P_GOLD04 208
#define P_GOLD05 209
#define P_GOLD06 210
#define P_GOLD07 211
#define P_GOLD08 212
#define P_GOLD09 213
#define P_GOLD10 214
#define P_GOLD11 215
#define P_GOLD12 216
#define P_GOLD13 217
#define P_GOLD14 218
#define P_GOLD15 219
#define P_GOLD16 220
#define P_GOLD17 221
#define P_GOLD18 222
#define P_GOLD19 223
#define P_GOLD20 224
#define P_GOLD21 225
#define P_GOLD22 226
#define P_GOLD23 227
#define P_GOLD24 228
#define P_GOLD25 229
#define P_GOLD26 230
#define P_GOLD27 231
#define P_GOLD28 232
#define P_GOLD29 233
#define P_GOLD30 234
#define P_GOLD31 235

#define P_ADMINTELEPORT 236
#define P_ADMINRENTCAR 237

#define CP_TAXI_NONE        0
#define CP_TAXI_SKATEPARK	1
#define CP_TAXI_HOSPITAL    2
#define CP_TAXI_DANCING     3
#define CP_TAXI_UNITY       4
#define CP_TAXI_LIQUOR      5
#define CP_TAXI_SEXSHOP     6
#define CP_TAXI_LSAIRPORT   7
#define CP_TAXI_CARGOCOMPANY    8
#define CP_TAXI_DIRTRING    9
#define CP_TAXI_HOTELBEACH  10
#define CP_TAXI_TENGREENBOTTLES 11
#define CP_TAXI_CHURCH      12
#define CP_TAXI_COUTTANDSCHUTZ  13
#define CP_TAXI_AMMUNATION  14
#define CP_TAXI_LSPD        15
#define CP_TAXI_CONGRESCENTER   16
#define CP_TAXI_PAPERCUTS   17
#define CP_TAXI_BROWNSTARFISH   18
#define CP_TAXI_MALL        19
#define CP_TAXI_JETTYLOUNGE 20
#define CP_TAXI_DIDIERSACHZ 21
#define CP_TAXI_HILLHOTEL   22
#define CP_TAXI_TABLEAU     23
#define CP_TAXI_ELDRITCH    24
#define CP_TAXI_VICECINEMA  25
#define CP_TAXI_FRANKDITRINA    26
#define CP_TAXI_TOMCROSS    27
#define CP_TAXI_OPRAHLINTREY    28
#define CP_TAXI_DILLMOREPD  29
#define CP_TAXI_FOURDRAGONS 30
#define CP_TAXI_COMEALOT    31
#define CP_TAXI_LVAIRPORT   32

#define P_TAXI_SKATEPARK	0
#define P_TAXI_HOSPITAL    1
#define P_TAXI_DANCING     2
#define P_TAXI_UNITY       3
#define P_TAXI_LIQUOR      4
#define P_TAXI_SEXSHOP     5
#define P_TAXI_LSAIRPORT   6
#define P_TAXI_CARGOCOMPANY    7
#define P_TAXI_DIRTRING    8
#define P_TAXI_HOTELBEACH  9
#define P_TAXI_TENGREENBOTTLES 10
#define P_TAXI_CHURCH      11
#define P_TAXI_COUTTANDSCHUTZ  12
#define P_TAXI_AMMUNATION  13
#define P_TAXI_LSPD        14
#define P_TAXI_CONGRESCENTER   15
#define P_TAXI_PAPERCUTS   16
#define P_TAXI_BROWNSTARFISH   17
#define P_TAXI_MALL        18
#define P_TAXI_JETTYLOUNGE 19
#define P_TAXI_DIDIERSACHZ 20
#define P_TAXI_HILLHOTEL   21
#define P_TAXI_TABLEAU     22
#define P_TAXI_ELDRITCH    23
#define P_TAXI_VICECINEMA  24
#define P_TAXI_FRANKDITRINA    25
#define P_TAXI_TOMCROSS    26
#define P_TAXI_OPRAHLINTREY    27
#define P_TAXI_DILLMOREPD  28
#define P_TAXI_FOURDRAGONS 29
#define P_TAXI_COMEALOT    30
#define P_TAXI_LVAIRPORT   31

#define CP_SPRINTRACE3_CP0 0
#define CP_SPRINTRACE3_CP1 1
#define CP_SPRINTRACE3_CP2 2
#define CP_SPRINTRACE3_CP3 3
#define CP_SPRINTRACE3_CP4 4
#define CP_SPRINTRACE3_CP5 5
#define CP_SPRINTRACE3_CP6 6
#define CP_SPRINTRACE3_CP7 7
#define CP_SPRINTRACE3_CP8 8
#define CP_SPRINTRACE3_CP9 9
#define CP_SPRINTRACE3_CP10 10
#define CP_SPRINTRACE3_CP11 11
#define CP_SPRINTRACE3_CP12 12
#define CP_SPRINTRACE3_CP13 13
#define CP_SPRINTRACE3_CP14 14
#define CP_SPRINTRACE3_CP15 15
#define CP_SPRINTRACE3_CP16 16
#define CP_SPRINTRACE3_CP17 17

#define CP_SPRINTRACE4_CP0 0
#define CP_SPRINTRACE4_CP1 1
#define CP_SPRINTRACE4_CP2 2
#define CP_SPRINTRACE4_CP3 3
#define CP_SPRINTRACE4_CP4 4
#define CP_SPRINTRACE4_CP5 5
#define CP_SPRINTRACE4_CP6 6
#define CP_SPRINTRACE4_CP7 7
#define CP_SPRINTRACE4_CP8 8
#define CP_SPRINTRACE4_CP9 9
#define CP_SPRINTRACE4_CP10 10
#define CP_SPRINTRACE4_CP11 11
#define CP_SPRINTRACE4_CP12 12
#define CP_SPRINTRACE4_CP13 13
#define CP_SPRINTRACE4_CP14 14
#define CP_SPRINTRACE4_CP15 15
#define CP_SPRINTRACE4_CP16 16
#define CP_SPRINTRACE4_CP17 17
#define CP_SPRINTRACE4_CP18 18
#define CP_SPRINTRACE4_CP19 19
#define CP_SPRINTRACE4_CP20 20
#define CP_SPRINTRACE4_CP21 21
#define CP_SPRINTRACE4_CP22 22
#define CP_SPRINTRACE4_CP23 23
#define CP_SPRINTRACE4_CP24 24
#define CP_SPRINTRACE4_CP25 25

#define CP_SPRINTRACE5_CP0 0
#define CP_SPRINTRACE5_CP1 1
#define CP_SPRINTRACE5_CP2 2
#define CP_SPRINTRACE5_CP3 3
#define CP_SPRINTRACE5_CP4 4
#define CP_SPRINTRACE5_CP5 5
#define CP_SPRINTRACE5_CP6 6
#define CP_SPRINTRACE5_CP7 7
#define CP_SPRINTRACE5_CP8 8
#define CP_SPRINTRACE5_CP9 9
#define CP_SPRINTRACE5_CP10 10
#define CP_SPRINTRACE5_CP11 11
#define CP_SPRINTRACE5_CP12 12
#define CP_SPRINTRACE5_CP13 13
#define CP_SPRINTRACE5_CP14 14
#define CP_SPRINTRACE5_CP15 15
#define CP_SPRINTRACE5_CP16 16
#define CP_SPRINTRACE5_CP17 17
#define CP_SPRINTRACE5_CP18 18
#define CP_SPRINTRACE5_CP19 19
#define CP_SPRINTRACE5_CP20 20
#define CP_SPRINTRACE5_CP21 21
#define CP_SPRINTRACE5_CP22 22
#define CP_SPRINTRACE5_CP23 23

#define CP_SPRINTRACE6_CP0 0
#define CP_SPRINTRACE6_CP1 1
#define CP_SPRINTRACE6_CP2 2
#define CP_SPRINTRACE6_CP3 3
#define CP_SPRINTRACE6_CP4 4
#define CP_SPRINTRACE6_CP5 5
#define CP_SPRINTRACE6_CP6 6
#define CP_SPRINTRACE6_CP7 7
#define CP_SPRINTRACE6_CP8 8
#define CP_SPRINTRACE6_CP9 9
#define CP_SPRINTRACE6_CP10 10
#define CP_SPRINTRACE6_CP11 11
#define CP_SPRINTRACE6_CP12 12
#define CP_SPRINTRACE6_CP13 13
#define CP_SPRINTRACE6_CP14 14
#define CP_SPRINTRACE6_CP15 15
#define CP_SPRINTRACE6_CP16 16
#define CP_SPRINTRACE6_CP17 17
#define CP_SPRINTRACE6_CP18 18
#define CP_SPRINTRACE6_CP19 19
#define CP_SPRINTRACE6_CP20 20
#define CP_SPRINTRACE6_CP21 21
#define CP_SPRINTRACE6_CP22 22
#define CP_SPRINTRACE6_CP23 23
#define CP_SPRINTRACE6_CP24 24
#define CP_SPRINTRACE6_CP25 25
#define CP_SPRINTRACE6_CP26 26

#define CP_SPRINTRACE7_CP0 0
#define CP_SPRINTRACE7_CP1 1
#define CP_SPRINTRACE7_CP2 2
#define CP_SPRINTRACE7_CP3 3
#define CP_SPRINTRACE7_CP4 4
#define CP_SPRINTRACE7_CP5 5
#define CP_SPRINTRACE7_CP6 6
#define CP_SPRINTRACE7_CP7 7
#define CP_SPRINTRACE7_CP8 8
#define CP_SPRINTRACE7_CP9 9
#define CP_SPRINTRACE7_CP10 10
#define CP_SPRINTRACE7_CP11 11
#define CP_SPRINTRACE7_CP12 12
#define CP_SPRINTRACE7_CP13 13
#define CP_SPRINTRACE7_CP14 14
#define CP_SPRINTRACE7_CP15 15
#define CP_SPRINTRACE7_CP16 16
#define CP_SPRINTRACE7_CP17 17
#define CP_SPRINTRACE7_CP18 18
#define CP_SPRINTRACE7_CP19 19
#define CP_SPRINTRACE7_CP20 20
#define CP_SPRINTRACE7_CP21 21
#define CP_SPRINTRACE7_CP22 22
#define CP_SPRINTRACE7_CP23 23
#define CP_SPRINTRACE7_CP24 24
#define CP_SPRINTRACE7_CP25 25
#define CP_SPRINTRACE7_CP26 26
#define CP_SPRINTRACE7_CP27 27
#define CP_SPRINTRACE7_CP28 28
#define CP_SPRINTRACE7_CP29 29
#define CP_SPRINTRACE7_CP30 30
#define CP_SPRINTRACE7_CP31 31
#define CP_SPRINTRACE7_CP32 32
#define CP_SPRINTRACE7_CP33 33
#define CP_SPRINTRACE7_CP34 34
#define CP_SPRINTRACE7_CP35 35
#define CP_SPRINTRACE7_CP36 36

#define CP_MOTORRACE1_CP0 0
#define CP_MOTORRACE1_CP1 1
#define CP_MOTORRACE1_CP2 2
#define CP_MOTORRACE1_CP3 3
#define CP_MOTORRACE1_CP4 4
#define CP_MOTORRACE1_CP5 5
#define CP_MOTORRACE1_CP6 6
#define CP_MOTORRACE1_CP7 7
#define CP_MOTORRACE1_CP8 8
#define CP_MOTORRACE1_CP9 9
#define CP_MOTORRACE1_CP10 10
#define CP_MOTORRACE1_CP11 11
#define CP_MOTORRACE1_CP12 12
#define CP_MOTORRACE1_CP13 13
#define CP_MOTORRACE1_CP14 14
#define CP_MOTORRACE1_CP15 15
#define CP_MOTORRACE1_CP16 16
#define CP_MOTORRACE1_CP17 17
#define CP_MOTORRACE1_CP18 18
#define CP_MOTORRACE1_CP19 19
#define CP_MOTORRACE1_CP20 20
#define CP_MOTORRACE1_CP21 21
#define CP_MOTORRACE1_CP22 22

#define CP_MOTORRACE2_CP0 0
#define CP_MOTORRACE2_CP1 1
#define CP_MOTORRACE2_CP2 2
#define CP_MOTORRACE2_CP3 3
#define CP_MOTORRACE2_CP4 4
#define CP_MOTORRACE2_CP5 5
#define CP_MOTORRACE2_CP6 6
#define CP_MOTORRACE2_CP7 7
#define CP_MOTORRACE2_CP8 8
#define CP_MOTORRACE2_CP9 9
#define CP_MOTORRACE2_CP10 10
#define CP_MOTORRACE2_CP11 11
#define CP_MOTORRACE2_CP12 12
#define CP_MOTORRACE2_CP13 13
#define CP_MOTORRACE2_CP14 14
#define CP_MOTORRACE2_CP15 15
#define CP_MOTORRACE2_CP16 16
#define CP_MOTORRACE2_CP17 17
#define CP_MOTORRACE2_CP18 18
#define CP_MOTORRACE2_CP19 19
#define CP_MOTORRACE2_CP20 20
#define CP_MOTORRACE2_CP21 21
#define CP_MOTORRACE2_CP22 22
#define CP_MOTORRACE2_CP23 23
#define CP_MOTORRACE2_CP24 24
#define CP_MOTORRACE2_CP25 25
#define CP_MOTORRACE2_CP26 26
#define CP_MOTORRACE2_CP27 27
#define CP_MOTORRACE2_CP28 28
#define CP_MOTORRACE2_CP29 29
#define CP_MOTORRACE2_CP30 30
#define CP_MOTORRACE2_CP31 31

#define CP_MOTORRACE3_CP0 0
#define CP_MOTORRACE3_CP1 1
#define CP_MOTORRACE3_CP2 2
#define CP_MOTORRACE3_CP3 3
#define CP_MOTORRACE3_CP4 4
#define CP_MOTORRACE3_CP5 5
#define CP_MOTORRACE3_CP6 6
#define CP_MOTORRACE3_CP7 7
#define CP_MOTORRACE3_CP8 8
#define CP_MOTORRACE3_CP9 9
#define CP_MOTORRACE3_CP10 10
#define CP_MOTORRACE3_CP11 11
#define CP_MOTORRACE3_CP12 12
#define CP_MOTORRACE3_CP13 13
#define CP_MOTORRACE3_CP14 14
#define CP_MOTORRACE3_CP15 15
#define CP_MOTORRACE3_CP16 16
#define CP_MOTORRACE3_CP17 17
#define CP_MOTORRACE3_CP18 18
#define CP_MOTORRACE3_CP19 19
#define CP_MOTORRACE3_CP20 20
#define CP_MOTORRACE3_CP21 21
#define CP_MOTORRACE3_CP22 22
#define CP_MOTORRACE3_CP23 23

#define CP_MOTORRACE4_CP0 0
#define CP_MOTORRACE4_CP1 1
#define CP_MOTORRACE4_CP2 2
#define CP_MOTORRACE4_CP3 3
#define CP_MOTORRACE4_CP4 4
#define CP_MOTORRACE4_CP5 5
#define CP_MOTORRACE4_CP6 6
#define CP_MOTORRACE4_CP7 7
#define CP_MOTORRACE4_CP8 8
#define CP_MOTORRACE4_CP9 9
#define CP_MOTORRACE4_CP10 10
#define CP_MOTORRACE4_CP11 11
#define CP_MOTORRACE4_CP12 12
#define CP_MOTORRACE4_CP13 13
#define CP_MOTORRACE4_CP14 14
#define CP_MOTORRACE4_CP15 15
#define CP_MOTORRACE4_CP16 16
#define CP_MOTORRACE4_CP17 17

#define CP_MOTORRACE5_CP0 0
#define CP_MOTORRACE5_CP1 1
#define CP_MOTORRACE5_CP2 2
#define CP_MOTORRACE5_CP3 3
#define CP_MOTORRACE5_CP4 4
#define CP_MOTORRACE5_CP5 5
#define CP_MOTORRACE5_CP6 6
#define CP_MOTORRACE5_CP7 7
#define CP_MOTORRACE5_CP8 8
#define CP_MOTORRACE5_CP9 9
#define CP_MOTORRACE5_CP10 10
#define CP_MOTORRACE5_CP11 11
#define CP_MOTORRACE5_CP12 12
#define CP_MOTORRACE5_CP13 13
#define CP_MOTORRACE5_CP14 14
#define CP_MOTORRACE5_CP15 15
#define CP_MOTORRACE5_CP16 16
#define CP_MOTORRACE5_CP17 17
#define CP_MOTORRACE5_CP18 18
#define CP_MOTORRACE5_CP19 19
#define CP_MOTORRACE5_CP20 20
#define CP_MOTORRACE5_CP21 21
#define CP_MOTORRACE5_CP22 22
#define CP_MOTORRACE5_CP23 23
#define CP_MOTORRACE5_CP24 24
#define CP_MOTORRACE5_CP25 25
#define CP_MOTORRACE5_CP26 26
#define CP_MOTORRACE5_CP27 27

#define SPRINTRACE3CPS 18
#define SPRINTRACE4CPS 25
#define SPRINTRACE5CPS 20
#define SPRINTRACE6CPS 23
#define SPRINTRACE7CPS 37
#define MOTORRACE1CPS 23
#define MOTORRACE2CPS 32
#define MOTORRACE3CPS 24
#define MOTORRACE4CPS 18
#define MOTORRACE5CPS 28

#define P_OFFSET    2

#define MAX_CARS	254

#define dcmd(%1,%2,%3) if ((strcmp(%3, "/%1", true, %2+1) == 0)&&(((%3[%2+1]==0)&&(dcmd_%1(playerid,"")))||((%3[%2+1]==32)&&(dcmd_%1(playerid,%3[%2+2]))))) return 1

forward SetPlayerRandomSpawn(playerid);
forward SetupPlayerForClassSelection(playerid);
forward GameModeExitFunc();

new strings[256];
new tmps1[256];
new tmps2[256];
new tmps3[256];
new moneyreason[256];
new cmd[256];
new playermoney;
new playername[MAX_PLAYER_NAME];
new sendername[MAX_PLAYER_NAME];
new giveplayer[MAX_PLAYER_NAME];
new giveplayerid;
new moneys;

new iSpawnSet[MAX_PLAYERS];
new currentmoney[MAX_PLAYERS];
new bank[MAX_PLAYERS];
new bounty[MAX_PLAYERS];
new playerCheckpoint[MAX_PLAYERS];
new worldTime;
new GameHours;
new GameMinutes = 1;
new DayOTWeek;
new god[MAX_PLAYERS];
new payment[MAX_PLAYERS];
new query[MAX_PLAYERS];
new jailed[MAX_PLAYERS];
new jailtime[MAX_PLAYERS];
new jailcelcounter;
new Float:jailcelloc[4][3] = {
	{227.3273,111.5,999.0156},
	{223.3339,111.5,999.0156},
	{219.4635,111.5,999.0156},
	{215.6566,111.5,999.0156}
};
new jailoutbreak[MAX_PLAYERS];

new muted[MAX_PLAYERS];
new mutetime[MAX_PLAYERS];
new logged[MAX_PLAYERS];
new admindived[MAX_PLAYERS];
new adminlevel[MAX_PLAYERS];
new hideoutwarning[MAX_PLAYERS];
new minigunwarning[MAX_PLAYERS];
new gamblelicence[MAX_PLAYERS];
new spawned[MAX_PLAYERS];
new SpawnTimeout[MAX_PLAYERS];
new isincasino[MAX_PLAYERS];
new isprotected[MAX_PLAYERS];
new FirstSpawn[MAX_PLAYERS];
new countdownseconds = 0;
new commandlogenabled = 1;
//new enablegod = 0; // 1 doesnt work i.c.m. AntiCheat
new moneyfterkill = 0; //Disabled because function where used is disabled
//bug in dini
new moneyscanner = 1;

new TaxFree = 750000;
new TaxLevel2 = 2500000;
new TaxLevel3 = 4000000;
new TaxPercentage1 = 10; //10%
new TaxPercentage2 = 5; //20%
new TaxPercentage3 = 3; //33%

//Floats for calculating coords
new Float:PF[MAX_PLAYERS];
new Float:QF[MAX_PLAYERS];
new Float:RF[MAX_PLAYERS];
new Float:PFold[MAX_PLAYERS];
new Float:QFold[MAX_PLAYERS];
new Float:RFold[MAX_PLAYERS];
new InteriorID[MAX_PLAYERS];

new WaitingTime[MAX_PLAYERS];
new TaxiLocname[MAX_PLAYERS] [32];
new RequestedTaxi[MAX_PLAYERS];
new WaitingTime2[MAX_PLAYERS];
new RequestedTaxi2[MAX_PLAYERS];

new BankHackTime[MAX_PLAYERS];
new BankHacker[MAX_PLAYERS];
new BankHackVictim[MAX_PLAYERS];
new BankHackVictimAttempt[MAX_PLAYERS];
new BankHackPassword[MAX_PLAYERS];
new BankHackAttempt[MAX_PLAYERS];
new BankHackWarning[MAX_PLAYERS];
new BankHackTimer[MAX_PLAYERS];

new JailBreakTime[MAX_PLAYERS];
new JailBreaker[MAX_PLAYERS];
new JailBreakPassword[MAX_PLAYERS];
new JailBreakAttempt[MAX_PLAYERS];
new JailBreakWarning[MAX_PLAYERS];
new JailBreakTimer[MAX_PLAYERS];

new TaxiUsedNew[MAX_PLAYERS];
new TaxiUsedPoor[MAX_PLAYERS];
new TaxiUsedRich[MAX_PLAYERS];
new TaxiUpcomingDrive[MAX_PLAYERS];
new TotalMoney[MAX_PLAYERS];

new Medic[MAX_PLAYERS];
new OwnHeal[MAX_PLAYERS];

new eaglematch[2];
new deathmatcher1[MAX_PLAYERS];
new eaglecountdownseconds;
new eaglecountdownseconds2;
new eaglematchstarted;
new eaglematchplayers[MAX_PLAYERS];
new playerseaglematch;
new eaglematchinprogress;

new chainmatch[4];
new deathmatcher4[MAX_PLAYERS];
new chaincountdownseconds;
new chaincountdownseconds2;
new chainmatchstarted;
new chainmatchprice;
new chainmatchplayer[MAX_PLAYERS];
new chainmatchplayers[MAX_PLAYERS];
new playerschainmatch;
new chainmatchinprogress;

new minimatch[6];
new deathmatcher5[MAX_PLAYERS];
new minicountdownseconds;
new minicountdownseconds2;
new minimatchstarted;
new minimatchprice;
new minimatchplayer[MAX_PLAYERS];
new minimatchplayers[MAX_PLAYERS];
new playersminimatch;
new minimatchinprogress;

new uzimatch[6];
new deathmatcher6[MAX_PLAYERS];
new uzicountdownseconds;
new uzicountdownseconds2;
new uzimatchstarted;
new uzimatchprice;
new uzimatchplayer[MAX_PLAYERS];
new uzimatchplayers[MAX_PLAYERS];
new playersuzimatch;
new uzimatchinprogress;

new dragrace1[2];
new deathmatcher7[MAX_PLAYERS];
new dragrace1countdownseconds;
new dragrace1started;
new dragrace1players[MAX_PLAYERS];
new playersdragrace1;
new dragrace1inprogress;
new dragrace1racer[2];
new DragRace1TimeLimit;
new DragRaceCountdown2Seconds;
new DragRace1Finish;

new dragrace2[4];
new deathmatcher8[MAX_PLAYERS];
new dragrace2countdownseconds;
new dragrace2started;
new dragrace2players[MAX_PLAYERS];
new playersdragrace2;
new dragrace2inprogress;
new dragrace2racer[4];
new DragRace2TimeLimit;
new DragRace2Countdown2Seconds;
new DragRace2Finish;
new dragrace2money;

new dragrace3[2];
new deathmatcher9[MAX_PLAYERS];
new dragrace3countdownseconds;
new dragrace3started;
new dragrace3players[MAX_PLAYERS];
new playersdragrace3;
new dragrace3inprogress;
new dragrace3racer[2];
new DragRace3TimeLimit;
new DragRace3Countdown2Seconds;
new DragRace3Finish;

new dragrace4[2];
new deathmatcher11[MAX_PLAYERS];
new dragrace4countdownseconds;
new dragrace4started;
new dragrace4players[MAX_PLAYERS];
new playersdragrace4;
new dragrace4inprogress;
new dragrace4racer[2];
new DragRace4TimeLimit;
new DragRace4Countdown2Seconds;
new DragRace4Finish;

new dragrace5[2];
new deathmatcher13[MAX_PLAYERS];
new dragrace5countdownseconds;
new dragrace5started;
new dragrace5players[MAX_PLAYERS];
new playersdragrace5;
new dragrace5inprogress;
new dragrace5racer[2];
new DragRace5TimeLimit;
new DragRace5Countdown2Seconds;
new DragRace5Finish;

new dragrace6[2];
new deathmatcher14[MAX_PLAYERS];
new dragrace6countdownseconds;
new dragrace6started;
new dragrace6players[MAX_PLAYERS];
new playersdragrace6;
new dragrace6inprogress;
new dragrace6racer[2];
new DragRace6TimeLimit;
new DragRace6Countdown2Seconds;
new DragRace6Finish;

new dragrace7[2];
new deathmatcher15[MAX_PLAYERS];
new dragrace7countdownseconds;
new dragrace7started;
new dragrace7players[MAX_PLAYERS];
new playersdragrace7;
new dragrace7inprogress;
new dragrace7racer[2];
new DragRace7TimeLimit;
new DragRace7Countdown2Seconds;
new DragRace7Finish;

new dragrace8[2];
new deathmatcher16[MAX_PLAYERS];
new dragrace8countdownseconds;
new dragrace8started;
new dragrace8players[MAX_PLAYERS];
new playersdragrace8;
new dragrace8inprogress;
new dragrace8racer[2];
new DragRace8TimeLimit;
new DragRace8Countdown2Seconds;
new DragRace8Finish;

new dragrace9[2];
new deathmatcher17[MAX_PLAYERS];
new dragrace9countdownseconds;
new dragrace9started;
new dragrace9players[MAX_PLAYERS];
new playersdragrace9;
new dragrace9inprogress;
new dragrace9racer[2];
new DragRace9TimeLimit;
new DragRace9Countdown2Seconds;
new DragRace9Finish;

new sprintrace1[4];
new deathmatcher10[MAX_PLAYERS];
new sprintrace1countdownseconds;
new sprintrace1started;
new sprintrace1players[MAX_PLAYERS];
new playerssprintrace1;
new sprintrace1inprogress;
new sprintrace1racer[4];
new SprintRace1TimeLimit;
new SprintRace1Countdown2Seconds;
new SprintRace1Finish;
new sprintrace1money;

new sprintrace2[4];
new deathmatcher12[MAX_PLAYERS];
new sprintrace2countdownseconds;
new sprintrace2started;
new sprintrace2players[MAX_PLAYERS];
new playerssprintrace2;
new sprintrace2inprogress;
new sprintrace2racer[4];
new SprintRace2TimeLimit;
new SprintRace2Countdown2Seconds;
new SprintRace2Finish;
new sprintrace2money;

new sprintrace3[2];
new deathmatcher18[MAX_PLAYERS];
new sprintrace3countdownseconds;
new sprintrace3started;
new sprintrace3players[MAX_PLAYERS];
new playerssprintrace3;
new sprintrace3inprogress;
new sprintrace3racer[2];
new SprintRace3Countdown2Seconds;
new SprintRace3NextCP[MAX_PLAYERS];
new SprintRace3CPCounter[MAX_PLAYERS];
new SprintRace3Finisher;

new sprintrace4[2];
new deathmatcher19[MAX_PLAYERS];
new sprintrace4countdownseconds;
new sprintrace4started;
new sprintrace4players[MAX_PLAYERS];
new playerssprintrace4;
new sprintrace4inprogress;
new sprintrace4racer[2];
new SprintRace4Countdown2Seconds;
new SprintRace4NextCP[MAX_PLAYERS];
new SprintRace4CPCounter[MAX_PLAYERS];
new SprintRace4Finisher;

new sprintrace5[2];
new deathmatcher20[MAX_PLAYERS];
new sprintrace5countdownseconds;
new sprintrace5started;
new sprintrace5players[MAX_PLAYERS];
new playerssprintrace5;
new sprintrace5inprogress;
new sprintrace5racer[2];
new SprintRace5Countdown2Seconds;
new SprintRace5NextCP[MAX_PLAYERS];
new SprintRace5CPCounter[MAX_PLAYERS];
new SprintRace5Finisher;

new sprintrace6[2];
new deathmatcher21[MAX_PLAYERS];
new sprintrace6countdownseconds;
new sprintrace6started;
new sprintrace6players[MAX_PLAYERS];
new playerssprintrace6;
new sprintrace6inprogress;
new sprintrace6racer[2];
new SprintRace6Countdown2Seconds;
new SprintRace6NextCP[MAX_PLAYERS];
new SprintRace6CPCounter[MAX_PLAYERS];
new SprintRace6Finisher;

new sprintrace7[2];
new deathmatcher22[MAX_PLAYERS];
new sprintrace7countdownseconds;
new sprintrace7started;
new sprintrace7players[MAX_PLAYERS];
new playerssprintrace7;
new sprintrace7inprogress;
new sprintrace7racer[2];
new SprintRace7Countdown2Seconds;
new SprintRace7NextCP[MAX_PLAYERS];
new SprintRace7CPCounter[MAX_PLAYERS];
new SprintRace7Finisher;

new motorrace1[2];
new deathmatcher24[MAX_PLAYERS];
new motorrace1countdownseconds;
new motorrace1started;
new motorrace1players[MAX_PLAYERS];
new playersmotorrace1;
new motorrace1inprogress;
new motorrace1racer[2];
new MotorRace1Countdown2Seconds;
new MotorRace1NextCP[MAX_PLAYERS];
new MotorRace1CPCounter[MAX_PLAYERS];
new MotorRace1Finisher;

new motorrace2[2];
new deathmatcher25[MAX_PLAYERS];
new motorrace2countdownseconds;
new motorrace2started;
new motorrace2players[MAX_PLAYERS];
new playersmotorrace2;
new motorrace2inprogress;
new motorrace2racer[2];
new MotorRace2Countdown2Seconds;
new MotorRace2NextCP[MAX_PLAYERS];
new MotorRace2CPCounter[MAX_PLAYERS];
new MotorRace2Finisher;

new motorrace3[2];
new deathmatcher26[MAX_PLAYERS];
new motorrace3countdownseconds;
new motorrace3started;
new motorrace3players[MAX_PLAYERS];
new playersmotorrace3;
new motorrace3inprogress;
new motorrace3racer[2];
new MotorRace3Countdown2Seconds;
new MotorRace3NextCP[MAX_PLAYERS];
new MotorRace3CPCounter[MAX_PLAYERS];
new MotorRace3Finisher;

new motorrace4[2];
new deathmatcher27[MAX_PLAYERS];
new motorrace4countdownseconds;
new motorrace4started;
new motorrace4players[MAX_PLAYERS];
new playersmotorrace4;
new motorrace4inprogress;
new motorrace4racer[2];
new MotorRace4Countdown2Seconds;
new MotorRace4NextCP[MAX_PLAYERS];
new MotorRace4CPCounter[MAX_PLAYERS];
new MotorRace4Finisher;

new motorrace5[2];
new deathmatcher28[MAX_PLAYERS];
new motorrace5countdownseconds;
new motorrace5started;
new motorrace5players[MAX_PLAYERS];
new playersmotorrace5;
new motorrace5inprogress;
new motorrace5racer[2];
new MotorRace5Countdown2Seconds;
new MotorRace5NextCP[MAX_PLAYERS];
new MotorRace5CPCounter[MAX_PLAYERS];
new MotorRace5Finisher;

new	dragracer[MAX_PLAYERS];
new RaceTime[MAX_PLAYERS];
new RaceTiming[MAX_PLAYERS];
new CrossedCheckpoints[MAX_PLAYERS];
new CheckpointsToBeCrossed[MAX_PLAYERS];
new CancelSprint3;
new CancelSprint4;
new CancelSprint5;
new CancelSprint6;
new CancelSprint7;
new CancelMotor1;
new CancelMotor2;
new CancelMotor3;
new CancelMotor4;
new CancelMotor5;
new sprintracer[MAX_PLAYERS];
new motorracer[MAX_PLAYERS];
new AutoCancelSprint3;
new AutoCancelSprint4;
new AutoCancelSprint5;
new AutoCancelSprint6;
new AutoCancelSprint7;
new AutoCancelMotor1;
new AutoCancelMotor2;
new AutoCancelMotor3;
new AutoCancelMotor4;
new AutoCancelMotor5;

new Float:XLast[MAX_PLAYERS];
new Float:YLast[MAX_PLAYERS];
new Float:ZLast[MAX_PLAYERS];
new Float:Xsec[MAX_PLAYERS];
new Float:Ysec[MAX_PLAYERS];
new Float:Zsec[MAX_PLAYERS];
new Float:X250[MAX_PLAYERS];
new Float:Y250[MAX_PLAYERS];
new Float:Z250[MAX_PLAYERS];
new PlayerSec;

new SpeedMode = 0; // 0 for KPH, 1 for MPH
new speedometer[MAX_PLAYERS];
new speedometeron[MAX_PLAYERS];
new calculatespeed[MAX_PLAYERS];

new DMplayer[MAX_PLAYERS];

new ErrorCounter;

new GroupTalk;
new GroupTalkers[MAX_PLAYERS];
new GroupInvites[MAX_PLAYERS];
new GroupInviter[MAX_PLAYERS];

new Float:CarSprayX[MAX_PLAYERS];
new Float:CarSprayY[MAX_PLAYERS];
new Float:CarSprayZ[MAX_PLAYERS];
new CarSprayVehicleid[MAX_PLAYERS];
new CarSprayCountdown[MAX_PLAYERS];
new payandspray[MAX_PLAYERS];
new askedpayandspray[MAX_PLAYERS];
new readypayandspray[MAX_PLAYERS];

new LowTunerVehicleid[MAX_PLAYERS];
new LowTunerCountdown[MAX_PLAYERS];
new askedlowtuner[MAX_PLAYERS];
new lowtunerback[MAX_PLAYERS];
new readylowtuner[MAX_PLAYERS];
new StreetTunerVehicleid[MAX_PLAYERS];
new StreetTunerCountdown[MAX_PLAYERS];
new askedstreettuner[MAX_PLAYERS];
new streettunerback[MAX_PLAYERS];
new readystreettuner[MAX_PLAYERS];

new LoginTimeout[MAX_PLAYERS];

new ForbiddenTuningTimes[MAX_PLAYERS];
new ForbiddenTuningBool[MAX_PLAYERS];
new DrivebyWarning[MAX_PLAYERS];
new WeaponCheatWarning[MAX_PLAYERS];
new LVPartytime;

new TaxiCreditcard[MAX_PLAYERS];

new SpyPlayer[MAX_PLAYERS];
new SpyPlayerOn[MAX_PLAYERS];
new SpyTimer[MAX_PLAYERS];

new Float:VehiclePetrol[255];
new Float:CarXPos[MAX_PLAYERS];
new Float:CarYPos[MAX_PLAYERS];
new Float:CarZPos[MAX_PLAYERS];
new CurrentVehicle[MAX_PLAYERS];
new VehicleTankWarning[MAX_CARS];
new TotalPetrol[MAX_PLAYERS];
new Tanking[MAX_PLAYERS];
new Teleporting[MAX_PLAYERS];
new VehicleGroup[MAX_PLAYERS];
new FuelmeterOff[MAX_PLAYERS];
new RemovedFromCar[MAX_PLAYERS];

new spawnloc[MAX_PLAYERS];
new SpawnViewCountdown[MAX_PLAYERS];
new AskedSpawnView1[MAX_PLAYERS];
new AskedSpawnView2[MAX_PLAYERS];
new SpawnViewer[MAX_PLAYERS];
new askedcardive[MAX_PLAYERS];
new CarDiveCountdownSeconds[MAX_PLAYERS];
new OwnSpawner[MAX_PLAYERS];
new PlayersSpeed[MAX_PLAYERS];
new PirateMoneyMessageCounter[MAX_PLAYERS];
new RegularPlayer[MAX_PLAYERS];
new NoReset[MAX_PLAYERS];
new Kills[MAX_PLAYERS];
new Deaths[MAX_PLAYERS];
new Suicides[MAX_PLAYERS];

new Fined[MAX_PLAYERS];
new OutOfRanger[MAX_PLAYERS];
new GetBackInRanger;
new HighwayOnMission[MAX_PLAYERS];
new BackInRangerCounter[MAX_PLAYERS];
new HighwayMission;
new HighwayOfficerColor;

new Uptime;
new Uptime_hours;
new Uptime_days;

new melee[MAX_PLAYERS];
new pistol[MAX_PLAYERS];
new pistolammo[MAX_PLAYERS];
new shotgun[MAX_PLAYERS];
new shotgunammo[MAX_PLAYERS];
new smg[MAX_PLAYERS];
new smgammo[MAX_PLAYERS];
new rifle[MAX_PLAYERS];
new rifleammo[MAX_PLAYERS];
new gift[MAX_PLAYERS];
new DisarmedPlayer[MAX_PLAYERS];
new DisplayMessage[MAX_PLAYERS];
new SpawnedPlayer[MAX_PLAYERS];

new Chairlifter1[MAX_PLAYERS];
new Chairliftcounter1[MAX_PLAYERS];
new Chairlifter2[MAX_PLAYERS];
new Chairliftcounter2[MAX_PLAYERS];
new ChairliftDelay[MAX_PLAYERS];

new AmbuHealing[2] ={
999,
999
};

new EnteredVehicle[MAX_PLAYERS];

new MedicalOfficer[MAX_PLAYERS];
new MedicalOfficerOnMission[MAX_PLAYERS];
new OutOfAmbu[MAX_PLAYERS];
new GetBackInAmbu[MAX_PLAYERS];
new BackInAmbuCounter[MAX_PLAYERS];

new Float:adShip[4] = {1995.5, 1518.0, 2006.0, 1569.0};
new Float:adShip2[4] = {2005.9633, 1540.1378, 2025.2864, 1550.3344};
new Float:adShip3[4] = {2000.8032,1543.3296,2002.8032,1545.3296};
new Float:adTransfender[4] = {615.5239,-3.9915,620.5239,-0.9915};
new Float:adTransfenderLV[4] = {2366.6978,1027.5732,2416.6978,1067.5732};
new Float:adOutsideFenderLV[4][3] = {
	{2391.0,988.0,14.0},
	{2391.0,993.0,14.0},
	{2391.0,998.0,14.0},
	{2391.0,1003.0,14.0}
};
new Float:adTransfenderSF[4] = {-1951.4281,231.0493,-1925.5331,259.7066};
new Float:adOutsideFenderSF[4][3] = {
	{-1976.0,176.0,30.0},
	{-1976.0,182.0,30.0},
	{-1976.0,188.0,30.0},
	{-1976.0,194.0,30.0}
};
new Float:adTransfenderLS[4] = {1023.8472,-1030.0055,1049.9963,-1005.3636};
new Float:adOutsideFenderLS[4][3] = {
	{1040.8,-1051.3,33.0},
	{1028.3,-1051.3,33.0},
	{1016.5,-1051.3,33.0},
	{1004.0,-1051.3,33.0}
};
new Float:adArchangels[4] = {613.0239,-125.9915,617.5239,-122.9915};
new Float:adArchangelsOut[4] = {-2749.9180,208.1551,-2709.2837,232.5087};
new Float:adOutsideArchangels[5][3] = {
	{-2692.0,205.8,7.0},
	{-2675.7,205.8,7.0},
	{-2667.0,205.8,7.0},
	{-2663.2,205.8,7.0},
	{-2648.7,205.8,7.0}
};
new Float:adLowrider[4] = {613.7867,-77.8150,619.7867,-71.8150};
new Float:adLowriderOut[4] = {2641.1985,-2053.2351,2649.0117,-2036.6528};
new Float:adOutsideLowrider[4][3] = {
	{2728.9695,-1969.6730,13.0964},
	{2728.7979,-1953.1715,13.0937},
	{2729.0740,-1944.7288,13.0948},
	{2728.2764,-1935.8933,13.0898}
};

new OldTaxiRate[MAX_PLAYERS];
new BankAmount[MAX_PLAYERS];
new fine[MAX_PLAYERS];
new PlayerDisarmDelay[MAX_PLAYERS];
new AdminPlayer[MAX_PLAYERS];

new GlobalPizza1;
new GlobalPizza2;
new GlobalPizza3;
new GlobalPizza4;
new GlobalPizza5;
new GlobalPizzaMan1[MAX_PLAYER_NAME];
new GlobalPizzaMan2[MAX_PLAYER_NAME];
new GlobalPizzaMan3[MAX_PLAYER_NAME];
new GlobalPizzaMan4[MAX_PLAYER_NAME];
new GlobalPizzaMan5[MAX_PLAYER_NAME];
new PizzaNextCP[MAX_PLAYERS];
new PizzaTimer[MAX_PLAYERS];
new PizzaDelivered[MAX_PLAYERS];
new Pizza[MAX_PLAYERS];
new PizzaExtraTime[MAX_PLAYERS];
new PizzaExtraTimeDisplay[MAX_PLAYERS];
new PizzaReturnTrip[MAX_PLAYERS];
new PizzaTotalTime[MAX_PLAYERS];
new PizzaWaitTime[MAX_PLAYERS];
new PizzaVehicle[MAX_PLAYERS];

new GlobalTaxi1;
new GlobalTaxi2;
new GlobalTaxi3;
new GlobalTaxi4;
new GlobalTaxi5;
new GlobalTaxiMan1[MAX_PLAYER_NAME];
new GlobalTaxiMan2[MAX_PLAYER_NAME];
new GlobalTaxiMan3[MAX_PLAYER_NAME];
new GlobalTaxiMan4[MAX_PLAYER_NAME];
new GlobalTaxiMan5[MAX_PLAYER_NAME];
new TaxiNextCP[MAX_PLAYERS];
new TaxiTimer[MAX_PLAYERS];
new TaxiDelivered[MAX_PLAYERS];
new TaxiDriver[MAX_PLAYERS];
new TaxiExtraTime[MAX_PLAYERS];
new TaxiExtraTimeDisplay[MAX_PLAYERS];
new TaxiReturnTrip[MAX_PLAYERS];
new TaxiTotalTime[MAX_PLAYERS];
new TaxiWaitTime[MAX_PLAYERS];
new TaxiVehicle[MAX_PLAYERS];
new TaxiDistance[MAX_PLAYERS];
new ApplyTaxi[MAX_PLAYERS];
new NewTaxiDriver[MAX_PLAYERS];

new TransFenderTuner[MAX_PLAYERS];
new ArchangelsTuner[MAX_PLAYERS];
new LowriderTuner[MAX_PLAYERS];
new TransFenderLVCounter;
new TransFenderSFCounter;
new TransFenderLSCounter;
new ArchangelsCounter;
new LowriderCounter;

new Helper[MAX_PLAYERS];
new NewPlayer[MAX_PLAYERS];

new VehicleModels[255];
new VC;

new MuteAll;
new FloodProtectionTimer[MAX_PLAYERS];
new FloodProtectionCounter[MAX_PLAYERS];
new PropUpDateTimer;

new PMSpyOn[MAX_PLAYERS];
new PMListen[MAX_PLAYERS];

new ToBeKicked[MAX_PLAYERS];
new ToBeBanned[MAX_PLAYERS];

new IgnorePlayerlist[MAX_PLAYERS][MAX_PLAYERS];

new WelFare[MAX_PLAYERS];
new	FirstWellfare[MAX_PLAYERS];

new VisitingPrison[MAX_PLAYERS];

new Transfered[MAX_PLAYERS];

new PlayerEnteredCheckpoint[MAX_PLAYERS];
new Killed[MAX_PLAYERS];

new GameTextForPlayers1[MAX_PLAYERS][36];
new GameTextForPlayers2[MAX_PLAYERS][36];
new GameTextForPlayersCounter[MAX_PLAYERS];

new SystemTime[12];

new ScriptVersion[12];

new OwnPlayerColor[MAX_PLAYERS];
new OwnPlayerColorChosen[MAX_PLAYERS];

new MoneyChecking[MAX_PLAYERS];
new MoneyTransferAmount[MAX_PLAYERS];
new MoneyTransferReason[MAX_PLAYERS][128];

new medicalreward[2] = {
	2500,
	2500
};

new KilometerPerLiter[12] = {
	18, //Bike
	13, //Normal car
	8,  //Performance car
	11, //Streetracers
	10, //Bus / truck
	15, //Boat
	15, //Airplaine prop
	10,  //Helicopter
	10, //Airplane jet small
	5,  //Airplane jet big
	0,
	13 // Taxi's
};

new Float:PetrolTank[12] = {
	20.0, //Bike
	60.0, //Normal car
	80.0,  //Performance car
	60.0, //Streetracers
	200.0, //Bus / truck
	50.0, //Boat
	40.0, //Airplaine prop
	100.0,  //Helicopter
	120.0, //Airplane jet small
	400.0,  //Airplane jet big
	0.0,
	80.0 //Taxi's
};

new VehicleMaxSpeed[12] = {
	240,
	200,
	260,
	210,
	180,
	220,
	300,
	210,
	350,
	350,
	0,
	200
};

new Float:CarLocation[MAX_CARS][4];

#define MAX_STATIONS 26
new Float:Station[MAX_STATIONS][5] = {
	{991.8250,-942.8740,1014.3935,-934.2750,46.0000}, //gasstation vinewood
	{1931.2257,-1783.3851,1951.4963,-1760.0319,18.0000}, //gasstation grove
	{-102.0996,-1172.3049,-82.0439,-1161.8765,7.0000}, //gasstation flint county
	{650.2310,-578.8812,660.5054,-552.3458,21.0000}, // gasstation dillmore
	{1376.9760,453.9236,1388.0414,464.9828,25.0000}, // gasstation montgommery
	{-1680.6169,395.6857,-1673.3879,432.2233,12.0000}, //gasstaion eastern basin
	{-2416.2515,959.4621,-2406.2815,993.1637,50.0000}, //gasstation juniper hollow
	{2137.7278,2740.6958,2157.2983,2759.1567,15.0000},// gasstation spinybed
	{1584.1063,2189.7913,1605.3728,2208.7546,15.0000}, //gasstation redsands
	{-1336.4580,2664.2312,-1324.6313,2688.8215,55.0000}, //gasstation El Quabrados
	{-1609.4421,-2724.5491,-1603.6292,-2700.8577,53.0000}, // gasstation whetstone
	{-2248.9402,-2567.8853,-2239.4849,-2553.0125,36.0000}, // gasstation angel pine
	{598.2826,1679.1799,631.9799,1706.1033,12.00000}, //gasstation petrol valley
	{2632.6106,1095.1746,2646.9065,1116.5039,15.0000}, //gasstation behind come-a-lot LV
	{2106.5022,908.7917,2124.6526,932.0682,16.0000}, //gasstation at ammunation
	{2192.7961,2467.4385,2212.7527,2484.5962,15.0000}, //gasstation emerald isle LV
	{-1481.8330,1857.2621,-1461.4703,1870.8361,37.0000}, //gasstation Tierra Robada
	{1984.9894,-2471.6887,2035.2931,-2419.0627,18.0000}, //LS airport
	{1312.1711,1468.8359,1362.4749,1518.5763,15.0000}, //LV airport
	{339.1411,2477.5522,400.7101,2529.4880,21.0000}, //Abandoned airport
	{-1301.8037,-19.3120,-1212.9508,32.1128,19.0000}, //SF airport
	{-1711.7979,146.1957,-1431.8701,228.4180,5.0000}, //SF Haven
	{-2221.3572,2343.5989,-2192.4849,2494.2600,5.0000}, //Haven Bayside
	{1580.9795,562.5332,1655.7471,597.3725,5.0000}, //LV Haven 1
	{2256.3298,503.9369,2388.4702,540.7412,5.0000}, //LV Haven 2
	{717.0596,-1733.0457,729.2417,-1599.2904,5.0000} //LS Haven
};

#define MAX_GTASAVEHICLES   212
new vehicleNames[MAX_GTASAVEHICLES][] = {
   "Landstalker",
   "Bravura",
   "Buffalo",
   "Linerunner",
   "Pereniel",
   "Sentinel",
   "Dumper",
   "Firetruck",
   "Trashmaster",
   "Stretch",
   "Manana",
   "Infernus",
   "Voodoo",
   "Pony",
   "Mule",
   "Cheetah",
   "Ambulance",
   "Leviathan",
   "Moonbeam",
   "Esperanto",
   "Taxi",
   "Washington",
   "Bobcat",
   "Mr Whoopee",
   "BF Injection",
   "Hunter",
   "Premier",
   "Enforcer",
   "Securicar",
   "Banshee",
   "Predator",
   "Bus",
   "Rhino",
   "Barracks",
   "Hotknife",
   "Trailer", //artict1
   "Previon",
   "Coach",
   "Cabbie",
   "Stallion",
   "Rumpo",
   "RC Bandit",
   "Romero",
   "Packer",
   "Monster",
   "Admiral",
   "Squalo",
   "Seasparrow",
   "Pizzaboy",
   "Tram",
   "Trailer", //artict2
   "Turismo",
   "Speeder",
   "Reefer",
   "Tropic",
   "Flatbed",
   "Yankee",
   "Caddy",
   "Solair",
   "Berkley's RC Van",
   "Skimmer",
   "PCJ-600",
   "Faggio",
   "Freeway",
   "RC Baron",
   "RC Raider",
   "Glendale",
   "Oceanic",
   "Sanchez",
   "Sparrow",
   "Patriot",
   "Quad",
   "Coastguard",
   "Dinghy",
   "Hermes",
   "Sabre",
   "Rustler",
   "ZR3 50",
   "Walton",
   "Regina",
   "Comet",
   "BMX",
   "Burrito",
   "Camper",
   "Marquis",
   "Baggage",
   "Dozer",
   "Maverick",
   "News Chopper",
   "Rancher",
   "FBI Rancher",
   "Virgo",
   "Greenwood",
   "Jetmax",
   "Hotring",
   "Sandking",
   "Blista Compact",
   "Police Maverick",
   "Boxville",
   "Benson",
   "Mesa",
   "RC Goblin",
   "Hotring Racer", //hotrina
   "Hotring Racer", //hotrinb
   "Bloodring Banger",
   "Rancher",
   "Super GT",
   "Elegant",
   "Journey",
   "Bike",
   "Mountain Bike",
   "Beagle",
   "Cropdust",
   "Stunt",
   "Tanker", //petro
   "RoadTrain",
   "Nebula",
   "Majestic",
   "Buccaneer",
   "Shamal",
   "Hydra",
   "FCR-900",
   "NRG-500",
   "HPV1000",
   "Cement Truck",
   "Tow Truck",
   "Fortune",
   "Cadrona",
   "FBI Truck",
   "Willard",
   "Forklift",
   "Tractor",
   "Combine",
   "Feltzer",
   "Remington",
   "Slamvan",
   "Blade",
   "Freight",
   "Streak",
   "Vortex",
   "Vincent",
   "Bullet",
   "Clover",
   "Sadler",
   "Firetruck", //firela
   "Hustler",
   "Intruder",
   "Primo",
   "Cargobob",
   "Tampa",
   "Sunrise",
   "Merit",
   "Utility",
   "Nevada",
   "Yosemite",
   "Windsor",
   "Monster", //monstera
   "Monster", //monsterb
   "Uranus",
   "Jester",
   "Sultan",
   "Stratum",
   "Elegy",
   "Raindance",
   "RC Tiger",
   "Flash",
   "Tahoma",
   "Savanna",
   "Bandito",
   "Freight", //freiflat
   "Trailer", //streakc
   "Kart",
   "Mower",
   "Duneride",
   "Sweeper",
   "Broadway",
   "Tornado",
   "AT-400",
   "DFT-30",
   "Huntley",
   "Stafford",
   "BF-400",
   "Newsvan",
   "Tug",
   "Trailer", //petrotr
   "Emperor",
   "Wayfarer",
   "Euros",
   "Hotdog",
   "Club",
   "Trailer", //freibox
   "Trailer", //artict3
   "Andromada",
   "Dodo",
   "RC Cam",
   "Launch",
   "Police Car (LSPD)",
   "Police Car (SFPD)",
   "Police Car (LVPD)",
   "Police Ranger",
   "Picador",
   "S.W.A.T. Van",
   "Alpha",
   "Phoenix",
   "Glendale",
   "Sadler",
   "Luggage Trailer", //bagboxa
   "Luggage Trailer", //bagboxb
   "Stair Trailer", //tugstair
   "Boxville",
   "Farm Plow", //farmtr1
   "Utility Trailer" //utiltr1
};

#define MAX_ALLOWED_CHARS 88
new allowedchars[MAX_ALLOWED_CHARS][2] = {
	"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z", //26
	"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z", //26
	"1","2","3","4","5","6","7","8","9","0", // 10
	"!","@","#","$","%","^","&","*","(",")","-",":",";",",",".","?"," ","[","]","{","}","~","_","/","\"","=" //26
};

new playerColors[100] = {
	0xFFFF00DD,0x4169FFDD,0xFF0000DD,0x32CD32DD,0xFF00FFDD,0xD3D3D3DD,0xFFFF82DD,0x87CEFADD,0xB22222DD,0x90EE90DD,0x9370DBDD,
	0xA0A0A0DD,0xB0E134DD,0x228B22DD,0xFF69B4DD,0x006400DD,0xD39EEFDD,0x778899DD,0x40E0D0DD,0xF5F5F5DD,0x9ACD32DD,0x8B4513DD,
	0xDDA0DDDD,0x00FF7FDD,0xFFE4FFDD,0x713111DD,0xC715FFDD,0x20B2AADD,0xDC143CDD,0x6495EDDD,0xf0e68cDD,0x778899DD,0xFF1493DD,
	0xF4A460DD,0xEE82EEDD,0xFFD720DD,0x8b4513DD,0x4949A0DD,0x148b8bDD,0x14ff7fDD,0x556b2fDD,0x0FD9FADD,0x10DC29DD,0x534081DD,
	0x0495CDDD,0xEF6CE8DD,0xBD34DADD,0x247C1BDD,0x0C8E5DDD,0x635B03DD,0xCB7ED3DD,0x65ADEBDD,0x5C1ACCDD,0xF2F853DD,0x11F891DD,
	0x7B39AADD,0x53EB10DD,0x54137DDD,0x275222DD,0xF09F5BDD,0x3D0A4FDD,0x22F767DD,0xD63034DD,0x9A6980DD,0xDFB935DD,0x3793FADD,
	0x90239DDD,0xE9AB2FDD,0xAF2FF3DD,0x057F94DD,0xB98519DD,0x388EEADD,0x028151DD,0xA55043DD,0x0DE018DD,0x93AB1CDD,0x95BAF0DD,
	0x369976DD,0x18F71FDD,0x4B8987DD,0x491B9EDD,0x829DC7DD,0xBCE635DD,0xCEA6DFDD,0x20D4ADDD,0x2D74FDDD,0x3C1C0DDD,0x12D6D4DD,
	0x48C000DD,0x2A51E2DD,0xE3AC12DD,0xFC42A8DD,0x2FC827DD,0x1A30BFDD,0xB740C2DD,0x42ACF5DD,0x2FD9DEDD,0xFAFB71DD,0x05D1CDDD,
	0xC471BDDD
};

new playerInvisColors[100] = {
	0xFFFF0000,0x4169FF00,0xFF000000,0x32CD3200,0xFF00FF00,0xD3D3D300,0xFFFF8200,0x87CEFA00,0xB2222200,0x90EE9000,0x9370DB00,
	0xA0A0A000,0xB0E13400,0x228B2200,0xFF69B400,0x00640000,0xD39EEF00,0x77889900,0x40E0D000,0xF5F5F500,0x9ACD3200,0x8B451300,
	0xDDA0DD00,0x00FF7F00,0xFFE4FF00,0x71311100,0xC715FF00,0x20B2AA00,0xDC143C00,0x6495ED00,0xf0e68c00,0x77889900,0xFF149300,
	0xF4A46000,0xEE82EE00,0xFFD72000,0x8b451300,0x4949A000,0x148b8b00,0x14ff7f00,0x556b2f00,0x0FD9FA00,0x10DC2900,0x53408100,
	0x0495CD00,0xEF6CE800,0xBD34DA00,0x247C1B00,0x0C8E5D00,0x635B0300,0xCB7ED300,0x65ADEB00,0x5C1ACC00,0xF2F85300,0x11F89100,
	0x7B39AA00,0x53EB1000,0x54137D00,0x27522200,0xF09F5B00,0x3D0A4F00,0x22F76700,0xD6303400,0x9A698000,0xDFB93500,0x3793FA00,
	0x90239D00,0xE9AB2F00,0xAF2FF300,0x057F9400,0xB9851900,0x388EEA00,0x02815100,0xA5504300,0x0DE01800,0x93AB1C00,0x95BAF000,
	0x36997600,0x18F71F00,0x4B898700,0x491B9E00,0x829DC700,0xBCE63500,0xCEA6DF00,0x20D4AD00,0x2D74FD00,0x3C1C0D00,0x12D6D400,
	0x48C00000,0x2A51E200,0xE3AC1200,0xFC42A800,0x2FC82700,0x1A30BF00,0xB740C200,0x42ACF500,0x2FD9DE00,0xFAFB7100,0x05D1CD00,
	0xC471BDDD
};

new PlayerColorsChoice[30] = {
	0x9292FFDD,0x0000FFDD,0x000096DD,0x4169FFDD,0xFF9C9CDD,0xFF0000DD,0xA10000DD,0xB22222DD,0x92FF92DD,0x00FF00DD,
	0x009600DD,0x7ACA7ADD,0xFFFF5EDD,0xFFFF00DD,0xD3D300DD,0xCFAE00DD,0xFF92FFDD,0xFF00FFDD,0x800080DD,0xDA70D6DD,
	0xBA9072DD,0x8B4513DD,0x6D360EDD,0xC7C7C7DD,0x8B8B8BDD,0x656565DD,0xFFFFFFDD,0x000000DD,0x7FFFD4DD,0x00FFFFDD
};

new PlayerInvisibleChoice[30] = {
	0x9292FF00,0x0000FF00,0x00009600,0x4169FF00,0xFF9C9C00,0xFF000000,0xA1000000,0xB2222200,0x92FF9200,0x00FF0000,
	0x00960000,0x7ACA7A00,0xFFFF5E00,0xFFFF0000,0xD3D30000,0xCFAE0000,0xFF92FF00,0xFF00FF00,0x80008000,0xDA70D600,
	0xBA907200,0x8B451300,0x6D360E00,0xC7C7C700,0x8B8B8B00,0x65656500,0xFFFFFF00,0x00000000,0x7FFFD400,0x00FFFF00
};

new PlayerColorNames[30][16] = {
	"lightblue","blue","darkblue","specialblue","lightred","red","darkred","specialred","lightgreen","green","darkgreen","specialgreen",
	"lightyellow","yellow","darkyellow","specialyellow","lightpurple","purple","darkpurple","specialpurple","lightbrown","brown","darkbrown",
	"lightgrey","grey","darkgrey","white","black","aquamarine","cyan"
};

new Float:notLoggedSpawn[3] = {2324.4199,-1147.1016,1050.7101}; //villa

new Float:gRandomPlayerSpawns[8][3] = {
	{2004.2555,1521.8010,17.0682}, // spawnpunt schip 1
	{1997.4397,1521.4657,17.0625}, // spawnpunt schip 2
	{1996.6748,1533.9108,14.6172}, // spawnpunt schip 3
	{2003.9340,1533.6292,14.6223}, // spawnpunt schip 4
	{2003.8167,1555.2704,14.4799}, // spawnpunt schip 5
	{1997.7933,1555.3453,14.4828}, // spawnpunt schip 6
	{2000.6272,1566.4745,15.3672}, // spawnpunt 7
	{1998.1041,1544.3392,14.4938} // spawnpunt schip 8
};

new Float:gCopPlayerSpawns[9][3] = {
	{2297.1064,2452.0115,10.8203},
	{2297.0452,2468.6743,10.8203},
	{1553.4371,-1675.5244,16.1953}, // spawnpunt LS politie
	{611.0424,-583.5018,18.2109}, // checkpoint dillmore PD
	{-2149.1824,-2395.7847,30.6250}, // PD angel pine 1
	{-2161.8364,-2385.3284,30.6250}, // PD angel pine 2
	{-1616.5706,683.7604,7.1875}, // Spawnpunt SF PD
	{-1389.8243,2636.7017,55.9844}, // ElQ PD
	{-217.3357,979.5353,19.5020} // bone county PD
};

#define MAX_3DLOCS 3

new Float:casCoords[MAX_3DLOCS][6] = { // {Xmin, Ymin, Zmin, Xmax, Ymax, Zmax}
	{1925.1511,968.2360,992.4687,1982.3024,1067.4122,995.5211}, // four dragons
	{2179.5100,1559.0856,1000.0,2281.1492,1622.9048,1010.0}, //caligula
	{1113.6541,-13.2672,1000.6718,1143.2858,12.4690,1003.0662} 	// redsands casino
};

new Float:casSpawn[MAX_3DLOCS][3] = {
	{2030.2551,1007.9247,10.8203}, // four dragons
	{2186.8896,1680.6750,11.1027}, //caligula
	{1658.9501,2255.8767,10.8203} // redsands casino
};

#define MAX_POINTS 240

new Float:checkCoords[MAX_POINTS][4] = {
	{-36.5483,-57.9948, -17.2655,-49.2967},     //BANK
	{2000.2132,1538.5012, 2000.4132,1538.7012}, //PIRATE
	{284.0546,-86.4384, 302.9315,-56.6674},     //AMMUNATION
	{1925.1511,968.2358, 2019.0715,1067.4276},  //DRAGON - LV
	{-115.9544,-24.2706, -99.1631,-7.1391},     //SEXSHOP - LV
	{487.6558,-88.5900, 512.0635, -67.7503},    //BAR - LV
	{2216.7971,1638.0493, 2255.2097,1714.0806}, //CALIGULA - LV
	{144.9131,-96.0927, 177.4128,-70.7923},    	//ZIP - ROAMING
	{201.4462,-112.4556, 218.5237,-95.1238},    //BINCO - ROAMING
	{-204.7623,-44.0326, -200.2330,-39.8128},   //TATOO - ROAMING
	{416.7485,-84.4242, 422.6890,-74.0611},		//BOTIQUE - ROAMING
	{-2676.0637,1398.3545,-2642.4065,1421.6180},//JIZZY - SF
	{369.0025,-131.6332,378.1711,-116.3600}, 	//PIZZA - SF
	{199.7428,-12.7540,227.5429,-3.5219},       //VICTIM SHOP - ROAMING
	{1201.1422,-16.6343,1223.4420,12.6656},     //STRIPCLUB - LV
	{-1996.0801,253.4684,-1942.0564,310.0717},  //WANG CARS - SF
	{2099.1985,2328.5200,2179.1382,2405.8721},  //EMERALD ISLE - LV
	{1998.3783,1875.9679,2066.3425,1957.0034},  //THE VISAGE - LV
	{199.4294,-46.8185,209.5469,-34.0015},  	//SUBURBAN - ROAMING
	{198.8601,-137.9890,214.9677,-128.5504},  	//PRO LAPS - ROAMING
	{363.5299,-73.9080,381.7558,-57.7846},  	//BURGER SHOT - ROAMING
	{364.8330,-10.3823,380.1563,-6.4998},  		//CLUCKIN' BELL - ROAMING
	{478.4092,-22.1267,498.3633,-7.5962},  		//CLUB - LV
	{198.9507,-166.7670,210.7806,-156.2189},  	//DIDIER SACHS - LS
	{-1986.7450,640.8196,-1918.7468,712.6972}, 	//ZOMBOTECH - LV

	{1292.8934,-797.0057,1306.0920,-779.6151},   //MADD DOGG'S MANSION - LS
	{1662.6529,1414.7014,1681.3187,1481.6320},   //LAS VENTURAS AIRPORT - LV
	{-1772.0982,947.3727,-1736.6804,963.3837},   //SAN FIERRO HOTEL - SF
	{1205.8051,-40.9889,1216.7790,-24.0315},     //BIG SPREAD RANCH - DESERT
	{354.1753,159.5983,390.2836,188.4295},       //CITY PLANNING DEPARTEMENT - LV
	{2610.4199,2330.7182,2654.1169,2352.5646},   //ROCK HOTEL - LV
	{2202.6713,-1078.4467,2216.5400,-1070.6549}, //CLOWNS POCKET HOTEL - LV
	{1293.4305,2066.6452,1321.7255,2099.6289},   //LAS VENTURAS STADIUM - LV
	{-962.1462,1928.5227,-938.0429,1953.9663},   //THE SHERMAN DAM - DESERT
	{-2240.6291,127.7278,-2223.6179,137.4343},   //ZERO RC - SF
	{-1583.9190,92.0117,-1517.5572,156.1555},    //EASTER BASIN - SF
	{-1675.1590,1202.4287,-1642.9515,1223.6416}, //OTTO'S AUTO'S - SF
	{243.6868,-61.2717,256.2911,-52.7754},       //P HAT LIQUOR -

	{1467.8023,-1772.2155,1494.3251,-1736.8258},    // LS Police Station - LS
	{820.5612,-1.0636,834.1079,11.6264},            // Betting Place - BADLANDS
	{900.2247,-1018.3746,1098.2244,-818.3746},           // San Andreas Bank - LS
	{2214.4145,-1155.1606,2228.4287,-1137.4962},    // LS Motel - LS
	{757.1307,-78.6668,776.2868,-58.1050},          // Gym - LV
	{-229.1025,1393.8225,-217.5239,1412.1468},       // UFO Restaurant - DESERT
	{-106.7368,-344.6002,-76.3945,-299.4551},       //BIER - BADLANDS

	{1437.1279,-1322.7638,1587.1279,-1172.7638}, //LS office 1
	{1598.3204,-1432.3176,1748.3204,-1282.3176}, //LS office 2
	{1693.1548,-1445.9072,1843.1548,-1295.9072}, //LS office 3
	{1579.2072,-1732.2014,1729.2072,-1582.2014}, //LS office 4 circle buildings
	{1659.2086,-2130.5313,1809.2086,-1980.5313}, //LS cargo transport station
	{2049.9902,-2350.8024,2199.9902,-2200.8024}, //LS Transport company
	{2668.9121,-2528.6096,2818.9121,-2378.6096}, //LS cargo docks
	{2588.3550,-2301.5488,2738.3550,-2151.5488}, //LS container terminal
	{1053.8467,-1564.4379,1203.8467,-1414.4379}, //LS market place
	{962.0238,-1412.8695,1112.0238,-1262.8695}, //LS Donught shop
	{1212.1600,-1232.2913,1362.1600,-1082.2913}, //LS Le Regalle
	{1047.7440,-1203.6295,1197.7440,-1053.6295}, //LS Sex cinema
	{947.8984,-1197.7528,1097.8984,-1047.7528}, //LS Royal
	{845.7953,-1363.4526,995.7953,-1213.4526}, //LS Movie Studio
	{657.8487,-1432.7705,807.8487,-1282.7705}, //LS Television studio
	{321.8876,-2133.7239,471.8876,-1983.7239}, //LS Yacht Harbour
	{265.0723,-1189.3950,335.0723,-1119.3950}, //LS Tom Cross Residence
	{203.6852,-1237.2969,273.6852,-1167.2969}, //LS El Pacman Residence
	{230.6898,-1322.8160,300.6898,-1252.8160}, //LS George Truly Residence
	{450.0629,-1150.1256,520.0629,-1080.1256}, //LS Mel Tripson Residence
	{860.5236,-828.1354,930.5236,-758.1354}, //LS Arnold Whitenagger Residence
	{957.9416,-731.2490,1027.9416,-661.2490}, //LS Russel Flow Residence
	{1060.7251,-681.6060,1130.7251,-611.6060}, //LS Sylvester Drylone Residence
	{1347.5481,-840.7982,1645.5481,-570.7982}, //LS Frank Ditrina Residence
	{184.9677,-1285.6982,254.9677,-1215.6982}, //LS Bill Fence's Residence
	{220.1756,-1401.3496,290.1756,-1331.3496}, //LS Oprah Lintrey's Residence
	{262.6759,-1372.0261,332.6759,-1302.0261}, //LS Rob the Gardener's residence
	{155.9045,-1343.3722,225.9045,-1273.3722}, //LS Bill Glitton Residence
	{1031.5836,-382.4359,1181.5836,-232.4359}, //Badlands Dillmore farm
	{779.2936,-679.0322,929.2936,-529.0322}, //Badlands Solarin Industries
	{579.9170,-639.7164,729.9170,-489.7164}, //Badlands Dillmore gasstation
	{606.7365,-550.1638,756.7365,-400.1638}, //Badlands The welcome pump
	{2237.8599,8.8167,2387.8599,158.8167}, //Badlands Palomino creek Dick's Sounds
	{2184.0481,-146.4134,2334.0481,4.4134}, //Badlands Palomino Creek Library
	{1330.6533,291.4945,1424.6533,421.4945}, //Badlands Montgomery Bio Engineering
	{1308.7439,386.6168,1458.7439,536.6168}, //Badlands Montgomery Gas Station
	{1250.3204,211.4617,1330.3204,290.4617}, //Badlands Montgomery Sprunk Factory
	{795.1017,-100.5970,945.1017,50.5970}, //Badlands Bart's hideout
	{80.5597,-329.1226,230.5597,-179.1226}, //Badlands Blueberry Truck Terminal
	{-137.7433,-31.2099,13.7433,119.2099}, //Badlands Blueberry Cotton farm
	{-586.3081,-162.9940,-436.3081,-12.9940}, //Badlands Logging camp
	{-451.3734,-1503.6661,-301.3734,-1353.6661}, //Badlands Flint Wheat Ranch
	{-80.6895,-1155.9447,99.6895,-968.9447}, //Badlands RS Haul
	{-666.8018,-595.6549,-516.8018,-445.6549}, //Badlands Fallen Tree Industrial Complex
	{-662.6992,-1125.3607,-512.6992,-975.3607}, //Badlands Center Parks Hunting Cabines
	{-1186.409,-1712.4600,-1036.409,-1562.4600}, //Badlands Grass Farm
	{-1893.410,-1690.4114,-1743.410,-1540.4114}, //Badlands Angel Pine Junkyard
	{-2268.592,-2329.1501,-2118.592,-2179.1501}, //Badlands Angel Pine motel
	{-2110.403,-2423.6101,-1960.403,-2273.6101}, //Badlands Angel Pine Sawmill
	{-1680.364,-2789.2827,-1530.364,-2639.2827}, //Badlands Whetstone Gas Station
	{-91.3514,-2579.3743,59.3514,-2429.3743}, //Badlands Flint county motel
	{-2319.707,-2636.2312,-2169.707,-2486.2312}, //Badlands Angel Pine Gas Station
	{-1129.648,-770.6937,-979.648,-620.6937}, //Badlands Easter Bay Chemicals
	{-1151.698,-1210.4862,-1001.698,-1060.4862}, //Badlands Tobacco Farm
	{-1574.6744,-1620.2271,-1275.6744,-1329.2271}, //Badlands Diary Farm
	{-2597.966,-696.5621,-2447.966,-546.5621}, //SF SA Radio Broadcast Company
	{-2029.845,-930.8918,-1879.845,-780.8918}, //SF Expensive Appartments
	{-2141.204,-934.6577,-1991.204,-784.6577}, //SF Round office building
	{-2065.487,-518.8075,-1915.487,-368.8075}, //SF SA Dirtring Arena Corporation
	{-2795.726,-393.8671,-2645.726,-243.8671}, //SF Avispa Country Clyb
	{-2664.981,-16.8830,-2514.981,134.8830}, //SF Hippy Shopper
	{-2700.556,325.9749,-2600.556,425.9749}, //SF SA Art Museum
	{-2816.114,325.3273,-2716.114,425.3273}, //SF SA Town Hall
	{-2680.723,612.5323,-2630.723,662.5323}, //SF San Andreas County Hospital
	{-2521.336,447.6240,-2371.336,597.6240}, //SF SA Federal Mint
	{-2349.604,459.1251,-2199.604,609.1251}, //SF City Tours
	{2158.3591,-1181.6328,2308.3591,-1031.6328}, //SF Queens Hotel
	{-2536.824,57.6668,-2386.824,207.6668}, //SF The Biffin Bridge Hotel
	{752.1308,-52.7644,784.1308,-20.7644}, //SF Corba Dojo
	{-2232.007,-270.0953,-2082.007,-120.0953}, //SF Drugs Laboratorium
	{-2044.529,62.7472,-1894.529,212.7472}, //SA Public Transportation
	{-1883.287,484.6503,-1733.287,634.6503}, //SF Triangular Office Building
	{-1811.550,110.0344,-1661.550,260.0344}, //SF Container Terminal
	{-1623.620,49.4745,-1473.620,199.4745}, //SF Car in and export
	{-1917.015,-85.0023,-1767.015,65.0023}, //SF Solarin Industries Factory
	{-1750.863,339.6386,-1600.863,489.6386}, //SF Gas Station
	{-2517.753,678.6963,-2367.753,828.6963}, //SF Supermarket
	{-1833.338,827.3233,-1683.338,977.3233}, //SF Big pointy building
	{-2264.361,2338.7371,-2114.361,2488.7371}, //Deser Bayside Yacht Club
	{-2016.310,2304.8674,-1866.310,2454.8674}, //Desert Jay's Diner
	{-763.4591,863.8668,-613.4591,1013.8668}, //Desert CIA Regional Headquater
	{-210.4107,1025.9098,-206.4107,1100.9098}, //Desert Fort Carson Hotel
	{-174.2219,1009.3588,-24.2219,1159.3588}, //Desert HI K69 radiostation
	{28.4225,1033.2750,178.4225,1183.2750}, //Desert Drive inn Cinema
	{-118.2196,1169.7456,-68.2196,1209.7456}, //Desert The Bowled Spot
	{-168.8977,1199.5636,-118.8977,1249.5636}, //Desert King Ring
	{-410.0847,1219.3022,-260.0847,1369.3022}, //Desert Lookout Point
	{-406.3119,1505.0635,-256.3119,1655.0635}, //Desert Big Ear
	{-404.0012,1785.9648,-254.0012,1935.9648}, //Desert Regular Tom
	{-822.2555,1514.0217,-672.2555,1664.0217}, //Desert Las Barrancas Gift Shop
	{-898.0395,1367.8489,-748.0395,1517.8489}, //Desert Tee Pee Motel
	{2325.7642,-1080.3997,2357.7642,-1048.3997}, //Desert Ronnies Crib
	{-1428.351,1982.5881,-1278.351,2132.5881}, //Desert Bait Shop
	{-1480.092,2554.4402,-1388.092,2704.4402}, //Desert El Quebrados Hotel
	{-1402.915,2602.3083,-1252.915,2752.3083}, //Desert El Quebrados Gas Station
	{-1378.631,2416.5068,-1228.631,2566.5068}, //Desert The Lost Pueblo Museum
	{-870.5163,2669.5886,-768.5163,2819.5886}, //Desert Valle Ocultado Tee Pee Motel
	{-625.9322,2519.1855,-475.9322,2669.1855}, //Desert Airport Museum
	{-343.8556,2514.8091,-193.8556,2664.8091}, //Desert Las Payasadas Chicken Restaurant
	{541.0198,1615.4517,691.0198,1765.4517}, //Desert Bone County Gas Station
	{145.8960,1345.3630,295.8960,1495.3630}, //Desert SA Oil Refinnery
	{531.3950,792.4795,681.3950,942.4795}, //Desert Hunter Quarry
	{721.4116,1612.2749,871.4116,1762.2749}, //Desert Shooting Range
	{969.8224,937.6628,1119.8224,1087.6628}, //LV SA College
	{1091.4728,1274.4929,1241.4728,1424.4929}, //LV SA Motorbike Driving School
	{863.6158,1656.2560,1013.6158,1806.2560}, //LV SA Customs Department
	{874.5857,2035.1077,1024.5857,2185.1077}, //LV Meatfactory
	{977.8396,2118.6423,1127.8396,2268.6423}, //LV Cargo Terminal
	{1230.9319,1540.7377,1380.9319,1690.7377}, //LV Aircraft control center
	{1677.7360,2064.2192,1827.7360,2214.2192}, //LV Fire brigade
	{1630.3931,2147.9092,1708.3931,2247.9092}, //LV Rim and shine
	{1547.4747,2149.5364,1615.4747,2249.5364}, //LV Gas Station
	{1114.9473,-18.2603,1146.9473,14.2603}, //LV Starbucks Casino
	{1956.3079,2086.1558,2106.3079,2236.1558}, //LV Behind the strip motel
	{1814.8846,2372.1077,1964.8846,2522.1077}, //LV Souvenir Shops
	{1691.0852,2704.1606,1841.0852,2854.1606}, //Centerparks Gambling Cottages
	{1385.0496,2698.8325,1535.0496,2848.8325}, //LV Yellow Bell Golf Course
	{2804.1292,1527.5717,2954.1292,1677.5717}, //LV Public Transport Maintenance
	{2485.5237,1486.3944,2635.5237,1636.3944}, //LV Aztec Motel
	{2351.2471,1587.8195,2501.2471,1737.8195}, //LV La Conca Motel
	{2226.8220,-1091.6866,2258.8220,-1059.6866}, //LV Mideval Casino Hotel
	{2090.5618,2087.7471,2240.5618,2237.7471}, //LV The Old Cowboy
	{2240.0085,2042.5710,2390.0085,2192.5710}, //LV The kicking heels
	{2046.6597,1412.0354,2196.6597,1562.0354}, //LV Royal Casino
	{2108.9497,1039.7048,2258.9497,1189.7048}, //LV Come-a-lot Casino
	{1612.8822,600.9433,1762.8822,750.9433}, //LV Cargo Harbour Depot
	{1379.3645,675.9985,1529.3645,825.9985}, //LV Dr. Pheely Confession Center
	{1351.4187,978.3818,1501.4187,1128.3818}, //LV Chuckup
	{1561.8679,960.3662,1711.8679,1110.3662}, //LV Final Build Construction
	{1664.2839,1789.8997,1814.2839,1939.8997}, //LV Shoody Used Cars
	{2077.6169,-1240.5886,2230.6169,-1095.5886}, //LS Taxi Company
	{2355.8435,-1134.6979,2379.8435,-1110.6979}, //Hacking the bank
	{210.0856,50.1221,252.0856,92.1221}, //Jailbreak
	{201.4829,1801.2782,221.4829,1823.2782}, // Joss DJ Control Room
	{235.5546,1850.3214,247.5546,1870.3214}, // Admin weapons storeroom
	{274.5485,1850.8495,276.8485,1865.8495}, // Nitro Secret Technologies Lab
	{272.3581,1870.8944,274.3581,1895.8944}, // Barts BeerTender
	{1086.3489,-2111.6693,1206.3489,-1961.6693}, // LS Memorial museum
	{1868.2294,-2191.3372,2012.2294,-2041.3372}, // LS Sex shop
	{1932.4171,-1380.9769,2082.4171,-1230.9769}, // LS The Bahamas Apartments
	{-2243.6550,-2349.8096,-2163.6550,-2269.8096}, // Angel Pine Medical Center
	{-1534.4595,2449.2551,-1494.4595,2539.2551}, // El Quebrados Medical Center
	{-737.7772,2230.6760,-587.7772,2380.6760}, // Old Gold Mine
	{-1000.4276,2612.0701,-880.4276,2750.0701}, // Vortex rental service
	{-2773.7783,90.2126,-2423.7783,290.2126}, //Speedometer verkoop
	{-2817.1416,730.9164,-2717.1416,818.9164}, //SF Deposit bank
	{2102.4875,2374.1521,2302.4875,2574.1521}, // Gasstation emerald isle
	{2538.3870,1006.2782,2738.3870,1206.2782}, // Gasstation behind camel toe
	{2016.0767,820.8616,2216.0767,1020.8616}, // Gasstation besides camel toe
	{2049.8552,2647.5637,2249.8552,2847.5637}, // Gasstation Spinybed
	{-1570.9108,1763.5177,-1370.9108,1963.5177}, // Gasstation Tierra Nobada
	{-2508.4954,874.5211,-2308.4954,1074.5211}, // Gasstation Juniper Hallow
	{1844.0710,-1872.0964,2044.0710,-1672.0964}, // Gasstation idlewood
	{-190.2210,-1268.0436,-82.2210,-1158.0436}, // Gasstation flint county
	{1630.4792,-2107.9432,1930.4792,-1657.9432}, //LS Townhall
	{-205.7904,1102.4246,-172.9716,1197.4524}, //SA Governo
	{2300.3140,2225.5293,2596.3140,2525.5293}, //LV Townhall
	{-299.0380,834.5831,-210.0380,1000.5831},     // Bone County Sherif office
	{-2420.9214,-2330.9839,-2284.9214,-2130.9839}, //Kabelbaan Chilliad
	{-1500.1160,725.8342,-1300.1160,925.8342}, //Kabelbaan Golden Gate
	{-1852.3885,1219.0029,-1562.3885,1519.0029}, //Luigi's
	
	{2586.8354,787.1437,2596.8354,797.1437}, // goud: rockshore east bouwput
	{2679.9998,824.6905,2689.9998,834.6905}, // goud: rockshore east bouwput 2
	{2318.6570,1278.1741,2328.6570,1288.1741}, // goud: top of camel toe
	{2617.8118,1711.6056,2627.8118,1721.6056}, // goud: chinese pilgrim
	{2789.4839,2562.6577,2799.4839,2572.6577}, // goud: loading bay urban creek
	{1347.7356,2794.6582,1357.7356,2804.6582}, // goud: hole in 1
	{1285.4968,2797.5581,1295.4968,2807.5581}, // goud: hole in 2
	{1263.5903,2734.0513,1273.5903,2744.0513}, // goud: hole in 3
	{1123.1879,2756.1948,1133.1879,2766.1948}, // goud: hole in 10
	{878.9520,2727.2131,888.9520,2737.2131}, // goud: tunnel las venturas
	{-233.6513,2705.2202,-223.6513,2715.2202}, // goud: behind the chicken
	{-812.5783,2441.6494,-802.5783,2451.6494}, // goud: on top of arco del oeste
	{-1072.3323,2198.2061,-1062.3323,2208.2061}, // goud: wooden bridge
	{-1443.5721,2163.3057,-1433.5721,2173.3057}, // goud: windmill in tierra robada
	{-2121.3950,2758.0750,-2111.3950,2768.0750}, // goud: tunneled roadway tierra robada
	{-2391.6294,2211.6343,-2381.6294,2221.6343}, // goud: bayside lighthouse
	{-2686.7014,1264.0801,-2676.7014,1274.0801}, // goud: toll booth
	{-1448.3636,930.8820,-1438.3636,940.8820}, // goud: old harbor building
	{-1611.1627,671.0151,-1601.1627,681.0151}, // goud: backdoor fierro police
	{-2757.1001,-236.8684,-2747.1001,-226.8684}, // goud: centercourt
	{-2382.4221,-584.1669,-2372.4221,-574.1669}, // missionary hill
	{2863.7373,-1594.4583,2873.7373,-1584.4583}, // goud: walking over the road towards the beach
	{2662.4246,-1443.1741,2672.4246,-1433.1741}, // goud: sewer channel
	{2351.6201,-658.8680,2361.6201,-648.8680}, // goud: wooden shet on north rock
	{1766.5499,-139.4105,1776.5499,-129.4105}, // goud: forrest overlooking palomino creek
	{969.8209,-190.4751,979.8209,-180.4751}, // goud: hiding under fern ridge
	{718.4434,-1497.9587,728.4434,-1487.9587}, // goud: jetty marina
	{1084.2739,-2249.2378,1094.2739,-2239.2378}, // goud: verdant bluffs park overlooking the ocean
	{401.4305,-1546.0342,411.4305,-1536.0342}, // goud: rodeo drive park
	{-83.2320,-1569.7670,-73.2320,-1559.7670}, // trailer park
	{-439.7388,-2709.0649,-429.7388,-2699.0649}, // goud: on top of flint county overlooking the ocean
	{-1431.3942,-959.0579,-1421.3942,-949.0579}, // goud: dev left sniperrifle
	{210.4332,1905.7321,250.4332,1940.7321}, // admin teleport
	{260.0851,1945.4263,320.0851,2010.4263} // admin rent a car

};

new Float:checkpoints[MAX_POINTS][3] = {
	{-22.2549,-55.6575,1003.5469},
	{2000.3132,1538.6012,13.5859},
	{291.0004,-84.5168,1001.5156},
	{1989.0619,1005.5241,994.4688},
	{-103.5525,-22.4661,1000.7188},
	{501.4927,-75.4323,998.7578},
	{2235.5408,1679.0402,1008.3594},
	{161.1875,-79.9915,1001.8047},
	{207.5640,-97.8188,1005.2578},
	{-203.4864,-41.2045,1002.2734},
	{418.5547,-80.1667,1001.8047},
	{-2649.101,1409.747,906.2734},
	{376.0949,-125.8507,1001.5},
	{218.443,-8.778273,1001.211},
	{1212.3918,-10.9459,1000.9219},
	{-1957.5327,300.2131,35.4688},
	{2127.5940,2370.4255,10.8203},
	{2022.5179,1916.6848,12.3397},
	{203.6803,-40.7557,1001.8047},
	{206.9941,-133.5536,1002.8672},
	{367.5272,-67.4198,1001.5078},
	{371.3292,-8.9039,1001.8516},
	{487.3790,-14.7161,1000.6797},
	{204.3967,-161.7745,1000.5234},
	{-1950.9393,674.2313,46.5625},

	{1297.0086,-791.9676,1084.0078},//maddcp
	{1674.2181,1447.9433,10.7831}, 	//lvapcp
	{-1753.8619,961.8862,24.8828}, 	//sfhotelcp
	{1208.8775,-32.6266,1000.9531}, //bsprcp
	{356.4751,173.5514,1008.3892}, 	//citpdcp
	{2632.5412,2349.4956,10.6718}, 	//rockhotecp
	{2206.4572,-1075.0778,1050.4843},//clowncp
	{1308.2580,2096.1147,10.9436}, 	//stadcp
	{-956.5483,1947.9230,9.0000}, 	//damcp
	{-2231.1411,129.9242,1035.4140},//zerocp
	{-1548.0362,124.2633,3.5546}, 	//basincp
	{-1654.7645,1213.0559,7.2500}, 	//ottocp
	{251.6643,-57.2912,1.5703},		//lqcp

	{1481.1345,-1768.5632,18.7957}, //policelscp
	{828.1565,4.1601,1004.1870}, 	//bettingcp
	{998.2447,-918.3746,41.7379}, 	//coolbankcp
	{2220.6218,-1153.0356,1025.7968}, //motelcp
	{774.0459,-71.8628,1000.6484}, 	//gymcp
	{-226.3355,1406.1617,27.7734}, 	//ufocp
	{-84.2125,-308.0748,1.6169}, 	//biercp
	{1512.1279,-1247.7638,14.1219}, //LS office 1
	{1673.3204,-1357.3176,16.9871}, //LS office 2
	{1768.1548,-1370.9072,15.3232}, //LS office 3
	{1654.2072,-1657.2014,22.5156}, //LS office 4 circle buildings
	{1734.2086,-2055.5313,13.1441}, //LS cargo transport station
	{2124.9902,-2275.8024,20.6719}, //LS Transport company
	{2743.9121,-2453.6096,13.8623}, //LS cargo docks
	{2663.3550,-2226.5488,13.1133}, //LS container terminal
	{1128.8467,-1489.4379,22.3383}, //LS market place
	{1037.0238,-1337.8695,13.2772}, //LS Donught shop
	{1287.1600,-1157.2913,23.3948}, //LS Le Regalle
	{1122.7440,-1128.6295,23.3712}, //LS Sex cinema
	{1022.8984,-1122.7528,23.4391}, //LS Royal
	{920.7953,-1288.4526,13.8806}, 	//LS Movie Studio
	{732.8487,-1357.7705,23.5792}, 	//LS Television studio
	{396.8876,-2058.7239,7.4023}, 	//LS Yacht Harbour
	{300.0723,-1154.3950,81.3544}, //LS Tom Cross Residence
	{238.6852,-1202.2969,76.1403}, //LS El Pacman Residence
	{265.6898,-1287.8160,74.6325}, //LS George Truly Residence
	{485.0629,-1115.1256,82.3594}, //LS Mel Tripson Residence
	{895.5236,-793.1354,101.4302}, //LS Arnold Whitenagger Residence
	{992.9416,-696.2490,120.9814}, //LS Russel Flow Residence
	{1095.7251,-646.6060,113.2224}, //LS Sylvester Drylone Residence
	{1497.1588,-690.2635,94.4345}, //LS Frank Ditrina Residence
	{219.9677,-1250.6982,78.3307}, 	//LS Bill Fence's Residence
	{255.1756,-1366.3496,52.6802}, 	//LS Oprah Lintrey's Residence
	{297.6759,-1337.0261,53.0079}, 	//LS Rob the Gardener's residence
	{190.9045,-1308.3722,69.8429}, 	//LS Bill Glitton Residence
	{1106.5836,-307.4359,73.5627}, 	//Badlands Dillmore farm
	{854.2936,-604.0322,17.9885}, 	//Badlands Solarin Industries
	{654.9170,-564.7164,15.9020}, 	//Badlands Dillmore gasstation
	{681.7365,-475.1638,16.0053}, 	//Badlands The welcome pump
	{2312.8599,83.8167,26.0543}, 	//Badlands Palomino creek Dick's Sounds
	{2259.0481,-71.4134,31.6016}, 	//Badlands Palomino Creek Library
	{1349.6533,346.4945,19.8791}, 	//Badlands Montgomery Bio Engineering
	{1383.7439,461.6168,19.6850}, 	//Badlands Montgomery Gas Station
	{1325.3204,286.4617,19.6174}, 	//Badlands Montgomery Sprunk Factory
	{870.1017,-25.5970,63.9364}, 	//Badlands Bart's hideout
	{155.5597,-254.1226,1.1330}, 	//Badlands Blueberry Truck Terminal
	{-63.9879,41.8253,3.1103}, 		//Badlands Blueberry Cotton Farm
	{-511.3081,-87.9940,61.7336}, 	//Badlands Logging camp
	{-376.3734,-1428.6661,25.2841}, //Badlands Flint Wheat Ranch
	{-66.6895,-1143.9447,0.6488}, 	//Badlands RS Haul
	{-591.8018,-520.6549,25.0840}, 	//Badlands Fallen Tree Industrial Complex
	{-587.6992,-1050.3607,22.9612}, //Badlands Center Parks Hunting Cabines
	{-1111.409,-1637.4600,76.3672}, //Badlands Grass Farm
	{-1818.410,-1615.4114,22.5823}, //Badlands Angel Pine Junkyard
	{-2193.592,-2254.1501,33.3203}, //Badlands Angel Pine motel
	{-2035.403,-2348.6101,40.4512}, //Badlands Angel Pine Sawmill
	{-1605.364,-2714.2827,48.0999}, //Badlands Whetstone Gas Station
	{-16.3514,-2504.3743,36.2236}, 	//Badlands Flint county motel
	{-2244.707,-2561.2312,31.4870}, //Badlands Angel Pine Gas Station
	{-1054.648,-695.6937,31.9221}, 	//Badlands Easter Bay Chemicals
	{-1076.698,-1135.4862,128.7893}, //Badlands Tobacco Farm
	{-1424.6744,-1479.2271,105.0321}, //Badlands Diary Farm
	{-2522.966,-621.5621,132.2790}, //SF SA Radio Broadcast Company
	{-1954.845,-855.8918,35.8909}, 	//SF Expensive Appartments
	{-2066.204,-859.6577,31.7385}, 	//SF Round office building
	{-1990.487,-443.8075,38.7344},  //SF SA Dirtring Arena Corporation
	{-2720.726,-318.8671,7.4124}, 	//SF Avispa Country Clyb
	{-2589.981,59.8830,3.9024}, 	//SF Hippy Shopper
	{-2650.556,375.9749,6.1563}, 	//SF SA Art Museum
	{-2766.114,375.3273,6.3347}, 	//SF SA Town Hall
	{-2655.723,637.5323,14.0230}, 	//SF San Andreas County Hospital
	{-2446.336,522.6240,29.7776}, 	//SF SA Federal Mint
	{-2274.604,534.1251,34.6123}, 	//SF City Tours
	{2233.3591,-1106.6328,1050.8828}, //SF Queens Hotel
	{-2461.824,132.6668,34.7432}, 	//SF The Biffin Bridge Hotel
	{768.1308,-36.7644,1000.6865}, 	//SF Corba Dojo
	{-2157.007,-195.0953,34.8772}, 	//SF Drugs Laboratorium
	{-1969.529,137.7472,27.2539}, 	//SA Public Transportation
	{-1808.287,559.6503,34.7184}, 	//SF Triangular Office Building
	{-1736.550,185.0344,3.1209}, 	//SF Container Terminal
	{-1548.620,124.4745,3.1190}, 	//SF Car in and export
	{-1842.015,-10.0023,14.6787}, 	//SF Solarin Industries Factory
	{-1675.863,414.6386,6.7501}, 	//SF Gas Station
	{-2442.753,753.6963,34.7454}, 	//SF Supermarket
	{-1758.338,902.3233,24.6564}, 	//SF Big pointy building
	{-2189.361,2413.7371,5.1563}, 	//Deser Bayside Yacht Club
	{-1941.310,2379.8674,49.2690}, 	//Desert Jay's Diner
	{-688.4591,938.8668,13.6328}, 	//Desert CIA Regional Headquater
	{-207.4107,1075.9098,19.3055}, 	//Desert Fort Carson Hotel
	{-99.2219,1084.3588,19.3140}, 	//Desert HI K69 radiostation
	{103.4225,1108.2750,13.1667}, 	//Desert Drive inn Cinema
	{-93.2196,1189.7456,19.3076}, 	//Desert The Bowled Spot
	{-143.8977,1224.5636,19.4649}, 	//Desert King Ring
	{-335.0847,1294.3022,53.2311}, 	//Desert Lookout Point
	{-331.3119,1580.0635,75.2616}, 	//Desert Big Ear
	{-329.0012,1860.9648,44.3828}, 	//Desert Regular Tom
	{-747.2555,1589.0217,26.5273}, 	//Desert Las Barrancas Gift Shop
	{-823.0395,1442.8489,13.4470}, 	//Desert Tee Pee Motel
	{2341.7642,-1064.3997,1049.0234}, //Desert Ronnies Crib
	{-1353.351,2057.5881,53.1172}, 	//Desert Bait Shop
	{-1463.092,2629.4402,58.7734}, 	//Desert El Quebrados Hotel
	{-1327.915,2677.3083,49.6331}, 	//Desert El Quebrados Gas Station
	{-1303.631,2491.5068,86.6226}, 	//Desert The Lost Pueblo Museum
	{-843.5163,2744.5886,45.4116}, 	//Desert Valle Ocultado Tee Pee Motel
	{-550.9322,2594.1855,53.5057}, 	//Desert Airport Museum
	{-268.8556,2589.8091,63.1361}, 	//Desert Las Payasadas Chicken Restaurant
	{616.0198,1690.4517,6.5569}, 	//Desert Bone County Gas Station
	{220.8960,1420.3630,10.1562}, 	//Desert SA Oil Refinnery
	{606.3950,867.4795,-40.6339}, 	//Desert Hunter Quarry
	{796.4116,1687.2749,4.8318}, 	//Desert Shooting Range
	{1044.8224,1012.6628,10.5719}, 	//LV SA College
	{1166.4728,1349.4929,10.9219}, 	//LV SA Motorbike Driving School
	{938.6158,1731.2560,8.4171}, 	//LV SA Customs Department
	{949.5857,2110.1077,1011.0234}, //LV Meatfactory
	{1052.8396,2193.6423,10.3655}, 	//LV Cargo Terminal
	{1305.9319,1615.7377,10.3867}, 	//LV Aircraft control center
	{1752.7360,2139.2192,10.3871}, 	//LV Fire brigade
	{1658.3931,2197.9092,10.3859}, 	//LV Rim and shine
	{1597.4747,2199.5364,10.3921}, 	//LV Gas Station
	{1130.9473,-2.2603,1000.6797}, 	//LV Starbucks Casino
	{2031.3079,2161.1558,10.8203}, 	//LV Behind the strip motel
	{1889.8846,2447.1077,10.7428}, 	//LV Souvenir Shops
	{1766.0852,2779.1606,10.4065}, 	//Centerparks Gambling Cottages
	{1460.0496,2773.8325,10.3842}, 	//LV Yellow Bell Golf Course
	{2879.1292,1602.5717,10.3907}, 	//LV Public Transport Maintenance
	{2560.5237,1561.3944,10.8203}, 	//LV Aztec Motel
	{2426.2471,1662.8195,10.3852}, 	//LV La Conca Motel
	{2242.8220,-1075.6866,1049.0310}, //LV Mideval Casino Hotel
	{2165.5618,2162.7471,10.3824}, 	//LV The Old Cowboy
	{2315.0085,2117.5710,10.3980}, 	//LV The kicking heels
	{2121.6597,1487.0354,10.3868}, 	//LV Royal Casino
	{2183.9497,1114.7048,12.2202}, 	//LV Come-a-lot Casino
	{1687.8822,675.9433,10.3870}, 	//LV Cargo Harbour Depot
	{1454.3645,750.9985,10.5942}, 	//LV Dr. Pheely Confession Center
	{1426.4187,1053.3818,10.3840}, 	//LV Chuckup
	{1636.8679,1035.3662,10.3771}, 	//LV Final Build Construction
	{1739.2839,1864.8997,10.8129}, 	//LV Shoody Used Cars
	{2154.6169,-1169.5886,23.8216}, //LS Taxi Company
	{2367.8435,-1122.6979,1050.8750}, //Hacking the bank
	{231.0856,71.1221,1005.0391}, 	//Jailbreak
	{211.4829,1812.2782,21.8594}, // Joss DJ Control Room
	{246.5546,1859.3214,14.0840}, // Admin weapons storeroom
	{275.3485,1855.8495,8.7649}, // Nitro Secret Technologies Lab
	{273.3581,1882.8944,-30.3906}, // Barts BeerTender
	{1131.3489,-2036.6693,68.5791}, // LS Memorial museum
	{1942.2294,-2116.3372,13.2287}, // LS Sex shop
	{2007.4171,-1305.9769,20.4341}, // LS The Bahamas Apartments
	{-2203.6550,-2309.8096,31.3750}, // Angel Pine Medical Center
	{-1514.4595,2519.2551,56.0703}, // El Quebrados Medical Center
	{-662.7772,2305.6760,135.6505}, // Old Gold Mine
	{-911.4276,2687.0701,41.9401}, // Vortex rental service
	{-2653.7783,190.2126,4.3281}, // Speedo verkoop
	{-2767.1416,769.9164,52.7813}, //SF Deposit bank
	{2202.4875,2474.1521,10.3874}, // Gasstation emerald isle
	{2638.3870,1106.2782,10.3975}, // Gasstation behind camel toe
	{2116.0767,920.8616,10.3938}, // Gasstation besides camel toe
	{2149.8552,2747.5637,10.3915}, // Gasstation Spinybed
	{-1470.9108,1863.5177,32.1811}, // Gasstation Tierra Nobada
	{-2408.4954,974.5211,45.2969}, // Gasstation Juniper Hallow
	{1944.0710,-1772.0964,12.9566}, // Gasstation idlewood
	{-90.2210,-1168.0436,2.2816}, // Gasstation flint county
	{1780.4792,-1807.9432,13.0929}, // LS Townhall
	{-204.7904,1119.4246,19.3074}, // SA Governor
	{2446.3140,2375.5293,11.7281}, // LV Townhall
	{-219.0380,974.5831,19.4931},    //Fort Carson Sherriff Office
	{-2384.9214,-2230.9839,33.2891}, //Kabelbaan chilliad
	{-1400.1160,825.8342,47.8557}, //Kabelbaan goldengate
	{-1712.3885,1369.0029,7.1853}, //Luigis

	{2591.8354,792.1437,10.9545}, // goud: rockshore east bouwput
	{2684.9998,829.6905,10.9545}, // goud: rockshore east bouwput 2
	{2323.6570,1283.1741,97.5979}, // goud: top of camel toe
	{2622.8118,1716.6056,10.5736}, // goud: chinese pilgrim
	{2794.4839,2567.6577,9.4985}, // goud: loading bay urban creek
	{1352.7356,2799.6582,9.7291}, // goud: hole in 1
	{1290.4968,2802.5581,9.8011}, // goud: hole in 2
	{1268.5903,2739.0513,9.6904}, // goud: hole in 3
	{1128.1879,2761.1948,9.8186}, // goud: hole in 10
	{883.9520,2732.2131,19.9310}, // goud: tunnel las venturas
	{-228.6513,2710.2202,62.5435}, // goud: behind the chicken
	{-807.5783,2446.6494,156.5701}, // goud: on top of arco del oeste
	{-1067.3323,2203.2061,87.3866}, // goud: wooden bridge
	{-1438.5721,2168.3057,49.0716}, // goud: windmill in tierra robada
	{-2116.3950,2763.0750,175.3513}, // goud: tunneled roadway tierra robada
	{-2386.6294,2216.6343,4.5438}, // goud: bayside lighthouse
	{-2681.7014,1269.0801,55.5086}, // goud: toll booth
	{-1443.3636,935.8820,6.7342}, // goud: old harbor building
	{-1606.1627,676.0151,-5.6952}, // goud: backdoor fierro police
	{-2752.1001,-231.8684,6.6711}, // goud: centercourt
	{-2377.4221,-579.1669,131.6815}, // missionary hill
	{2868.7373,-1589.4583,22.0667}, // goud: walking over the road towards the beach
	{2667.4246,-1438.1741,15.8033}, // goud: sewer channel
	{2356.6201,-653.8680,127.6173}, // goud: wooden shet on north rock
	{1771.5499,-134.4105,70.6542}, // goud: forrest overlooking palomino creek
	{974.8209,-185.4751,14.8473}, // goud: hiding under fern ridge
	{723.4434,-1492.9587,1.5057}, // goud: jetty marina
	{1089.2739,-2244.2378,46.3833}, // goud: verdant bluffs park overlooking the ocean
	{406.4305,-1541.0342,31.7936}, // goud: rodeo drive park
	{-78.2320,-1564.7670,2.1262}, // trailer park
	{-434.7388,-2704.0649,170.4631}, // goud: on top of flint county overlooking the ocean
	{-1426.3942,-954.0579,200.6183}, // goud: dev left sniperrifle
	{230.4332,1925.7321,17.6406}, //admin teleport
	{288.0851,1972.4263,17.6406} //admin rent a car
};

new checkpointType[MAX_POINTS] = {
	CP_BANK,
	CP_PIRATE,
	CP_AMMU,
	CP_DRAGON,
	CP_SEXSHOP,
	CP_BAR,
	CP_CALIGULA,
	CP_ZIP,
	CP_BINCO,
	CP_TATOO,
	CP_BOTIQUE,
	CP_JIZZY,
	CP_PIZZA,
	CP_VICTIM,
	CP_STRIPCLUB,
	CP_WANGCARS,
	CP_EMERALD,
	CP_VISAGE,
	CP_SUBURBAN,
	CP_PROLAPS,
	CP_BURGER,
	CP_CLUCKIN,
	CP_CLUB,
	CP_DS,
	CP_ZOMBO,

	CP_MADD_D,
	CP_LV_AP,
	CP_SF_HOTEL,
	CP_BS_RANCH,
	CP_CITY_PL_D,
	CP_ROCK_HOTEL,
	CP_CLOWN_HOTEL,
	CP_LV_STADIUM,
	CP_S_DAM,
	CP_ZERO_RC,
	CP_E_BASIN,
	CP_OTTO_AUTO,
	CP_PH_LIQUOR,

	CP_LS_POLICE,
	CP_BETTING,
	CP_SA_BANK,
	CP_LS_MOTEL,
	CP_GYM,
	CP_UFO_RES,
	CP_BARTS_BEER,
	
    CP_BANKADMIN,
    CP_ISPOFFICE,
    CP_INSURANCE,
    CP_FOREIGN,
    CP_LSCARGOTRNS,
    CP_LSCARGOCMP,
    CP_LSCARGODCK,
    CP_LSCONTAINER,
    CP_LSMARKET,
    CP_DONUT,
    CP_LEREGALLE,
    CP_SEXCINEMA,
    CP_ROYAL,
    CP_MOVIE,
    CP_TELEVISION,
    CP_YACHT,
    CP_TOMCR,
    CP_ELPACM,
    CP_GEORGET,
    CP_MELTRIP,
    CP_WHITENAG,
    CP_RUSSEL,
    CP_SYLVESTER,
    CP_DITRINA,
    CP_BILLFENCE,
    CP_OPRAH,
    CP_GARDENER,
    CP_GLITTON,

    CP_PIGFARM,
    CP_SOLARADM,
    CP_DILLGAS,
    CP_WELCOME,
    CP_PALDICK,
    CP_PALLIBR,
    CP_BIOENG,
    CP_MONTGAS,
    CP_SPRUNK,
    CP_BARTHIDE,
    CP_BLUETRUCK,
    CP_COTTON,
    CP_LOGGING,
    CP_FLINTRANCH,
    CP_RSHAUL,
    CP_FALLENTREE,
    CP_HUNTING,
    CP_GRASS,
    CP_JUNKYARD,
    CP_ANGELMOT,
    CP_SAWMILL,
    CP_WHETGAS,
    CP_FLINTMOT,
    CP_ANGELGAS,
    CP_EASTCHEM,
    CP_TOBACCO,
    CP_DIARY,

    CP_SABROAD,
    CP_RETIRE,
    CP_FBI,
    CP_SADIRT,
    CP_AVISPA,
    CP_HIPPY,
    CP_ARTMUS,
    CP_SFTOWN,
    CP_SAHOSP,
    CP_SAMINT,
    CP_CITY,
    CP_QUEENS,
    CP_BIFFIN,
    CP_DOJO,
    CP_DRUGS,
    CP_PUBLICTRAN,
    CP_DEA,
    CP_SFCONT,
    CP_CARINEX,
    CP_SOLARFAC,
    CP_SFGAS,
    CP_SUPERMARK,
    CP_CIAOFFICE,

    CP_BAYYACHT,
    CP_JAYDINER,
    CP_CIAHID,
    CP_CARSHOTEL,
    CP_HIK69,
    CP_DRIVEINN,
    CP_BOWLED,
    CP_KINGRING,
    CP_LOOKOUT,
    CP_BIGEAR,
    CP_REGULAR,
    CP_BARRGIFT,
    CP_BARTEE,
    CP_RONNIECRIB,
    CP_BAIT,
    CP_ELQUEHOTEL,
    CP_ELQUEGAS,
    CP_PEUBLOMUS,
    CP_VALTEE,
    CP_AIRMUS,
    CP_LASCHICK,
    CP_BONEGAS,
    CP_OILREF,
    CP_HUNTER,
    CP_SHOOTING,

    CP_COLLEGE,
    CP_SABIKE,
    CP_CUSTOMS,
    CP_MEATFAC,
    CP_LVCARGO,
    CP_AIRCONTR,
    CP_FIREBRIG,
    CP_RIMSHINE,
    CP_LVGAS,
    CP_STARBUCK,
    CP_BEHIND,
    CP_LVSOURV,
    CP_CENTER,
    CP_YELLOWBELL,
    CP_TRANSMAIN,
    CP_AZTECMOT,
    CP_CONCA,
    CP_MIDEVAL,
    CP_OLDCOWBOY,
    CP_KICKHEELS,
    CP_ROYALCAS,
    CP_COMEALOT,
    CP_LVCARGOHAR,
    CP_PHEELY,
    CP_CHUCKUP,
    CP_FINALBUILD,
    CP_SHOODY,
    CP_TAXICOMP,
    CP_BANKHACKING,
    CP_JAILBREAK,
	CP_JOSDJCON,
	CP_ADMWEAP,
	CP_SECRWEAP,
	CP_BEERTENDER,
	CP_WARMEMORIAL,
	CP_LSSEXXSHOP,
	CP_BAHAMAS,
	CP_ANGELMED,
	CP_ELQMED,
	CP_GOLDMINE,
	CP_VORTEX,
	CP_SPEEDO,
	CP_SFBANK,
	CP_GASEMER,
	CP_GASBEHCAM,
	CP_GASBESCAM,
	CP_GASSPINY,
	CP_GASTIERRA,
	CP_GASJUNIP,
	CP_GASIDLE,
	CP_GASFLINT,
	CP_LSTOWN,
	CP_SAGOVERN,
	CP_LVTOWN,
	CP_FORTCARSONPD,
	CP_LIFTMECHIL,
	CP_LIFTMEGATE,
	CP_LUIGIS,
	
    CP_GOLD00,
    CP_GOLD01,
    CP_GOLD02,
    CP_GOLD03,
    CP_GOLD04,
    CP_GOLD05,
    CP_GOLD06,
    CP_GOLD07,
    CP_GOLD08,
    CP_GOLD09,
    CP_GOLD10,
    CP_GOLD11,
    CP_GOLD12,
    CP_GOLD13,
    CP_GOLD14,
    CP_GOLD15,
    CP_GOLD16,
    CP_GOLD17,
    CP_GOLD18,
    CP_GOLD19,
    CP_GOLD20,
    CP_GOLD21,
    CP_GOLD22,
    CP_GOLD23,
    CP_GOLD24,
    CP_GOLD25,
    CP_GOLD26,
    CP_GOLD27,
    CP_GOLD28,
    CP_GOLD29,
    CP_GOLD30,
    CP_GOLD31,
	CP_ADMINTELEPORT,
	CP_ADMINRENTCAR

};

#define MAX_PROPERTIES 238

new ownedtime[MAX_PROPERTIES];

new propertyArray[MAX_PLAYERS][MAX_OWNED_PROPERTIES];

new propertyNames[MAX_PROPERTIES][58] = {
	"None",
	"Four Dragons Casino",
	"Sex Shop",
	"Bar",
	"Caligula Casino",
	"Zip Shop",
	"Binco Shop",
	"Tatoo Parlor",
	"Botique",
	"Jizzy's Club",
	"Well Stacked Pizza",
	"Victim Shop",
	"Strip Club",
	"Wang Cars",
	"Emerald Isle",
	"Visage",
	"Sub Urban",
	"Pro Laps",
	"Burger Shot",
	"Cluckin' Bell",
	"Club",
	"Didier Sachs",
	"Zombotech Corp.",

	"Madd Dogg's Mansion",
	"Las Venturas Airport",
	"San Fierro Hotel",
	"Pole Dancing Experience",
	"City Planning Department",
	"Rock Hotel",
	"Clowns Pocket Hotel",
	"Las Venturas Stadium",
	"Sherman Dam",
	"Zero RC",
	"Easter Basin",
	"Otto's Auto's",
	"P Hat Liquor",

	"Los Santos Police Station",
	"Betting Place",
	"San Andreas Bank",
	"Los Santos Motel",
	"Caxoperro Bodybuilding",
	"UFO Restaurant",
	"San Andreas Beer Brewery",

	"Administrative Bank Office",
	"Internet Service Provider",
	"Insurance Office",
	"Foreign Affairs Office",
	"LS Cargo Transportation Station",
	"Adv_Rifle's Transport Company",
	"LS Cargo Docks",
	"LS Container Terminal",
	"Market place",
	"Thijs Donut Shop",
	"Le Regalle Theatre",
	"Sex Cinema",
	"Royal Theatre",
	"Movie Studio",
	"Television Studio",
	"Sandra's Pleasure Dome",
	"Tom Cross Residence",
	"El Pacman Residence",
	"George Truly Residence",
	"Mel Tripson Residence",
	"Arnold Whitenagger Residence",
	"Russel Flow Residence",
	"Sylvester Drylone Residence",
	"Frank Ditrina Residence",
	"Bill Fence Residence",
	"Oprah Lintrey Residence",
	"Rob the Gardener Residence",
	"Bill Glitton Residence",

	"Pig Farm",
	"Solarin Industries HQ",
	"Dillmore Gas Station",
	"Welcome Pump",
	"Palomino Creek Dick's Sounds",
	"Palomino Creek Library",
	"Bio Enginering",
	"Montgomery Gas Station",
	"Sprunk Factory",
	"Admins Hideout",
	"Blueberry Truck Terminal",
	"Cottin Farm",
	"Logging Camp",
	"Flint Wheat Ranch",
	"RS Haul",
	"Fallen Tree Industrial Complex",
	"Center Parks Hunting Cabines",
	"Spacy Grass Farm",
	"San Andreas Junkyard",
	"Angel Pine Motel",
	"Sawmill",
	"Whetstone Gas Sation",
	"Flint County Motel",
	"Angel Pine Gas Station",
	"Nitro Chemicals",
	"Tobacco Farm",
	"Diary Farm",

	"SA Radio Broadcast Company",
	"Retirement Home",
	"SA FBI Office",
	"SA Dirtring Arena Corporation",
	"Avispa Country Club",
	"Hippy Shopper",
	"SA Art Museum",
	"San Fierro Town Hall",
	"SA County Hospital",
	"Federal Mint",
	"SF City Tours",
	"Queens Hotel",
	"Biffin Bridge Hotel",
	"Corba Dojo",
	"Drugs Laboratory",
	"Public Transportation",
	"SA DEA Office",
	"SF Container Terminal",
	"Vehicle In and Export",
	"Solarin Industries Factory",
	"San Fierro Gas Station",
	"Insanity Food Services",
	"SA CIA Office",

	"Bayside Yacht Club",
	"Jay's Diner",
	"CIA Safe House",
	"Fort Carson Hotel",
	"HI K69 Radiostation",
	"Drive Inn Cinema",
	"Bowled Spot",
	"King Ring",
	"Lookout Point",
	"Astronomy Center",
	"Regular Tom",
	"Las Barrancas Gift Shop",
	"Las Barrancas Tee Pee Motel",
	"Nitro's Crib",
	"Bait Shop",
	"El Quebrados Hotel",
	"El Quebrados Gas Station",
	"Lost Pueblo Museum",
	"Valle Ocultado Tee Pee Motel",
	"Air Transportation Museum",
	"Las Payasadas Chicken Place",
	"Bone County Gas Station",
	"SA Oil Refinnery",
	"Hunter Quarry",
	"Shooting Range",

	"Anthony v Leeuwenhoek College",
	"SA Motorbike Driving School",
	"SA Customs Department",
	"Meatfactory",
	"LV Cargo Terminal",
	"Aircraft Control Center",
	"Jos's Waterhoses",
	"Rim and Shine",
	"LV Gas Station",
	"Starbucks Casino",
	"Behind The Strip Motel",
	"LV Souvenir Shop",
	"Center Parks Gambling Cribs",
	"Yellow Bell Golf Club",
	"Public Transport Maintenance",
	"Aztec Motel",
	"La Conca Motel",
	"Mideval Casino Hotel",
	"Old Cowboy",
	"Kicking Heels",
	"Royal Casino",
	"Come-a-lot Casino",
	"Cargo Harbour Depot",
	"Dr. Pheeley Confession Center",
	"Chuckup Office",
	"Final Build Construction",
	"San Andreas Used Cars",
	"San Andreas Taxi Company",
	"Hacking the SA Bank",
	"Breaking the jail",
	"Jos' DJ Control Room",
	"Admin weapons storeroom",
	"Nitro's Explosives Lab",
	"Admins BeerTender",
	"War Memorial museum",
	"LS Sex shop",
	"The Bahamas Apartments",
	"Angel Pine Medical Center",
	"El Quebrados Medical Center",
	"Old Gold Mine",
	"Killerfist Vortex rentals",
	"Black Market Carparts",
	"none",
	"Gasstation Emerald Isle",
	"Gasstation Behind Camel Toe",
	"Gasstation Besides Camel Toe",
	"Gasstation Spinybed",
	"Gasstation Tierra Nobada",
	"Gasstation Juniper Hallow",
	"Gasstation Idlewood",
	"Gasstation Flint County",
	
	"Los Santos Town Hall",
	"SA Governor Office",
	"Las Venturas Town Hall",
	"Highway Patrol Headquaters",
	"None",
	"None",
	"Luigi's pizza courier",

	"Buildingsite at rockshore east",
	"Buildingsite at rockshore east",
	"The kick of a camel's toe",
	"Chinese pilgrim houses",
	"Delivery for urban creek",
	"Where did i left my golf ball",
	"Where did i left my golf ball",
	"Where did i left my golf ball",
	"Where did i left my golf ball",
	"Train tunneling through desert",
	"Watch out for the chickens back",
	"Enjoying the view at Arco del Oeste",
	"Have you seen that wooden bridge",
	"A windmill in the desert",
	"No wonder they went through this mountain",
	"A lighthouse in Bayside",
	"$5 toll please Sir",
	"Old harbour architectural site",
	"Do not run into a Fierro cop here",
	"First serve... OUT! Game, set and match",
	"Nice view at Missionary Hill",
	"In bathing suits watching cars passing underneath",
	"Smelly in the sewer channel",
	"Old wooden shed on North Rock",
	"From this forrest you can see Palomino Creek",
	"A good hiding spot under Fern Ridge",
	"Watching the boats at the Jetty Marina",
	"Verdant bluffs park overlooking the ocean",
	"Celeberty watching at Rodeo Drive park",
	"This trailer park is too close to Bill Fence Residence",
	"Enjoying the ocean view at flint county mountain",
	"Has anyone seen my sniper rifle",
	"none",
	"Admin rent-a-car"

};

new propertyShortNames[MAX_PROPERTIES] = {
	P_NONE,
	P_DRAGON,
	P_SEXSHOP,
	P_BAR,
	P_CALIGULA,
	P_ZIP,
	P_BINCO,
	P_TATOO,
	P_BOTIQUE,
	P_JIZZY,
	P_PIZZA,
	P_VICTIM,
	P_STRIPCLUB,
	P_WANGCARS,
	P_EMERALD,
	P_VISAGE,
	P_SUBURBAN,
	P_PROLAPS,
	P_BURGER,
	P_CLUCKIN,
	P_CLUB,
	P_DS,
	P_ZOMBO,

	P_MADD_D,
	P_LV_AP,
	P_SF_HOTEL,
	P_BS_RANCH,
	P_CITY_PL_D,
	P_ROCK_HOTEL,
	P_CLOWN_HOTEL,
	P_LV_STADIUM,
	P_S_DAM,
	P_ZERO_RC,
	P_E_BASIN,
	P_OTTO_AUTO,
	P_PH_LIQUOR,

	P_LS_POLICE,
	P_BETTING,
	P_SA_BANK,
	P_LS_MOTEL,
	P_GYM,
	P_UFO_RES,
	P_BARTS_BEER,

	P_BANKADMIN,
	P_ISPOFFICE,
	P_INSURANCE,
	P_FOREIGN,
	P_LSCARGOTRNS,
	P_LSCARGOCMP,
	P_LSCARGODCK,
	P_LSCONTAINER,
	P_LSMARKET,
	P_DONUT,
	P_LEREGALLE,
	P_SEXCINEMA,
	P_ROYAL,
	P_MOVIE,
	P_TELEVISION,
	P_YACHT,
	P_TOMCR,
	P_ELPACM,
	P_GEORGET,
	P_MELTRIP,
	P_WHITENAG,
	P_RUSSEL,
	P_SYLVESTER,
	P_DITRINA,
	P_BILLFENCE,
	P_OPRAH,
	P_GARDENER,
	P_GLITTON,

	P_PIGFARM,
	P_SOLARADM,
	P_DILLGAS,
	P_WELCOME,
	P_PALDICK,
	P_PALLIBR,
	P_BIOENG,
	P_MONTGAS,
	P_SPRUNK,
	P_BARTHIDE,
	P_BLUETRUCK,
	P_COTTON,
	P_LOGGING,
	P_FLINTRANCH,
	P_RSHAUL,
	P_FALLENTREE,
	P_HUNTING,
	P_GRASS,
	P_JUNKYARD,
	P_ANGELMOT,
	P_SAWMILL,
	P_WHETGAS,
	P_FLINTMOT,
	P_ANGELGAS,
	P_EASTCHEM,
	P_TOBACCO,
	P_DIARY,

	P_SABROAD,
	P_RETIRE,
	P_FBI,
	P_SADIRT,
	P_AVISPA,
	P_HIPPY,
	P_ARTMUS,
	P_SFTOWN,
	P_SAHOSP,
	P_SAMINT,
	P_CITY,
	P_QUEENS,
	P_BIFFIN,
	P_DOJO,
	P_DRUGS,
	P_PUBLICTRAN,
	P_DEA,
	P_SFCONT,
	P_CARINEX,
	P_SOLARFAC,
	P_SFGAS,
	P_SUPERMARK,
	P_CIAOFFICE,

	P_BAYYACHT,
	P_JAYDINER,
	P_CIAHID,
	P_CARSHOTEL,
	P_HIK69,
	P_DRIVEINN,
	P_BOWLED,
	P_KINGRING,
	P_LOOKOUT,
	P_BIGEAR,
	P_REGULAR,
	P_BARRGIFT,
	P_BARTEE,
	P_RONNIECRIB,
	P_BAIT,
	P_ELQUEHOTEL,
	P_ELQUEGAS,
	P_PEUBLOMUS,
	P_VALTEE,
	P_AIRMUS,
	P_LASCHICK,
	P_BONEGAS,
	P_OILREF,
	P_HUNTER,
	P_SHOOTING,

	P_COLLEGE,
	P_SABIKE,
	P_CUSTOMS,
	P_MEATFAC,
	P_LVCARGO,
	P_AIRCONTR,
	P_FIREBRIG,
	P_RIMSHINE,
	P_LVGAS,
	P_STARBUCK,
	P_BEHIND,
	P_LVSOURV,
	P_CENTER,
	P_YELLOWBELL,
	P_TRANSMAIN,
	P_AZTECMOT,
	P_CONCA,
	P_MIDEVAL,
	P_OLDCOWBOY,
	P_KICKHEELS,
	P_ROYALCAS,
	P_COMEALOT,
	P_LVCARGOHAR,
	P_PHEELY,
	P_CHUCKUP,
	P_FINALBUILD,
	P_SHOODY,
	P_TAXICOMP,
	P_BANKHACKING,
	P_JAILBREAK,
	P_JOSDJCON,
	P_ADMWEAP,
	P_SECRWEAP,
	P_BEERTENDER,
	P_WARMEMORIAL,
	P_LSSEXXSHOP,
	P_BAHAMAS,
	P_ANGELMED,
	P_ELQMED,
	P_GOLDMINE,
	P_VORTEX,
	P_SPEEDO,
	P_SFBANK,
	P_GASEMER,
	P_GASBEHCAM,
	P_GASBESCAM,
	P_GASSPINY,
	P_GASTIERRA,
	P_GASJUNIP,
	P_GASIDLE,
	P_GASFLINT,
	P_LSTOWN,
	P_SAGOVERN,
	P_LVTOWN,
	P_FORTCARSONPD,
	P_LIFTMECHIL,
	P_LIFTMEGATE,
	P_LUIGIS,
	
    P_GOLD00,
	P_GOLD01,
    P_GOLD02,
    P_GOLD03,
    P_GOLD04,
    P_GOLD05,
    P_GOLD06,
    P_GOLD07,
    P_GOLD08,
    P_GOLD09,
    P_GOLD10,
    P_GOLD11,
    P_GOLD12,
    P_GOLD13,
    P_GOLD14,
    P_GOLD15,
    P_GOLD16,
    P_GOLD17,
    P_GOLD18,
    P_GOLD19,
    P_GOLD20,
    P_GOLD21,
    P_GOLD22,
    P_GOLD23,
    P_GOLD24,
    P_GOLD25,
    P_GOLD26,
    P_GOLD27,
    P_GOLD28,
    P_GOLD29,
    P_GOLD30,
    P_GOLD31,
    
	P_ADMINTELEPORT,
	P_ADMINRENTCAR
};

new propertyValues[MAX_PROPERTIES] = {
	0,
	85400,
	28467,
	22773,
	113867,
	17080,
	17080,
	11387,
	22773,
	85400,
	17080,
	17080,
	34160,
	22773,
	68320,
	113867,
	17080,
	17080,
	22773,
	11387,
	56933,
	142333,
	45547,
	156567, //maddcp
	128100,  //lvapcp
	48393,  //sfhotelcp
	370067,  //SMX Pole dancing experience - was 65000
	62627,  //citpdcp
	71167,  //rockhotecp2
	45547,  //clownccp
	76860,  //stadcp
	42700,  //damcp
	22773, //zerocp
	34160,  //basincp
	85400,  //ottocp
	17080, //lqcp
	99633,  //policelscp
	22773,  //bettingcp
	85400,  //coolbankcp
	71167,  //motelcp
	42700,  //gymcp
	34160,  //ufocp
	170800,  //barts beer
	996333,  //LS office 1
	42700,  //LS office 2
	42700,  //LS office 3
	156567,  //LS office 4 circle buildings
	17080,  //LS cargo transport station
	17080,  //LS Transport company
	17080,  //LS cargo docks
	17080,  //LS container terminal
	17080,  //LS market place
	99633,  //LS Donught shop
	71167,  //LS Le Regalle
	99633,  //LS Sex cinema
	71167,  //LS Royal
	128100,  //LS Movie Studio
	113867,  //LS Television studio
	156567,  //LS Yacht Harbour
	56933,  //LS Tom Cross Residence
	56933,  //LS El Pacman Residence
	56933,  //LS George Truly Residence
	56933,  //LS Mel Tripson Residence
	56933,  //LS Arnold Whitenagger Residence
	56933,  //LS Russel Flow Residence
	56933,  //LS Sylvester Drylone Residence
	56933,  //LS Frank Ditrina Residence
	56933,  //LS Bill Fence's Residence
	56933,  //LS Oprah Lintrey's Residence
	56933,  //LS Rob the Gardener's residence
	56933,  //LS Bill Glitton Residence
	14233,  //Badlands Dillmore farm
	85400,  //Badlands Solarin Industries
	142333,  //Badlands Dillmore gasstation
	14233,  //Badlands The welcome pump
	28467,  //Badlands Palomino creek Dick's Sounds
	85400,  //Badlands Palomino Creek Library
	99633,  //Badlands Montgomery Bio Engineering
	142333,  //Badlands Montgomery Gas Station
	113867,  //Badlands Montgomery Sprunk Factory
	142333,  //Badlands Bart's hideout
	68320,  //Badlands Blueberry Truck Terminal
	14233,  //Badlands Blueberry Cotton Farm
	14233,  //Badlands Logging camp
	14233,  //Badlands Flint Wheat Ranch
	34160,  //Badlands RS Haul
	99633,  //Badlands Fallen Tree Industrial Complex
	142333,  //Badlands Center Parks Hunting Cabines
	427000,  //Badlands Tsunami Spacy Grass Farm
	156567,  //Badlands Angel Pine Junkyard
	34160,  //Badlands Angel Pine motel
	56933,  //Badlands Angel Pine Sawmill
	142333,  //Badlands Whetstone Gas Station
	34160,  //Badlands Flint county motel
	142333,  //Badlands Angel Pine Gas Station
	159413,  //Badlands Easter Bay Chemicals
	42700,  //Badlands Tobacco Farm
	14233,  //Badlands Diary Farm
	142333,  //SF SA Radio Broadcast Company
	56933,  //SF Expensive Appartments
	170800,  //SF Round office building
	122407,  //SF SA Dirtring Arena Corporation
	71167,  //SF Avispa Country Clyb
	14233,  //SF Hippy Shopper
	56933,  //SF SA Art Museum
	1138667,  //SF SA Town Hall
	56933,  //SF San Andreas County Hospital
	213500,  //SF SA Federal Mint
	56933,  //SF City Tours
	34160,  //SF Queens Hotel
	56933,  //SF The Biffin Bridge Hotel
	14233,  //SF Corba Dojo
	153720,  //SF Drugs Laboratorium
	113867,  //SA Public Transportation
	170800,  //SF Triangular Office Building
	17080,  //SF Container Terminal
	17080,  //SF Car in and export
	71167,  //SF Solarin Industries Factory
	142333,  //SF Gas Station
	79707,  //SF Supermarket
	227733,  //SF Big pointy building
	76860,  //Deser Bayside Yacht Club
	14233,  //Desert Jay's Diner
	213500,  //Desert CIA Regional Headquater
	34160,  //Desert Fort Carson Hotel
	91093,  //Desert HI K69 radiostation
	71167,  //Desert Drive inn Cinema
	34160,  //Desert The Bowled Spot
	56933,  //Desert King Ring
	99633,  //Desert Lookout Point
	142333,  //Desert Big Ear
	14233,  //Desert Regular Tom
	14233,  //Desert Las Barrancas Gift Shop
	34160,  //Desert Tee Pee Motel
	227733,  //Desert Ronnies Crib
	14233,  //Desert Bait Shop
	34160,  //Desert El Quebrados Hotel
	142333,  //Desert El Quebrados Gas Station
	56933,  //Desert The Lost Pueblo Museum
	34160,  //Desert Valle Ocultado Tee Pee Motel
	56933,  //Desert Airport Museum
	14233,  //Desert Las Payasadas Chicken Restaurant
	142333,  //Desert Bone County Gas Station
	156567,  //Desert SA Oil Refinnery
	113867,  //Desert Hunter Quarry
	854000,  //Desert Shooting Range
	185033,  //LV SA College
	170800,  //LV SA Motorbike Driving School
	159413,  //LV SA Customs Department
	56933,  //LV Meatfactory
	17080,  //LV Cargo Terminal
	128100,  //LV Aircraft control center
	170800,  //LV Fire brigade
	14233,  //LV Rim and shine
	142333,  //LV Gas Station
	156567,  //LV Starbucks Casino
	39853,  //LV Behind the strip motel
	14233,  //LV Souvenir Shops
	142333,  //Centerparks Gambling Cottages
	156567,  //LV Yellow Bell Golf Course
	56933,  //LV Public Transport Maintenance
	34160,  //LV Aztec Motel
	34160,  //LV La Conca Motel
	34160,  //LV Mideval Casino Hotel
	113867,  //LV The Old Cowboy
	113867,  //LV The kicking heels
	113867,  //LV Royal Casino
	113867,  //LV Come-a-lot Casino
	17080,  //LV Cargo Harbour Depot
	113867,  //LV Dr. Pheely Confession Center
	14233,  //LV Chuckup
	71167,  //LV Final Build Construction
	185033,  //LV Shoody Used Cars
	142333,  //LS Taxi Company
	0,   //Hacking the bank
	0,   //Jailbreak
	213500,  //Jos's DJ Control room
	455467,  //Admin weapon storeroom
	427000,  //Nitro explosives lab
	199267,  //BeerTender
	227733,  // LS Memorial museum
	71167,  // LS Sex shop
	170800,  // LS The Bahamas Apartments
	2846667,  // Angel Pine Medical Center
	2846667,  // El Quebrados Medical Center
	79707,  // Old Gold Mine
	170800,  // Vortex rental service
	0,   // Speedo
	0,    // SF Bank
	142333,  // Gasstation emerald isle
	142333,  // Gasstation behind camel toe
	142333,  // Gasstation besides camel toe
	142333,  // Gasstation Spinybed
	142333,  // Gasstation Tierra Nobada
	142333,  // Gasstation Juniper Hallow
	142333,  // Gasstation idlewood
	142333,  // Gasstation flint county
	1138667,  //LS Town hall
	1708000,  //SA Governor office
	1138667,  //LV Town hall
	1992667,  //Highway patrol HQ
	0,
	0,
	0,
	
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	170800 //admin rent a car
};

new propertyCurrentValue[MAX_PROPERTIES];

new propertyOldValues[MAX_PROPERTIES] = {
	0,
	105000,
	35000,
	28000,
	140000,
	21000,
	21000,
	14000,
	28000,
	105000,
	21000,
	21000,
	42000,
	28000,
	84000,
	140000,
	21000,
	21000,
	28000,
	14000,
	70000,
	175000,
	56000,
	192500,//maddcp
	157500, //lvapcp
	59500, //sfhotelcp
	455000, //SMX Pole dancing experience - was 65000
	77000, //citpdcp
	87500, //rockhotecp2
	56000, //clownccp
	94500, //stadcp
	52500, //damcp
	28000,//zerocp
	42000, //basincp
	105000, //ottocp
	21000,//lqcp
	122500, //policelscp
	28000, //bettingcp
	105000, //coolbankcp
	87500, //motelcp
	52500, //gymcp
	42000, //ufocp
	210000, //barts beer
	1225000, //LS office 1
	52500, //LS office 2
	52500, //LS office 3
	192500, //LS office 4 circle buildings
	21000, //LS cargo transport station
	21000, //LS Transport company
	21000, //LS cargo docks
	21000, //LS container terminal
	21000, //LS market place
	122500, //LS Donught shop
	87500, //LS Le Regalle
	122500, //LS Sex cinema
	87500, //LS Royal
	157500, //LS Movie Studio
	140000, //LS Television studio
	192500, //LS Yacht Harbour
	70000, //LS Tom Cross Residence
	70000, //LS El Pacman Residence
	70000, //LS George Truly Residence
	70000, //LS Mel Tripson Residence
	70000, //LS Arnold Whitenagger Residence
	70000, //LS Russel Flow Residence
	70000, //LS Sylvester Drylone Residence
	70000, //LS Frank Ditrina Residence
	70000, //LS Bill Fence's Residence
	70000, //LS Oprah Lintrey's Residence
	70000, //LS Rob the Gardener's residence
	70000, //LS Bill Glitton Residence
	17500, //Badlands Dillmore farm
	105000, //Badlands Solarin Industries
	175000, //Badlands Dillmore gasstation
	17500, //Badlands The welcome pump
	35000, //Badlands Palomino creek Dick's Sounds
	105000, //Badlands Palomino Creek Library
	122500, //Badlands Montgomery Bio Engineering
	175000, //Badlands Montgomery Gas Station
	140000, //Badlands Montgomery Sprunk Factory
	175000, //Badlands Bart's hideout
	84000, //Badlands Blueberry Truck Terminal
	17500, //Badlands Blueberry Cotton Farm
	17500, //Badlands Logging camp
	17500, //Badlands Flint Wheat Ranch
	42000, //Badlands RS Haul
	122500, //Badlands Fallen Tree Industrial Complex
	175000, //Badlands Center Parks Hunting Cabines
	525000, //Badlands Tsunami Spacy Grass Farm
	192500, //Badlands Angel Pine Junkyard
	42000, //Badlands Angel Pine motel
	70000, //Badlands Angel Pine Sawmill
	175000, //Badlands Whetstone Gas Station
	42000, //Badlands Flint county motel
	175000, //Badlands Angel Pine Gas Station
	196000, //Badlands Easter Bay Chemicals
	52500, //Badlands Tobacco Farm
	17500, //Badlands Diary Farm
	175000, //SF SA Radio Broadcast Company
	70000, //SF Expensive Appartments
	210000, //SF Round office building
	150500, //SF SA Dirtring Arena Corporation
	87500, //SF Avispa Country Clyb
	17500, //SF Hippy Shopper
	70000, //SF SA Art Museum
	1400000, //SF SA Town Hall
	70000, //SF San Andreas County Hospital
	262500, //SF SA Federal Mint
	70000, //SF City Tours
	42000, //SF Queens Hotel
	70000, //SF The Biffin Bridge Hotel
	17500, //SF Corba Dojo
	189000, //SF Drugs Laboratorium
	140000, //SA Public Transportation
	210000, //SF Triangular Office Building
	21000, //SF Container Terminal
	21000, //SF Car in and export
	87500, //SF Solarin Industries Factory
	175000, //SF Gas Station
	98000, //SF Supermarket
	280000, //SF Big pointy building
	94500, //Deser Bayside Yacht Club
	17500, //Desert Jay's Diner
	262500, //Desert CIA Regional Headquater
	42000, //Desert Fort Carson Hotel
	112000, //Desert HI K69 radiostation
	87500, //Desert Drive inn Cinema
	42000, //Desert The Bowled Spot
	70000, //Desert King Ring
	122500, //Desert Lookout Point
	175000, //Desert Big Ear
	17500, //Desert Regular Tom
	17500, //Desert Las Barrancas Gift Shop
	42000, //Desert Tee Pee Motel
	280000, //Desert Ronnies Crib
	17500, //Desert Bait Shop
	42000, //Desert El Quebrados Hotel
	175000, //Desert El Quebrados Gas Station
	70000, //Desert The Lost Pueblo Museum
	42000, //Desert Valle Ocultado Tee Pee Motel
	70000, //Desert Airport Museum
	17500, //Desert Las Payasadas Chicken Restaurant
	175000, //Desert Bone County Gas Station
	192500, //Desert SA Oil Refinnery
	140000, //Desert Hunter Quarry
	1050000, //Desert Shooting Range
	227500, //LV SA College
	210000, //LV SA Motorbike Driving School
	196000, //LV SA Customs Department
	70000, //LV Meatfactory
	21000, //LV Cargo Terminal
	157500, //LV Aircraft control center
	210000, //LV Fire brigade
	17500, //LV Rim and shine
	175000, //LV Gas Station
	192500, //LV Starbucks Casino
	49000, //LV Behind the strip motel
	17500, //LV Souvenir Shops
	175000, //Centerparks Gambling Cottages
	192500, //LV Yellow Bell Golf Course
	70000, //LV Public Transport Maintenance
	42000, //LV Aztec Motel
	42000, //LV La Conca Motel
	42000, //LV Mideval Casino Hotel
	140000, //LV The Old Cowboy
	140000, //LV The kicking heels
	140000, //LV Royal Casino
	140000, //LV Come-a-lot Casino
	21000, //LV Cargo Harbour Depot
	140000, //LV Dr. Pheely Confession Center
	17500, //LV Chuckup
	87500, //LV Final Build Construction
	227500, //LV Shoody Used Cars
	175000, //LS Taxi Company
	0,  //Hacking the bank
	0,  //Jailbreak
	262500, //Jos's DJ Control room
	560000, //Admin weapon storeroom
	525000, //Nitro explosives lab
	245000, //BeerTender
	280000, // LS Memorial museum
	87500, // LS Sex shop
	210000, // LS The Bahamas Apartments
	3500000, // Angel Pine Medical Center
	3500000, // El Quebrados Medical Center
	98000, // Old Gold Mine
	210000, // Vortex rental service
	0,  // Speedo
	0,   // SF Bank
	175000, // Gasstation emerald isle
	175000, // Gasstation behind camel toe
	175000, // Gasstation besides camel toe
	175000, // Gasstation Spinybed
	175000, // Gasstation Tierra Nobada
	175000, // Gasstation Juniper Hallow
	175000, // Gasstation idlewood
	175000, // Gasstation flint county
	1400000, //LS Town hall
	2100000, //SA Governor office
	1400000,
	2450000, //Highway patrol HQ
	0,
	0,
	0,

	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0
};

new propertyOwner[MAX_PROPERTIES] = {
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999,999,999,
	999,999,999,999,999,999,999,999
};

new ErrorMessages[36][93] = {
	"BREAKFAST.SYS halted... Cereal port not responding. Try another command.",
	"Errr what? What? Don't disturb my coffee break with an unknown command!",
	"Bad or missing mouse. Spank the cat? (Y/N)",
	"COFFEE.SYS missing... Insert cup in cup holder and press any key.",
	"File not found. Should I fake it? (Y/N)",
	"Press any key except... No, No, No, NOT THAT ONE!",
	"Press any key to continue or any other key to quit. ",
	"Error saving file! Format drive now? (Y/Y)",
	"Browser not responding. I'm not listening!",
	"Game over. Insert quarter to browse the Internet. ",
	"Aliens must have abducted this page!",
	"The web page you requested was accidentally shredded during transfer. Please try back later.",
	"If you're reading this, it means this page is no more. It's probably not your fault.",
	"We didn't do it.",
	"The page you requested is taking a coffee break.",
	"Keyboard not found. Hit F1 to continue",
	"BOB says: You seem to have mispelled your command, enter another! ",
	"To help you protect your computer, Windows has closed this program: SA-MP",
	"I am a wicked error message, and you just have to try again :)",
	"This page cannot be displayed because you need some fresh air.",
	"You must be running a version of Microsoft Windows to be able to use Windows Update",
	"The Internet cannot be stored in the Recycle Bin",
	"Error: The operation completed successfully.",
	"A number should have been here; I inserted 0. Result: you get no raise.",
	"Contacting online helpdesk. Rate $250 per second. Proceed? (OK/OK)",
	"Why are you here? You shouldn't even got to this point. Go back. NOW!",
	"zzzzzzzzzzzzzzzzzzzzzzz uhm what? oh... nothing....... zzzzzzzzzzzzzzzzzz",
	"Your advertisement can be here. Call 555-1234-5678 NOW!",
	"You have reached the end of the game.",
	"That was the most original line i saw someone use i a long, long time. Congratulations!",
	"Your error message can be here! Call 999-i-wanna-be-famous NOW!",
	 "Out of diskspace. Delete Windows in order to free up some space?",
	 "I thought i saw a puddy cat. I did! I did saw a puddy cat!",
	 "Mjeeeeeeeeeeeh what's up doc?",
	 "Whooooooooooooeshhhhhh MIEP MIEP whoooooooooooooooooeshhhhhhhh",
	 "Shhhhhhhhht I am gonna kill a whabbit! Kghehehehhehehehehehe"
};

new RussianRoulette1[6][32] = {
	"[O][_][_][_][_][_]",
	"[_][O][_][_][_][_]",
	"[_][_][O][_][_][_]",
	"[_][_][_][O][_][_]",
	"[_][_][_][_][O][_]",
	"[_][_][_][_][_][O]"
};

new RussianRoulette2[6][32] = {
	"[O][_][_][O][_][_]",
	"[_][O][_][_][O][_]",
	"[_][_][O][_][_][O]",
	"[O][_][_][O][_][_]",
	"[_][O][_][_][O][_]",
	"[_][_][O][_][_][O]"
};

new RussianRoulette3[6][32] = {
	"[O][_][O][_][O][_]",
	"[_][O][_][O][_][O]",
	"[O][_][O][_][O][_]",
	"[_][O][_][O][_][O]",
	"[O][_][O][_][O][_]",
	"[_][O][_][O][_][O]"
};

new RussianRoulette1End[6] = { 0, 0, 0, 0, 0,1 };
new RussianRoulette2End[6] = { 0, 0, 1, 0, 0,1 };
new RussianRoulette3End[6] = { 0, 1, 0, 1, 0,1 };

new RussianRouletteChoice;
new russianmatch[2];
new deathmatcher23[MAX_PLAYERS];
new russiancountdownseconds;
new russiancountdownseconds2;
new russianmatchstarted;
new russianmatchplayers[MAX_PLAYERS];
new playersrussianmatch;
new russianmatchinprogress;
new spintime;
new CurrentRoulettePlayer;
new RouletteCurrentPlayer;
new russianroulettecounter;
new solution;
new spinning;
new russianrouletteplayer0;
new russianrouletteplayer1;
new spincycle;
new RussianTimer;

new PatrolDisable;
new PatrolCountingUp;
new PatrolTimer;
new PatrolTimer2;

new SuspectedSpeedCheater[MAX_PLAYERS];
new SuspectedSpeedCheaterTimer[MAX_PLAYERS];

new manuallock[255];
new autolock[MAX_PLAYERS];
new Fuelcan[MAX_PLAYERS];
new FuelcanContent[MAX_PLAYERS];

new Payout[MAX_PLAYERS];

new TaxiPricePlayer[5] = {
	10000,
	25000,
	75000,
	150000,
	250000
};

new TaxiPriceReward[5] = {
	3000,
	6000,
	9000,
	18000,
	50000
};

new TaxiPriceOwner[5] = {
	5000,
	12500,
	37500,
	75000,
	125000
};

new Fines[20] = {
	250,
	1000,
	2500,
	10000,
	25000,
	50000,
	100000,
	200000,
	200000,
	200000,
	200000,
	250000,
	250000,
	250000,
	250000,
	250000,
	250000,
	250000,
	250000,
	250000
};

new Float:OwnSpawnLocations[9][3] = {
	{2673.7732,-2018.1278,13.5477}, //LS near low tuner
	{-1956.6963,287.3948,41.0471},  //SF wang cars
	{1265.2467,2609.1108,10.8203},  //LV near golf course
	{2822.2224,2139.2339,10.8203},  //LV creek
	{2510.6382,1420.5892,10.9063},  //LV Pilgrim
	{2511.8354,-1667.6631,13.5658}, //LS Grove street
	{1279.8203,-826.6539,83.1406},  //LS Madd Dogg's
	{2272.1655,2398.4124,10.8203}, // LV at LVPD
	{2135.5295,1443.9397,10.8203} // LV Royal casino

};

new OwnSpawnPrices[9] = {
	37500000,
	100000000,
	62500000,
	25000000,
	75000000,
	87500000,
	150000000,
	11000000,
	15000000
};

new Float:ChairLift1Coords[21][3] = {
{-2384.9214,-2230.9839,33.2891},
{-2378.0,-2206.0,61.0},
{-2372.0,-2182.0,84.0},
{-2365.0,-2158.0,107.0},
{-2359.0,-2134.0,130.0},
{-2352.0,-2110.0,153.0},
{-2346.0,-2086.0,176.0},
{-2339.0,-2062.0,199.0},
{-2333.0,-2038.0,222.0},
{-2326.0,-2014.0,245.0},
{-2320.0,-1990.0,268.0},
{-2313.0,-1966.0,291.0},
{-2307.0,-1942.0,314.0},
{-2300.0,-1918.0,337.0},
{-2294.0,-1894.0,360.0},
{-2287.0,-1870.0,383.0},
{-2281.0,-1846.0,406.0},
{-2274.0,-1822.0,429.0},
{-2268.0,-1798.0,452.0},
{-2261.0,-1774.0,475.0},
{-2255.6694,-1746.6718,487.6}
};

new Float:ChairLift2Coords[21][3] = {
	{-1400.1160,825.8342,47.8557},
	{-1464.0,864.0,62.0},
	{-1528.0,903.0,77.0},
	{-1592.0,942.0,92.0},
	{-1656.0,981.0,107.0},
	{-1720.0,1020.0,122.0},
	{-1784.0,1059.0,137.0},
	{-1848.0,1098.0,152.0},
	{-1912.0,1137.0,167.0},
	{-1976.0,1176.0,182.0},
	{-2040.0,1215.0,197.0},
	{-2104.0,1254.0,212.0},
	{-2168.0,1293.0,227.0},
	{-2232.0,1332.0,240.0},
	{-2296.0,1371.0,240.0},
	{-2360.0,1410.0,240.0},
	{-2424.0,1449.0,240.0},
	{-2488.0,1488.0,240.0},
	{-2552.0,1527.0,240.0},
	{-2616.0,1566.0,228.0},
	{-2681.4475,1595.3885,217.2739}
};



//Katana en kettingzaag verwijderd, array aangepast
new weaponNamesMelee[2][32] = {
	"Knife",
	"Baseball Bat"
};

new weaponIDsMelee[2] = {
	4,      //Knife
	5       //Baseball
};

new weaponCostMelee[2] = {
	1500,
	2000
};

new weaponNamesPistols[3][32] = {
	"Pistol",
	"Silenced Pistol",
	"Desert Eagle"
};

new weaponIDsPistols[3] = {
	22,     //Pistol
	23,     //Silenced
	24      //DE
};

new weaponCostPistols[3] = {
	20,
	30,
	60
};

new weaponNamesShotguns[3][32] = {
	"Shotgun",
	"Sawn-off",
	"Combat Shotgun"
};

new weaponIDsShotguns[3] = {
	25,     //Shotgun
	26,     //Sawnoff
	27      //Combat shotgun
};

new weaponCostShotguns[3] = {
	70,
	120,
	150
};

new weaponNamesSMGs[3][32] = {
	"Tec9",
	"Micro Uzi",
	"MP5"
};

new weaponIDsSMGs[3] = {
	32,     //Tec9
	28,     //Micro Uzi
	29      //MP5
};

new weaponCostSMGs[3] = {
	50,
	80,
	150
};

new weaponNamesRifles[2][32] = {
	"AK47",
	"M4"
};

new weaponIDsRifles[2] = {
	30,     //AK47
	31		//M4
};

new weaponCostRifles[2] = {
	250,
	300
};

new weaponNamesGift[3][32] = {
	"Purple Dildo",
	"White Dildo",
	"Flowers"
};

new weaponIDsGift[3] = {
	10,     //Purple Dildo
	12,     //White Dildo
	14      //Flowers
};

new weaponCostGift[3] = {
	5000,
	4500,
	10000
};

new Float:LVBoundaries[4] = {882.0,457.0,2917.0,2845.0};

new alphabet[27][3] = {
	"A","B","C","D","E","F","G","H","I","J","K","L",
	"M","N","O","P","Q","R","S","T","U","V","W","R",
	"X","Y","Z"
};

new calphabet[27][3] = {
	"a","b","c","d","e","f","g","h","i","j","k","l",
	"m","n","o","p","q","r","s","t","u","v","w","r",
	"x","y","z"
};

new TaxiID[1] = {
	420
};

new MotorIDTemp1[5] = {
        463,
        586,
        468,
        471,
        521
};
new MotorIDTemp2[4];
new MotorIDTemp3[3];
new MotorID[3];
new MotorIDCounter;

new NormalCarIDTemp1[27] ={
	400,
	412,
	458,
	500,
	526,
	536,
	554,
	579,
	589,
	405,
	419,
	475,
	507,
	533,
	545,
	575,
	580,
	600,
	409,
	445,
	482,
	518,
	534,
	551,
	576,
	587,
	602
};

new NormalCarIDTemp2[26];
new NormalCarIDTemp3[25];
new NormalCarIDTemp4[24];
new NormalCarIDTemp5[23];
new NormalCarIDTemp6[22];
new NormalCarIDTemp7[21];
new NormalCarIDTemp8[20];
new NormalCarIDTemp9[19];
new NormalCarIDTemp10[18];
new NormalCarID[10];
new NormalCarIDCounter;

new PerformanceCarIDTemp1[10] = {
	411,
	429,
	477,
	494,
	541,
	415,
	451,
	480,
	506,
	555
};

new PerformanceCarIDTemp2[9];
new PerformanceCarIDTemp3[8];
new PerformanceCarIDTemp4[7];
new PerformanceCarIDTemp5[6];
new PerformanceCarIDTemp6[5];
new PerformanceCarID[6];
new PerformanceCarIDCounter;

new StreetRacerIDTemp1[13] = {
	402,
	470,
	495,
	535,
	558,
	559,
	560,
	561,
	562,
	565,
	568,
	603,
	434
};
new StreetRacerID[12];

new TruckID[3] = {
	403,
	455,
	515
};

new BusID[2] = {
	431,
	437
};

new MonsterID[4] = {
	444,
	556,
	557,
	571
};
new AircraftID[3] = {
	511,
	513,
	593
};

new HelicopterIDTemp1[6] = {
	417,
	469,
	487,
	488,
	497,
	548
};
new HelicopterIDTemp2[5];
new HelicopterID[2];
new HelicopterIDCounter;

new ForbiddenTuningVehicles[23] = {
	521,
	522,
	554,
	482,
	443,
	444,
	556,
	557,
	431,
	437,
    463,
    586,
    468,
    471,
    571,
	403,
	455,
	515,
	494,
	470,
	434,
	495,
	568
};

new DaysOfTheWeek[7][5] = {
	"Mon",
	"Tue",
	"Wed",
	"Thu",
	"Fri",
	"Sat",
	"Sun"
};

new PizzaLocs[11] = {
	CP_CIAOFFICE,
	CP_DEA,
	CP_SAMINT,
	CP_SFTOWN,
	CP_WANGCARS,
	CP_FBI,
	CP_SADIRT,
	CP_DRUGS,
	CP_SOLARFAC,
	CP_BAYYACHT,
	CP_CIAHID
};

new PizzaTimes[11] = {
	30,
	40,
	45,
	60,
	45,
	65,
	75,
	70,
	40,
	85,
	70
};

new PropsForHelper[13] = {
	P_PIGFARM,
	P_LOGGING,
	P_FLINTRANCH,
	P_DIARY,
	P_FLINTMOT,
	P_COTTON,
	P_LSCARGODCK,
	P_LSCONTAINER,
	P_LSMARKET,
	P_ZERO_RC,
	P_SFCONT,
	P_JAYDINER,
	P_BAIT
};

#define MAX_TAXIPOINTS 33

new Float:TaxiCheckpoints[MAX_TAXIPOINTS][3]= {
	{0.0,0.0,0.0},
	{1842.9419,-1368.6844,13.1773}, // skate park
	{2001.8976,-1445.9836,13.3424}, // checkpoint ziekenhuis
	{1824.4877,-1682.4564,13.1578}, // dancing
	{1752.0406,-1858.0789,13.1935}, // unity station
	{1840.8210,-1871.5017,13.1705}, // liquor store
	{1946.8456,-2114.3955,13.3279}, // sex shop
	{1673.7010,-2251.1213,13.1614}, // LS airport
	{2189.5237,-2261.7458,13.2760}, // cargo company
	{2791.1599,-1831.6287,9.6306}, // dirt ring ls
	{2817.6675,-1091.5132,30.5174}, // hotel on the beach
	{2307.2717,-1655.3650,14.1442}, // ten green bottles
	{2227.8613,-1333.0245,23.7629}, // Church
	{2125.7761,-1113.8955,24.9548}, // coutt and schutz
	{1360.5825,-1280.1473,13.1548}, // ammunation
	{1484.4933,-1736.0096,13.1615}, // LS PD
	{1183.7045,-1750.4260,13.1779}, // congress center
	{1081.0630,-1708.2115,13.1624}, // Papercuts office supplies
	{372.2534,-2043.9337,7.4508}, // the brown starfish
	{1120.2218,-1409.3185,13.1930}, // the mall
	{726.0953,-1437.6758,13.3134}, // jetty lounge
	{447.1570,-1479.1387,30.3731}, // didier sachs
	{333.6991,-1520.4132,35.6405}, // curved hotel
	{543.5745,-1506.9166,14.1535}, // tableau
	{1003.1880,-1152.2180,23.5137}, // el dritch
	{1123.2458,-1137.3052,23.4362}, // vice cinema
	{1497.1281,-702.4579,94.5257}, // frank ditrina
	{297.4555,-1157.5302,80.6878}, // tom cross
	{260.5511,-1364.7433,52.8883}, // oprah lintrey
	{638.4233,-572.1149,15.9667}, // dillmore pd
	{2035.0227,1007.2243,10.6007}, // four dragons
	{2175.0845,1119.6061,12.4522}, // Come-a-lot
	{1710.6228,1441.4796,10.4226} // lv airport
};

new TaxiCheckpointDescriptions[MAX_TAXIPOINTS][32] = {
	"none",
	"LS Skate Park",
	"LS Hospital",
	"Dancing Idlewood",
	"Unity Station",
	"Liquor store",
	"Sex Shop",
	"LS Airport",
	"Cargo Company",
	"LS Dirt Ring",
	"Hotel On The Beach",
	"Ten Green Bottles",
	"Reverend Greens Church",
	"Coutt and Schutz",
	"Ammunation",
	"LS Police Department",
	"Congress Center",
	"Papercuts Office",
	"Brown Starfish",
	"Mall",
	"Jetty Lounge",
	"Didier Sachz",
	"Curved Hotel",
	"Tableau",
	"El Dritch",
	"Vice Cinema",
	"Frank Ditrina",
	"Tom Cross",
	"Oprah Lintrey",
	"Dillmore PD",
	"Four Dragons",
	"Come-a-Lot",
	"LV Airport"
};

new TaxiDriverLocs[MAX_TAXIPOINTS] = {
	CP_TAXI_NONE,
	CP_TAXI_SKATEPARK,
	CP_TAXI_HOSPITAL,
	CP_TAXI_DANCING,
	CP_TAXI_UNITY,
	CP_TAXI_LIQUOR,
	CP_TAXI_SEXSHOP,
	CP_TAXI_LSAIRPORT,
	CP_TAXI_CARGOCOMPANY,
	CP_TAXI_DIRTRING,
	CP_TAXI_HOTELBEACH,
	CP_TAXI_TENGREENBOTTLES,
	CP_TAXI_CHURCH,
	CP_TAXI_COUTTANDSCHUTZ,
	CP_TAXI_AMMUNATION,
	CP_TAXI_LSPD,
	CP_TAXI_CONGRESCENTER,
	CP_TAXI_PAPERCUTS,
	CP_TAXI_BROWNSTARFISH,
	CP_TAXI_MALL,
	CP_TAXI_JETTYLOUNGE,
	CP_TAXI_DIDIERSACHZ,
	CP_TAXI_HILLHOTEL,
	CP_TAXI_TABLEAU,
	CP_TAXI_ELDRITCH,
	CP_TAXI_VICECINEMA,
	CP_TAXI_FRANKDITRINA,
	CP_TAXI_TOMCROSS,
	CP_TAXI_OPRAHLINTREY,
	CP_TAXI_DILLMOREPD,
	CP_TAXI_FOURDRAGONS,
	CP_TAXI_COMEALOT,
	CP_TAXI_LVAIRPORT
};

new Float:TaxiCheckCheckpoints[MAX_TAXIPOINTS][4]= {
	{0.0,0.0,0.0,0.0},
	{1792.0,-1418.0,1892.0,-1318.0}, // skate park
	{1951.0,-1495.0,2051.0,-1395.0}, // checkpoint ziekenhuis
	{1774.0,-1732.0,1874.0,-1632.0}, // dancing
	{1702.0,-1908.0,1802.0,-1808.0}, // unity station
	{1790.0,-1921.0,1890.0,-1821.0}, // liquor store
	{1896.0,-2164.0,1996.0,-2064.0}, // sex shop
	{1623.0,-2301.0,1723.0,-2201.0}, // LS airport
	{2139.0,-2311.0,2239.0,-2211.0}, // cargo company
	{2741.0,-1881.0,2841.0,-1781.0}, // dirt ring ls
	{2767.0,-1141.0,2867.0,-1041.0}, // hotel on the beach
	{2257.0,-1705.0,2357.0,-1605.0}, // ten green bottles
	{2177.0,-1383.0,2277.0,-1283.0}, // Church
	{2075.0,-1163.0,2175.0,-1063.0}, // coutt and schutz
	{1310.0,-1330.0,1410.0,-1230.0}, // ammunation
	{1434.0,-1786.0,1534.0,-1686.0}, // LS PD
	{1133.0,-1800.0,1233.0,-1700.0}, // congress center
	{1031.0,-1758.0,1131.0,-1658.0}, // Papercuts office supplies
	{322.0,-2093.0,422.0,-1993.0}, // the brown starfish
	{1070.0,-1459.0,1170.0,-1359.0}, // the mall
	{676.0,-1487.0,776.0,-1387.0}, // jetty lounge
	{397.0,-1529.0,497.0,-1429.0}, // didier sachs
	{283.0,-1570.0,383.0,-1470.0}, // curved hotel
	{493.0,-1556.0,593.0,-1456.0}, // tableau
	{953.0,-1202.0,1053.0,-1102.0}, // el dritch
	{1073.0,-1187.0,1173.0,-1087.0}, // vice cinema
	{1447.0,-752.0,1547.0,-652.0}, // frank ditrina
	{247.0,-1207.0,347.0,-1107.0}, // tom cross
	{210.0,-1414.0,310.0,-1314.0}, // oprah lintrey
	{588.0,-622.0,688.0,-522.0}, // dillmore pd
	{1985.0,957.0,2085.0,1057.0}, // four dragons
	{2125.0,1069.0,2225.0,1169.0}, // Come-a-lot
	{1660.0,1391.0,1760.0,1491.0} // lv airport
};

new Float:SprintRace3Checkpoints[SPRINTRACE3CPS][3] = {
	{0.0,0.0,0.0},
	{1265.2233,831.4880,7.6814}, // checkpoint 1
	{750.0812,680.4224,10.4515}, // checkpoint 2
	{334.8338,800.5916,9.3055}, // checkpoint 3
	{206.4792,1021.9232,24.5143}, // checkpoint 4
	{238.1329,1204.0543,15.0885}, // checkpoint 5
	{560.6181,1697.7841,9.3036}, // checkpoint 6
	{663.3581,1982.0692,6.4506}, // checkpoint 7
	{809.1917,2623.7654,13.1891}, // checkpoint 8
	{1176.6080,2417.5630,10.5888}, // checkpoint 9
	{1729.3610,2420.7715,6.3348}, // checkpoint 10
	{1788.2045,1541.5314,6.2991}, // checkpoint 11
	{1841.1792,835.7439,9.4550}, // checkpoint 12
	{2227.7046,833.5961,6.2923}, // checkpoint 13
	{2764.6633,1393.4355,8.0430}, // checkpoint 14
	{2727.3530,1653.4526,6.2753}, // checkpoint 15
	{2626.8599,2527.0012,5.7354}, // checkpoint 16
	{1902.5421,2530.6628,6.3612} // finish
};

new Float:SprintRace3Boundaries[SPRINTRACE3CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{1190.0,756.0,1340.0,906.0}, // checkpoint 1
	{675.0,605.0,825.0,755.0}, // checkpoint 2
	{259.0,725.0,409.0,875.0}, // checkpoint 3
	{131.0,946.0,281.0,1096.0}, // checkpoint 4
	{163.0,1129.0,313.0,1279.0}, // checkpoint 5
	{485.0,1622.0,635.0,1772.0}, // checkpoint 6
	{588.0,1907.0,738.0,2057.0}, // checkpoint 7
	{734.0,2548.0,884.0,2698.0}, // checkpoint 8
	{1101.0,2342.0,1251.0,2492.0}, // checkpoint 9
	{1654.0,2345.0,1804.0,2495.0}, // checkpoint 10
	{1713.0,1466.0,1863.0,1616.0}, // checkpoint 11
	{1766.0,760.0,1916.0,910.0}, // checkpoint 12
	{2152.0,758.0,2302.0,908.0}, // checkpoint 13
	{2689.0,1318.0,2839.0,1468.0}, // checkpoint 14
	{2652.0,1578.0,2802.0,1728.0}, // checkpoint 15
	{2551.0,2452.0,2701.0,2602.0}, // checkpoint 16
	{1827.0,2455.0,1977.0,2605.0} // finish
};

new Float:SprintRace4Checkpoints[SPRINTRACE4CPS][3] = {
	{0.0,0.0,0.0},
	{-1038.8374,1181.0211,37.4648}, // race 2 checkpoint 1
	{-121.0527,571.0194,15.5576}, // race 2 checkpoint 2
	{239.8117,724.7269,6.3836}, // race 2 checkpoint 3
	{408.6784,630.0157,17.5044}, // race 2 checkpoint 4
	{598.6907,301.3333,18.8753}, // race 2 checkpoint 5
	{519.9007,157.5942,23.2737}, // race 2 checkpoint 6
	{499.2551,-139.3373,35.3367}, // race 2 checkpoint 7
	{282.7798,-168.1177,1.1366}, // race 2 checkpoint 8
//	{151.5731,-211.9565,1.1365}, // race 2 checkpoint 9
	{-88.7088,-170.4104,2.1424}, // race 2 checkpoint 10
	{-41.2613,184.1269,1.7856}, // race 2 checkpoint 11
	{-231.4705,209.0076,11.0186}, // race 2 checkpoint 12
	{-349.5817,172.4423,6.1019}, // race 2 checkpoint 13
	{-485.1812,213.3821,8.0254}, // race 2 checkpoint 14
	{-681.2037,199.9024,21.0048}, // race 2 checkpoint 15
	{-617.1487,-18.6716,61.8699}, // race 2 checkpoint 16
	{-511.2001,-111.8677,64.2008}, // race 2 checkpoint 17
	{-546.9698,-189.6591,78.1131}, // race 2 checkpoint 18
	{-889.0449,-134.6811,57.1693}, // race 2 checkpoint 19
	{-963.3375,-323.7234,35.9695}, // race 2 checkpoint 20
	{-1090.5641,-483.4200,32.9953}, // race 2 checkpoint 21
	{-1275.6090,-798.1252,68.7437}, // race 2 checkpoint 22
	{-1833.3851,-580.1902,16.7071}, // race 2 checkpoint 23
	{-1922.7976,-553.6967,24.1445}, // race 2 checkpoint 24
	{-1904.7372,-15.4805,37.9490} // finish race 2
};

new Float:SprintRace4Boundaries[SPRINTRACE4CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{-1113.0,1106.0,-963.0,1256.0}, // race 2 checkpoint 1
	{-196.0,496.0,-46.0,646.0}, // race 2 checkpoint 2
	{164.0,649.0,314.0,799.0}, // race 2 checkpoint 3
	{333.0,555.0,483.0,705.0}, // race 2 checkpoint 4
	{523.0,226.0,673.0,376.0}, // race 2 checkpoint 5
	{444.0,82.0,594.0,232.0}, // race 2 checkpoint 6
	{424.0,-214.0,574.0,-64.0}, // race 2 checkpoint 7
	{272.0,-178.0,307.0,-143.0}, // race 2 checkpoint 8
//	{1.0,-261.0,101.0,-161.0},	//race 2 checkpoint 9
	{-163.0,-245.0,-13.0,-95.0}, // race 2 checkpoint 10
	{-116.0,109.0,34.0,259.0}, // race 2 checkpoint 11
	{-306.0,134.0,-156.0,284.0}, // race 2 checkpoint 12
	{-424.0,97.0,-274.0,247.0}, // race 2 checkpoint 13
	{-560.0,138.0,-410.0,288.0}, // race 2 checkpoint 14
	{-756.0,124.0,-606.0,274.0}, // race 2 checkpoint 15
	{-692.0,-93.0,-542.0,57.0}, // race 2 checkpoint 16
	{-586.0,-186.0,-436.0,-36.0}, // race 2 checkpoint 17
	{-621.0,-264.0,-471.0,-114.0}, // race 2 checkpoint 18
	{-964.0,-209.0,-814.0,-59.0}, // race 2 checkpoint 19
	{-1038.0,-398.0,-888.0,-248.0}, // race 2 checkpoint 20
	{-1165.0,-558.0,-1015.0,-408.0}, // race 2 checkpoint 21
	{-1350.0,-873.0,-1200.0,-723.0}, // race 2 checkpoint 22
	{-1908.0,-655.0,-1758.0,-505.0}, // race 2 checkpoint 23
	{-1997.0,-628.0,-1847.0,-478.0}, // race 2 checkpoint 24
	{-1979.0,-90.0,-1829.0,60.0} // finish race 2
};

new Float:SprintRace5Checkpoints[SPRINTRACE5CPS][3] = {
	{0.0,0.0,0.0},
	{-2143.2112,578.9691,35.0529}, // checkpoint 1
	{-2143.2698,831.3329,69.0895}, // checkpoint 2
	{-2142.9651,1044.3755,79.5336}, // checkpoint 3
	{-2222.5835,1176.1350,55.2602}, // checkpoint 4
	{-2506.9727,1241.2617,34.6977}, // checkpoint 5
	{-2738.6353,1068.7064,47.0781}, // checkpoint 6
	{-2750.7419,822.3418,53.0462}, // checkpoint 7
	{-2750.5459,632.3293,27.4477}, // checkpoint 8
	{-2763.3000,467.0146,4.8882}, // checkpoint 9
	{-2853.6111,392.3500,4.0375}, // checkpoint 10
	{-2809.0413,120.4015,6.7145}, // checkpoint 11
	{-2819.7068,-370.2010,6.7144}, // checkpoint 12
	{-2714.3472,-529.2330,9.9409}, // checkpoint 13
	{-2413.4678,-370.2825,73.3482}, // checkpoint 14
	{-2423.0698,-608.0286,132.2457}, // checkpoint 15
	{-2221.5276,-941.1774,40.2666}, // checkpoint 16
	{-1947.0023,-1350.5380,40.4835}, // checkpoint 17
	{-1527.1375,-1418.2947,41.3534}, // checkpoint 18
	{-1748.9283,-952.9896,75.3463} // finish race 3
};

new Float:SprintRace5Boundaries[SPRINTRACE5CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{-2193.0,528.0,-2093.0,628.0}, // checkpoint 1
	{-2193.0,781.0,-2093.0,881.0}, // checkpoint 2
	{-2172.0,994.0,-2092.0,1094.0}, // checkpoint 3
	{-2272.0,1126.0,-2152.0,1226.0}, // checkpoint 4
	{-2556.0,1191.0,-2456.0,1291.0}, // checkpoint 5
	{-2788.0,1018.0,-2688.0,1118.0}, // checkpoint 6
	{-2800.0,772.0,-2700.0,872.0}, // checkpoint 7
	{-2800.0,582.0,-2700.0,682.0}, // checkpoint 8
	{-2803.0,437.0,-2713.0,517.0}, // checkpoint 9
	{-2903.0,342.0,-2813.0,422.0}, // checkpoint 10
	{-2859.0,70.0,-2759.0,170.0}, // checkpoint 11
	{-2869.0,-420.0,-2769.0,-320.0}, // checkpoint 12
	{-2764.0,-579.0,-2664.0,-479.0}, // checkpoint 13
	{-2463.0,-420.0,-2363.0,-320.0}, // checkpoint 14
	{-2473.0,-658.0,-2373.0,-558.0}, // checkpoint 15
	{-2271.0,-991.0,-2171.0,-891.0}, // checkpoint 16
	{-1997.0,-1400.0,-1897.0,-1300.0}, // checkpoint 17
	{-1577.0,-1468.0,-1477.0,-1368.0}, // checkpoint 18
	{-1798.0,-1002.0,-1698.0,-902.0} // finish race 3
};

new Float:SprintRace6Checkpoints[SPRINTRACE6CPS][3] = {
	{0.0,0.0,0.0},
	{2313.5244,-1658.9688,13.8056}, // 1
	{2156.5588,-1630.6167,13.3973}, // 2
	{2082.0679,-1731.3560,13.0153}, // 3
	{2085.1941,-1463.4760,23.3472}, // 4
	{1987.2159,-1360.0508,23.3954}, // 5
	{2069.3154,-1295.7301,23.4451}, // 6
	{2047.1774,-1079.2786,24.2899}, // 7
	{2042.5071,-978.6703,42.5037}, // 8
	{2268.4294,-1062.4613,48.2392}, // 9
	{2560.1074,-1067.7457,68.6742}, // 10
	{2388.4253,-1174.4724,27.6984}, // 11
	{2571.2678,-1201.6365,59.7281}, // 12
	{2570.6162,-1401.6058,26.2025}, // 13
	{2430.9580,-1485.2371,23.4529}, // 14
	{2642.7896,-1425.2360,29.9095}, // 15
	{2684.5403,-1257.0015,54.8920}, // 16
	{2722.5945,-1370.9990,40.6636}, // 17
	{2686.6836,-1609.5944,14.5262}, // 18
	{1821.6917,-1712.1354,13.0078}, // 19
	{1689.7939,-1833.2760,13.0074}, // 20
	{1426.7124,-1899.2595,13.3689}, // 21
	{1263.7832,-2028.1277,58.9366} // finish
};

new Float:SprintRace6Boundaries[SPRINTRACE6CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{2263.0,-1708.0,2363.0,-1608.0}, // 1
	{2106.0,-1680.0,2206.0,-1580.0}, // 2
	{2032.0,-1781.0,2132.0,-1681.0}, // 3
	{2035.0,-1513.0,2135.0,-1413.0}, // 4
	{1937.0,-1410.0,2037.0,-1310.0}, // 5
	{2019.0,-1345.0,2119.0,-1245.0}, // 6
	{1997.0,-1129.0,2097.0,-1029.0}, // 7
	{1992.0,-1028.0,2092.0,-928.0}, // 8
	{2218.0,-1112.0,2318.0,-1012.0}, // 9
	{2510.0,-1117.0,2610.0,-1017.0}, // 10
	{2338.0,-1224.0,2438.0,-1124.0}, // 11
	{2521.0,-1251.0,2621.0,-1151.0}, // 12
	{2520.0,-1451.0,2620.0,-1351.0}, // 13
	{2380.0,-1535.0,2480.0,-1435.0}, // 14
	{2592.0,-1475.0,2692.0,-1375.0}, // 15
	{2634.0,-1307.0,2734.0,-1207.0}, // 16
	{2672.0,-1420.0,2772.0,-1320.0}, // 17
	{2636.0,-1659.0,2736.0,-1559.0}, // 18
	{1771.0,-1762.0,1871.0,-1662.0}, // 19
	{1639.0,-1883.0,1739.0,-1783.0}, // 20
	{1376.0,-1949.0,1476.0,-1849.0}, // 21
	{1213.0,-2078.0,1313.0,-1978.0} // 22
};

new Float:SprintRace7Checkpoints[SPRINTRACE7CPS][3] = {
	{0.0,0.0,0.0},
	{2389.5247,-1603.4480,9.4337}, // 1
	{1998.3375,-1500.9589,2.9488}, // 2
	{1644.9954,-1444.4038,27.1746}, // 3
	{1661.2402,-1023.6398,61.8581}, // 4
	{1686.2108,-376.6097,40.4675}, // 5
	{1615.9075,77.8483,37.0968}, // 6
	{1734.7108,482.9826,29.3950}, // 7
	{1805.9589,883.1467,9.5811}, // 8
	{1806.3895,1764.0159,6.3008}, // 9
	{1813.0745,2403.5854,8.7442}, // 10
	{1441.3218,2473.4944,6.3120}, // 11
	{1208.2557,1901.2937,6.3084}, // 12
	{1209.5742,1109.8424,6.3799}, // 13
	{1179.6637,930.3778,9.2262}, // 14
	{917.1033,736.7960,10.2479}, // 15
	{334.2241,776.0076,5.7143}, // 16
	{-72.5763,628.1174,4.3013}, // 17
	{-292.3900,586.1120,14.9997}, // 18
	{-837.0349,855.5368,21.1245}, // 19
	{-886.3389,1187.5968,31.0143}, // 20
	{-1205.4772,1042.3275,41.7057}, // 21
	{-1809.9917,403.8501,38.9592}, // 22
	{-1933.3481,-238.5397,38.5693}, // 23
	{-2269.9187,-335.6720,39.3114}, // 24
	{-2874.4917,-771.3510,6.8707}, // 25
	{-2926.1108,-1522.0731,10.5964}, // 26
	{-2770.9839,-1961.5995,45.5145}, // 27
	{-2465.1746,-2376.5906,29.9748}, // 28
	{-1894.8527,-2583.4045,60.7585}, // 29
	{-824.2862,-2796.2017,71.5399}, // 30
	{-108.8688,-2810.0864,38.6289}, // 31
	{-318.7782,-2214.9521,28.4852}, // 32
	{-208.0150,-1529.7521,14.9355}, // 33
	{231.2098,-1176.5679,19.1068}, // 34
	{632.7710,-1328.8367,13.2306}, // 35
	{632.8750,-1691.5184,14.9486} // finish
};

new Float:SprintRace7Boundaries[SPRINTRACE7CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{2349.0,-1643.0,2429.0,-1563.0}, // 1
	{1958.0,-1540.0,2038.0,-1460.0}, // 2
	{1604.0,-1484.0,1684.0,-1404.0}, // 3
	{1621.0,-1063.0,1701.0,-983.0}, // 4
	{1646.0,-416.0,1726.0,-336.0}, // 5
	{1575.0,37.0,1655.0,117.0}, // 6
	{1694.0,442.0,1774.0,522.0}, // 7
	{1765.0,843.0,1845.0,923.0}, // 8
	{1766.0,1724.0,1846.0,1804.0}, // 9
	{1773.0,2363.0,1853.0,2443.0}, // 10
	{1401.0,2433.0,1481.0,2513.0}, // 11
	{1168.0,1861.0,1248.0,1941.0}, // 12
	{1169.0,1069.0,1249.0,1149.0}, // 13
	{1139.0,890.0,1219.0,970.0}, // 14
	{877.0,696.0,957.0,776.0}, // 15
	{294.0,736.0,374.0,816.0}, // 16
	{-112.0,588.0,-32.0,668.0}, // 17
	{-332.0,546.0,-252.0,626.0}, // 18
	{-877.0,815.0,-797.0,895.0}, // 19
	{-926.0,1147.0,-846.0,1227.0}, // 19
	{-1245.0,1002.0,-1165.0,1082.0}, // 20
	{-1849.0,363.0,-1769.0,443.0}, // 21
	{-1973.0,-278.0,-1893.0,-198.0}, // 22
	{-2309.0,-375.0,-2229.0,-295.0}, // 23
	{-2914.0,-811.0,-2834.0,-731.0}, // 24
	{-2966.0,-1562.0,-2886.0,-1482.0}, // 25
	{-2810.0,-2001.0,-2730.0,-1921.0}, // 26
	{-2505.0,-2416.0,-2425.0,-2336.0}, // 27
	{-1934.0,-2623.0,-1854.0,-2543.0}, // 28
	{-864.0,-2836.0,-784.0,-2756.0}, // 29
	{-148.0,-2850.0,-68.0,-2770.0}, // 30
	{-358.0,-2254.0,-278.0,-2174.0}, // 31
	{-248.0,-1569.0,-168.0,-1489.0}, // 32
	{191.0,-1216.0,271.0,-1136.0}, // 33
	{592.0,-1368.0,672.0,-1288.0}, // 34
	{592.0,-1731.0,672.0,-1651.0} // finish
};

new Float:MotorRace1Checkpoints[MOTORRACE1CPS][3] = {
	{0.0,0.0,0.0},
	{1556.8900,-101.0163,19.8549},
	{1486.9814,-204.9352,10.9096},
	{1216.2897,-107.7256,39.5667},
	{932.6250,-91.3819,17.2399},
	{712.4980,-182.9851,19.8246},
	{483.9587,-255.5238,10.4148},
	{393.9277,-400.5377,25.5375},
	{641.3456,-446.4301,15.7472},
	{641.8779,-591.5436,15.7510},
	{755.1595,-616.1576,14.6798},
	{831.3281,-579.4105,15.7446},
	{1032.4294,-454.6891,51.0483},
	{1287.0063,-378.0961,2.2839},
	{1753.3196,-342.9107,45.6251},
	{1937.3892,41.0083,33.1568},
	{2272.9045,41.5121,25.9010},
	{2178.2996,88.2597,24.4331},
	{1934.0956,172.2242,36.8447},
//	{2295.0576,60.9171,25.9026},
//	{2293.9407,47.2186,25.9021},
//	{2274.9856,91.6953,25.8996},
//	{2173.3542,88.7836,25.6499},
//	{2023.6536,105.5164,28.6033},
	{1643.8245,261.8438,18.9256},
	{1196.3491,305.2077,19.1149},
	{1011.6355,173.6023,29.5557},
	{549.0093,163.3321,25.4207}
};

new Float:MotorRace1Boundaries[MOTORRACE1CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{1506.0,-151.0,1606.0,-51.0},
	{1436.0,-254.0,1536.0,-154.0},
	{1166.0,-157.0,1266.0,-57.0},
	{882.0,-141.0,982.0,-41.0},
	{662.0,-232.0,762.0,-132.0},
	{433.0,-305.0,533.0,-205.0},
	{343.0,-450.0,443.0,-350.0},
	{591.0,-496.0,691.0,-396.0},
	{591.0,-641.0,691.0,-541.0},
	{705.0,-666.0,805.0,-566.0},
	{781.0,-629.0,881.0,-529.0},
	{982.0,-504.0,1082.0,-404.0},
	{1237.0,-428.0,1337.0,-328.0},
	{1703.0,-392.0,1803.0,-292.0},
	{1887.0,-9.0,1987.0,91.0},
	{2233.9045,16.5121,2302.9045,66.5121},
	{2153.2996,67.2597,2203.2996,113.2597},
	{1909.0956,147.2242,1959.0956,197.2242},
//	{2294.1,55.0,2325.0,110.0},
//	{2280.0,-3.0,2294.0,54.0},
//	{2224.0,41.0,2279.0,141.0},
//	{2123.0,38.0,2223.0,138.0},
//	{1973.0,55.0,2073.0,155.0},
	{1593.0,211.0,1693.0,311.0},
	{1146.0,255.0,1246.0,355.0},
	{961.0,123.0,1061.0,223.0},
	{499.0,113.0,599.0,213.0}
};

new Float:MotorRace2Checkpoints[MOTORRACE2CPS][3] = {
	{0.0,0.0,0.0},
	{-297.9578,1400.7583,71.8888},
	{-360.6155,1464.8595,63.3390},
	{-344.0800,1322.2688,50.7288},
	{-434.9034,1422.5676,32.3874},
	{-320.8375,1241.9546,23.7940},
	{-249.6524,1098.0939,19.1654},
	{-19.5826,1098.3175,19.1595},
	{267.8102,1105.4307,11.1853},
	{506.9973,1178.8215,9.0083},
	{713.4122,1150.4427,18.6082},
	{826.2361,1240.7797,26.2791},
	{854.1254,1569.8661,17.2537},
	{777.2477,1836.8617,5.0595},
	{726.6229,1764.2850,5.7625},
	{654.0826,1413.7889,11.0279},
	{563.5571,1368.8937,16.0692},
	{348.4911,1409.5425,6.1975},
	{530.0824,1731.5123,10.0906},
	{610.6719,1925.0253,26.2467},
	{592.7629,2101.9148,37.6180},
	{438.8539,2389.1267,26.6721},
	{326.8033,2410.8982,17.4008},
	{226.0820,2392.7368,15.9630},
	{41.8874,2310.2979,22.2624},
	{-366.0973,2559.2913,38.4302},
	{-391.9470,2489.0532,40.6124},
	{-504.7678,2429.6030,55.1614},
	{-749.1942,2539.8362,80.5511},
	{-823.8063,2475.4309,108.8607},
	{-682.3295,2332.5886,132.4742},
	{-862.8459,2309.0518,158.7866}
};

new Float:MotorRace2Boundaries[MOTORRACE2CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{-347.0,1350.0,-247.0,1450.0},
	{-410.0,1414.0,-310.0,1514.0},
	{-394.0,1272.0,-294.0,1372.0},
	{-484.0,1372.0,-384.0,1472.0},
	{-370.0,1191.0,-270.0,1291.0},
	{-299.0,1048.0,-199.0,1148.0},
	{-69.0,1048.0,31.0,1148.0},
	{217.0,1055.0,317.0,1155.0},
	{456.0,1128.0,556.0,1228.0},
	{663.0,1100.0,763.0,1200.0},
	{776.0,1190.0,876.0,1290.0},
	{804.0,1519.0,904.0,1619.0},
	{727.0,1786.0,827.0,1886.0},
	{676.0,1714.0,776.0,1814.0},
	{604.0,1363.0,704.0,1463.0},
	{513.0,1318.0,613.0,1418.0},
	{298.0,1359.0,398.0,1459.0},
	{480.0,1681.0,580.0,1781.0},
	{560.0,1875.0,660.0,1975.0},
	{542.0,2051.0,642.0,2151.0},
	{388.0,2339.0,488.0,2439.0},
	{276.0,2360.0,376.0,2460.0},
	{176.0,2342.0,276.0,2442.0},
	{-9.0,2260.0,91.0,2360.0},
	{-416.0,2509.0,-316.0,2609.0},
	{-441.0,2439.0,-341.0,2539.0},
	{-554.0,2379.0,-454.0,2479.0},
	{-799.0,2489.0,-699.0,2589.0},
	{-873.0,2425.0,-773.0,2525.0},
	{-732.0,2282.0,-632.0,2382.0},
	{-912.0,2259.0,-812.0,2359.0}
};

new Float:MotorRace3Checkpoints[MOTORRACE3CPS][3] = {
	{0.0,0.0,0.0},
	{-1735.8547,731.2056,25.6818},
	{-1951.3193,731.2019,44.8450},
	{-2156.2192,731.3968,68.9430},
	{-2297.8647,727.4163,49.0044},
	{-2400.8291,723.2595,34.7731},
	{-2526.6631,753.4653,34.1238},
	{-2526.8701,892.2829,63.6645},
	{-2565.9917,1004.1514,77.7043},
	{-2606.8440,908.3344,64.3967},
	{-2614.6667,695.2000,27.3754},
	{-2588.3811,384.8600,9.8450},
	{-2480.1672,433.8978,28.7664},
	{-2397.0906,413.0940,34.5246},
	{-2272.7107,266.3057,34.8702},
	{-2255.8459,-148.9042,34.7231},
	{-2000.7041,-580.0048,25.2465},
	{-1577.6943,-462.3505,5.5623},
	{-1416.3229,-399.1749,5.4051},
	{-1281.9706,-510.0969,13.7209},
	{-1182.1973,-477.2018,13.6984},
	{-1137.2798,-355.7015,13.7191},
	{-1147.9376,-256.3762,13.7333},
	{-1115.9684,376.4034,13.7194}
};

new Float:MotorRace3Boundaries[MOTORRACE3CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{-1785.0,681.0,-1685.0,781.0},
	{-2001.0,681.0,-1901.0,781.0},
	{-2206.0,681.0,-2106.0,781.0},
	{-2347.0,677.0,-2247.0,777.0},
	{-2450.0,673.0,-2350.0,773.0},
	{-2576.0,703.0,-2476.0,803.0},
	{-2576.0,842.0,-2476.0,942.0},
	{-2615.0,954.0,-2515.0,1054.0},
	{-2656.0,858.0,-2556.0,958.0},
	{-2664.0,645.0,-2564.0,745.0},
	{-2638.0,334.0,-2538.0,434.0},
	{-2530.0,383.0,-2430.0,483.0},
	{-2447.0,363.0,-2347.0,463.0},
	{-2322.0,216.0,-2222.0,316.0},
	{-2305.0,-198.0,-2205.0,-98.0},
	{-2050.0,-630.0,-1950.0,-530.0},
	{-1627.0,-512.0,-1527.0,-412.0},
	{-1466.0,-449.0,-1366.0,-349.0},
	{-1331.0,-560.0,-1231.0,-460.0},
	{-1232.0,-527.0,-1132.0,-427.0},
	{-1187.0,-405.0,-1087.0,-305.0},
	{-1197.0,-306.0,-1097.0,-206.0},
	{-1165.0,326.0,-1065.0,426.0}
};

new Float:MotorRace4Checkpoints[MOTORRACE4CPS][3] = {
	{0.0,0.0,0.0},
	{-2302.4893,-1791.2380,444.3752},
	{-2419.2986,-1755.8672,433.0529},
	{-2447.6272,-1811.2606,409.5576},
	{-2542.3799,-1669.1926,400.3143},
	{-2524.6321,-1794.2787,377.0667},
	{-2592.5869,-1626.5714,343.8248},
	{-2448.7876,-1932.1892,302.2971},
	{-2372.6304,-1938.9651,302.3545},
	{-2225.7458,-1920.2166,241.6077},
	{-2171.9561,-1830.3788,217.4994},
	{-2116.8989,-1767.1249,205.5007},
	{-2071.6079,-1655.9185,176.3718},
	{-2050.0056,-1502.8351,124.2074},
	{-1992.8612,-1648.5316,84.7926},
//	{-1998.1809,-1551.8713,84.4894},
	{-2055.0315,-1813.2078,103.3987},
	{-2113.7351,-1936.7275,100.7952},
	{-2377.2710,-2196.8228,32.8816}
};

new Float:MotorRace4Boundaries[MOTORRACE4CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{-2352.0,-1841.0,-2252.0,-1741.0},
	{-2425.0,-1780.0,-2369.0,-1705.0},
	{-2497.0,-1861.0,-2426.0,-1781.0},
	{-2592.0,-1719.0,-2492.0,-1619.0},
	{-2574.0,-1844.0,-2474.0,-1744.0},
	{-2642.0,-1676.0,-2542.0,-1576.0},
	{-2498.0,-1982.0,-2398.0,-1882.0},
	{-2422.0,-1988.0,-2322.0,-1888.0},
	{-2275.0,-1970.0,-2175.0,-1870.0},
	{-2221.0,-1880.0,-2121.0,-1780.0},
	{-2166.0,-1817.0,-2066.0,-1717.0},
	{-2121.0,-1705.0,-2021.0,-1605.0},
	{-2100.0,-1552.0,-2000.0,-1452.0},
	{-2042.0,-1698.0,-1942.0,-1598.0},
//	{-2048.0,-1601.0,-1948.0,-1501.0},
	{-2105.0,-1863.0,-2005.0,-1763.0},
	{-2163.0,-1986.0,-2063.0,-1886.0},
	{-2427.0,-2246.0,-2327.0,-2146.0}
};

new Float:MotorRace5Checkpoints[MOTORRACE5CPS][3] = {
	{0.0,0.0,0.0},
	{1767.6738,650.7266,18.3989},
	{1628.4031,-11.1004,36.2532},
	{1696.7247,-495.5616,33.2379},
	{1637.6708,-860.1511,57.3387},
	{1669.0192,-987.1364,29.7668},
	{1727.0862,-1118.2395,23.6587},
	{1714.7540,-1237.3198,15.1461},
	{1757.1572,-1443.3440,12.9288},
	{1958.6527,-1446.4707,13.0509},
	{1878.0697,-1417.1324,10.1619},
	{1849.4003,-1278.9207,12.9536},
	{1550.2441,-1160.9282,23.4687},
	{1303.7908,-1144.8615,23.2285},
	{1216.4686,-1234.6141,15.8748},
	{1241.0463,-1427.2910,14.8025},
	{1277.8376,-1537.0989,13.1237},
	{1341.0665,-1732.1107,12.9465},
	{1578.5558,-1750.5709,13.1106},
	{1922.9751,-1828.7491,4.8013},
	{2158.9929,-1852.1367,3.5500},
	{2314.9448,-1834.9307,1.9735},
	{2476.4336,-1828.5697,8.8294},
	{2588.5352,-1609.7036,3.2496},
	{2639.9331,-1468.5453,15.8068},
	{2825.0925,-1511.0077,12.3098},
	{2847.7375,-1690.0934,10.4457},
	{2795.2817,-2181.4836,14.5798}
};

new Float:MotorRace5Boundaries[MOTORRACE5CPS][4] = {
	{0.0,0.0,0.0,0.0},
	{1717.0,600.0,1817.0,700.0},
	{1578.0,-61.0,1678.0,39.0},
	{1646.0,-545.0,1746.0,-445.0},
	{1587.0,-910.0,1687.0,-810.0},
	{1619.0,-1037.0,1719.0,-937.0},
	{1677.0,-1168.0,1777.0,-1068.0},
	{1664.0,-1287.0,1764.0,-1187.0},
	{1707.0,-1493.0,1807.0,-1393.0},
	{1908.0,-1496.0,2008.0,-1396.0},
	{1828.0,-1467.0,1928.0,-1367.0},
	{1799.0,-1328.0,1899.0,-1228.0},
	{1500.0,-1210.0,1600.0,-1110.0},
	{1253.0,-1194.0,1353.0,-1094.0},
	{1166.0,-1284.0,1266.0,-1184.0},
	{1191.0,-1477.0,1291.0,-1377.0},
	{1227.0,-1587.0,1327.0,-1487.0},
	{1291.0,-1782.0,1391.0,-1682.0},
	{1528.0,-1800.0,1628.0,-1700.0},
	{1872.0,-1878.0,1972.0,-1778.0},
	{2108.0,-1902.0,2208.0,-1802.0},
	{2264.0,-1884.0,2364.0,-1784.0},
	{2426.0,-1878.0,2526.0,-1778.0},
	{2538.0,-1659.0,2638.0,-1559.0},
	{2589.0,-1518.0,2689.0,-1418.0},
	{2775.0,-1561.0,2875.0,-1461.0},
	{2797.0,-1740.0,2897.0,-1640.0},
	{2745.0,-2231.0,2845.0,-2131.0}
};


new SprintRace3CP[SPRINTRACE3CPS] = {
	CP_SPRINTRACE3_CP0,
	CP_SPRINTRACE3_CP1,
	CP_SPRINTRACE3_CP2,
	CP_SPRINTRACE3_CP3,
	CP_SPRINTRACE3_CP4,
	CP_SPRINTRACE3_CP5,
	CP_SPRINTRACE3_CP6,
	CP_SPRINTRACE3_CP7,
	CP_SPRINTRACE3_CP8,
	CP_SPRINTRACE3_CP9,
	CP_SPRINTRACE3_CP10,
	CP_SPRINTRACE3_CP11,
	CP_SPRINTRACE3_CP12,
	CP_SPRINTRACE3_CP13,
	CP_SPRINTRACE3_CP14,
	CP_SPRINTRACE3_CP15,
	CP_SPRINTRACE3_CP16,
	CP_SPRINTRACE3_CP17
};

new SprintRace4CP[SPRINTRACE4CPS] = {
	CP_SPRINTRACE4_CP0,
	CP_SPRINTRACE4_CP1,
	CP_SPRINTRACE4_CP2,
	CP_SPRINTRACE4_CP3,
	CP_SPRINTRACE4_CP4,
	CP_SPRINTRACE4_CP5,
	CP_SPRINTRACE4_CP6,
	CP_SPRINTRACE4_CP7,
	CP_SPRINTRACE4_CP8,
	CP_SPRINTRACE4_CP9,
	CP_SPRINTRACE4_CP10,
	CP_SPRINTRACE4_CP11,
	CP_SPRINTRACE4_CP12,
	CP_SPRINTRACE4_CP13,
	CP_SPRINTRACE4_CP14,
	CP_SPRINTRACE4_CP15,
	CP_SPRINTRACE4_CP16,
	CP_SPRINTRACE4_CP17,
	CP_SPRINTRACE4_CP18,
	CP_SPRINTRACE4_CP19,
	CP_SPRINTRACE4_CP20,
	CP_SPRINTRACE4_CP21,
	CP_SPRINTRACE4_CP22,
	CP_SPRINTRACE4_CP23,
	CP_SPRINTRACE4_CP24
};

new SprintRace5CP[SPRINTRACE5CPS] = {
	CP_SPRINTRACE5_CP0,
	CP_SPRINTRACE5_CP1,
	CP_SPRINTRACE5_CP2,
	CP_SPRINTRACE5_CP3,
	CP_SPRINTRACE5_CP4,
	CP_SPRINTRACE5_CP5,
	CP_SPRINTRACE5_CP6,
	CP_SPRINTRACE5_CP7,
	CP_SPRINTRACE5_CP8,
	CP_SPRINTRACE5_CP9,
	CP_SPRINTRACE5_CP10,
	CP_SPRINTRACE5_CP11,
	CP_SPRINTRACE5_CP12,
	CP_SPRINTRACE5_CP13,
	CP_SPRINTRACE5_CP14,
	CP_SPRINTRACE5_CP15,
	CP_SPRINTRACE5_CP16,
	CP_SPRINTRACE5_CP17,
	CP_SPRINTRACE5_CP18,
	CP_SPRINTRACE5_CP19
};

new SprintRace6CP[SPRINTRACE6CPS] = {
	CP_SPRINTRACE6_CP0,
	CP_SPRINTRACE6_CP1,
	CP_SPRINTRACE6_CP2,
	CP_SPRINTRACE6_CP3,
	CP_SPRINTRACE6_CP4,
	CP_SPRINTRACE6_CP5,
	CP_SPRINTRACE6_CP6,
	CP_SPRINTRACE6_CP7,
	CP_SPRINTRACE6_CP8,
	CP_SPRINTRACE6_CP9,
	CP_SPRINTRACE6_CP10,
	CP_SPRINTRACE6_CP11,
	CP_SPRINTRACE6_CP12,
	CP_SPRINTRACE6_CP13,
	CP_SPRINTRACE6_CP14,
	CP_SPRINTRACE6_CP15,
	CP_SPRINTRACE6_CP16,
	CP_SPRINTRACE6_CP17,
	CP_SPRINTRACE6_CP18,
	CP_SPRINTRACE6_CP19,
	CP_SPRINTRACE6_CP20,
	CP_SPRINTRACE6_CP21,
	CP_SPRINTRACE6_CP22
};

new SprintRace7CP[SPRINTRACE7CPS] = {
	CP_SPRINTRACE7_CP0,
	CP_SPRINTRACE7_CP1,
	CP_SPRINTRACE7_CP2,
	CP_SPRINTRACE7_CP3,
	CP_SPRINTRACE7_CP4,
	CP_SPRINTRACE7_CP5,
	CP_SPRINTRACE7_CP6,
	CP_SPRINTRACE7_CP7,
	CP_SPRINTRACE7_CP8,
	CP_SPRINTRACE7_CP9,
	CP_SPRINTRACE7_CP10,
	CP_SPRINTRACE7_CP11,
	CP_SPRINTRACE7_CP12,
	CP_SPRINTRACE7_CP13,
	CP_SPRINTRACE7_CP14,
	CP_SPRINTRACE7_CP15,
	CP_SPRINTRACE7_CP16,
	CP_SPRINTRACE7_CP17,
	CP_SPRINTRACE7_CP18,
	CP_SPRINTRACE7_CP19,
	CP_SPRINTRACE7_CP20,
	CP_SPRINTRACE7_CP21,
	CP_SPRINTRACE7_CP22,
	CP_SPRINTRACE7_CP23,
	CP_SPRINTRACE7_CP24,
	CP_SPRINTRACE7_CP25,
	CP_SPRINTRACE7_CP26,
	CP_SPRINTRACE7_CP27,
	CP_SPRINTRACE7_CP28,
	CP_SPRINTRACE7_CP29,
	CP_SPRINTRACE7_CP30,
	CP_SPRINTRACE7_CP31,
	CP_SPRINTRACE7_CP32,
	CP_SPRINTRACE7_CP33,
	CP_SPRINTRACE7_CP34,
	CP_SPRINTRACE7_CP35,
	CP_SPRINTRACE7_CP36
};

new MotorRace1CP[MOTORRACE1CPS] = {
	CP_MOTORRACE1_CP0,
	CP_MOTORRACE1_CP1,
	CP_MOTORRACE1_CP2,
	CP_MOTORRACE1_CP3,
	CP_MOTORRACE1_CP4,
	CP_MOTORRACE1_CP5,
	CP_MOTORRACE1_CP6,
	CP_MOTORRACE1_CP7,
	CP_MOTORRACE1_CP8,
	CP_MOTORRACE1_CP9,
	CP_MOTORRACE1_CP10,
	CP_MOTORRACE1_CP11,
	CP_MOTORRACE1_CP12,
	CP_MOTORRACE1_CP13,
	CP_MOTORRACE1_CP14,
	CP_MOTORRACE1_CP15,
	CP_MOTORRACE1_CP16,
	CP_MOTORRACE1_CP17,
	CP_MOTORRACE1_CP18,
	CP_MOTORRACE1_CP19,
	CP_MOTORRACE1_CP20,
	CP_MOTORRACE1_CP21,
	CP_MOTORRACE1_CP22
};

new MotorRace2CP[MOTORRACE2CPS] = {
	CP_MOTORRACE2_CP0,
	CP_MOTORRACE2_CP1,
	CP_MOTORRACE2_CP2,
	CP_MOTORRACE2_CP3,
	CP_MOTORRACE2_CP4,
	CP_MOTORRACE2_CP5,
	CP_MOTORRACE2_CP6,
	CP_MOTORRACE2_CP7,
	CP_MOTORRACE2_CP8,
	CP_MOTORRACE2_CP9,
	CP_MOTORRACE2_CP10,
	CP_MOTORRACE2_CP11,
	CP_MOTORRACE2_CP12,
	CP_MOTORRACE2_CP13,
	CP_MOTORRACE2_CP14,
	CP_MOTORRACE2_CP15,
	CP_MOTORRACE2_CP16,
	CP_MOTORRACE2_CP17,
	CP_MOTORRACE2_CP18,
	CP_MOTORRACE2_CP19,
	CP_MOTORRACE2_CP20,
	CP_MOTORRACE2_CP21,
	CP_MOTORRACE2_CP22,
	CP_MOTORRACE2_CP23,
	CP_MOTORRACE2_CP24,
	CP_MOTORRACE2_CP25,
	CP_MOTORRACE2_CP26,
	CP_MOTORRACE2_CP27,
	CP_MOTORRACE2_CP28,
	CP_MOTORRACE2_CP29,
	CP_MOTORRACE2_CP30,
	CP_MOTORRACE2_CP31
};

new MotorRace3CP[MOTORRACE3CPS] = {
	CP_MOTORRACE3_CP0,
	CP_MOTORRACE3_CP1,
	CP_MOTORRACE3_CP2,
	CP_MOTORRACE3_CP3,
	CP_MOTORRACE3_CP4,
	CP_MOTORRACE3_CP5,
	CP_MOTORRACE3_CP6,
	CP_MOTORRACE3_CP7,
	CP_MOTORRACE3_CP8,
	CP_MOTORRACE3_CP9,
	CP_MOTORRACE3_CP10,
	CP_MOTORRACE3_CP11,
	CP_MOTORRACE3_CP12,
	CP_MOTORRACE3_CP13,
	CP_MOTORRACE3_CP14,
	CP_MOTORRACE3_CP15,
	CP_MOTORRACE3_CP16,
	CP_MOTORRACE3_CP17,
	CP_MOTORRACE3_CP18,
	CP_MOTORRACE3_CP19,
	CP_MOTORRACE3_CP20,
	CP_MOTORRACE3_CP21,
	CP_MOTORRACE3_CP22,
	CP_MOTORRACE3_CP23
};

new MotorRace4CP[MOTORRACE4CPS] = {
	CP_MOTORRACE4_CP0,
	CP_MOTORRACE4_CP1,
	CP_MOTORRACE4_CP2,
	CP_MOTORRACE4_CP3,
	CP_MOTORRACE4_CP4,
	CP_MOTORRACE4_CP5,
	CP_MOTORRACE4_CP6,
	CP_MOTORRACE4_CP7,
	CP_MOTORRACE4_CP8,
	CP_MOTORRACE4_CP9,
	CP_MOTORRACE4_CP10,
	CP_MOTORRACE4_CP11,
	CP_MOTORRACE4_CP12,
	CP_MOTORRACE4_CP13,
	CP_MOTORRACE4_CP14,
	CP_MOTORRACE4_CP15,
	CP_MOTORRACE4_CP16,
	CP_MOTORRACE4_CP17
};

new MotorRace5CP[MOTORRACE5CPS] = {
	CP_MOTORRACE5_CP0,
	CP_MOTORRACE5_CP1,
	CP_MOTORRACE5_CP2,
	CP_MOTORRACE5_CP3,
	CP_MOTORRACE5_CP4,
	CP_MOTORRACE5_CP5,
	CP_MOTORRACE5_CP6,
	CP_MOTORRACE5_CP7,
	CP_MOTORRACE5_CP8,
	CP_MOTORRACE5_CP9,
	CP_MOTORRACE5_CP10,
	CP_MOTORRACE5_CP11,
	CP_MOTORRACE5_CP12,
	CP_MOTORRACE5_CP13,
	CP_MOTORRACE5_CP14,
	CP_MOTORRACE5_CP15,
	CP_MOTORRACE5_CP16,
	CP_MOTORRACE5_CP17,
	CP_MOTORRACE5_CP18,
	CP_MOTORRACE5_CP19,
	CP_MOTORRACE5_CP20,
	CP_MOTORRACE5_CP21,
	CP_MOTORRACE5_CP22,
	CP_MOTORRACE5_CP23,
	CP_MOTORRACE5_CP24,
	CP_MOTORRACE5_CP25,
	CP_MOTORRACE5_CP26,
	CP_MOTORRACE5_CP27
};


new CopColor[2] = {
	0,
	1
};

// ZONES
enum zoneinfo {
	zone_name[27],
    Float:zone_minx,
    Float:zone_miny,
    Float:zone_minz,
    Float:zone_maxx,
    Float:zone_maxy,
    Float:zone_maxz
}
new Float:zones[][zoneinfo] = {
	{ "'The Big Ear'",                -410.00,  1403.30,    -3.00,  -137.90,  1681.20,   200.00},
	{ "Aldea Malvada",               -1372.10,  2498.50,     0.00, -1277.50,  2615.30,   200.00},
	{ "Angel Pine",                  -2324.90, -2584.20,    -6.10, -1964.20, -2212.10,   200.00},
	{ "Arco del Oeste",               -901.10,  2221.80,     0.00,  -592.00,  2571.90,   200.00},
	{ "Avispa Country Club",         -2646.40,  -355.40,     0.00, -2270.00,  -222.50,   200.00},
	{ "Avispa Country Club",         -2831.80,  -430.20,    -6.10, -2646.40,  -222.50,   200.00},
	{ "Avispa Country Club",         -2361.50,  -417.10,     0.00, -2270.00,  -355.40,   200.00},
	{ "Avispa Country Club",         -2667.80,  -302.10,   -28.80, -2646.40,  -262.30,    71.10},
	{ "Avispa Country Club",         -2470.00,  -355.40,     0.00, -2270.00,  -318.40,    46.10},
	{ "Avispa Country Club",         -2550.00,  -355.40,     0.00, -2470.00,  -318.40,    39.70},
	{ "Back o Beyond",               -1166.90, -2641.10,     0.00,  -321.70, -1856.00,   200.00},
	{ "Battery Point",               -2741.00,  1268.40,    -4.50, -2533.00,  1490.40,   200.00},
	{ "Bayside",                     -2741.00,  2175.10,     0.00, -2353.10,  2722.70,   200.00},
	{ "Bayside Marina",              -2353.10,  2275.70,     0.00, -2153.10,  2475.70,   200.00},
	{ "Beacon Hill",                  -399.60, -1075.50,    -1.40,  -319.00,  -977.50,   198.50},
	{ "Blackfield",                    964.30,  1203.20,   -89.00,  1197.30,  1403.20,   110.90},
	{ "Blackfield",                    964.30,  1403.20,   -89.00,  1197.30,  1726.20,   110.90},
	{ "Blackfield Chapel",            1375.60,   596.30,   -89.00,  1558.00,   823.20,   110.90},
	{ "Blackfield Chapel",            1325.60,   596.30,   -89.00,  1375.60,   795.00,   110.90},
	{ "Blackfield Intersection",      1197.30,  1044.60,   -89.00,  1277.00,  1163.30,   110.90},
	{ "Blackfield Intersection",      1166.50,   795.00,   -89.00,  1375.60,  1044.60,   110.90},
	{ "Blackfield Intersection",      1277.00,  1044.60,   -89.00,  1315.30,  1087.60,   110.90},
	{ "Blackfield Intersection",      1375.60,   823.20,   -89.00,  1457.30,   919.40,   110.90},
	{ "Blueberry",                     104.50,  -220.10,     2.30,   349.60,   152.20,   200.00},
	{ "Blueberry",                      19.60,  -404.10,     3.80,   349.60,  -220.10,   200.00},
	{ "Blueberry Acres",              -319.60,  -220.10,     0.00,   104.50,   293.30,   200.00},
	{ "Caligula's Palace",            2087.30,  1543.20,   -89.00,  2437.30,  1703.20,   110.90},
	{ "Caligula's Palace",            2137.40,  1703.20,   -89.00,  2437.30,  1783.20,   110.90},
	{ "Calton Heights",              -2274.10,   744.10,    -6.10, -1982.30,  1358.90,   200.00},
	{ "Chinatown",                   -2274.10,   578.30,    -7.60, -2078.60,   744.10,   200.00},
	{ "City Hall",                   -2867.80,   277.40,    -9.10, -2593.40,   458.40,   200.00},
	{ "Come-A-Lot",                   2087.30,   943.20,   -89.00,  2623.10,  1203.20,   110.90},
	{ "Commerce",                     1323.90, -1842.20,   -89.00,  1701.90, -1722.20,   110.90},
	{ "Commerce",                     1323.90, -1722.20,   -89.00,  1440.90, -1577.50,   110.90},
	{ "Commerce",                     1370.80, -1577.50,   -89.00,  1463.90, -1384.90,   110.90},
	{ "Commerce",                     1463.90, -1577.50,   -89.00,  1667.90, -1430.80,   110.90},
	{ "Commerce",                     1583.50, -1722.20,   -89.00,  1758.90, -1577.50,   110.90},
	{ "Commerce",                     1667.90, -1577.50,   -89.00,  1812.60, -1430.80,   110.90},
	{ "Conference Center",            1046.10, -1804.20,   -89.00,  1323.90, -1722.20,   110.90},
	{ "Conference Center",            1073.20, -1842.20,   -89.00,  1323.90, -1804.20,   110.90},
	{ "Cranberry Station",           -2007.80,    56.30,     0.00, -1922.00,   224.70,   100.00},
	{ "Creek",                        2749.90,  1937.20,   -89.00,  2921.60,  2669.70,   110.90},
	{ "Dillimore",                     580.70,  -674.80,    -9.50,   861.00,  -404.70,   200.00},
	{ "Doherty",                     -2270.00,  -324.10,    -0.00, -1794.90,  -222.50,   200.00},
	{ "Doherty",                     -2173.00,  -222.50,    -0.00, -1794.90,   265.20,   200.00},
	{ "Downtown",                    -1982.30,   744.10,    -6.10, -1871.70,  1274.20,   200.00},
	{ "Downtown",                    -1871.70,  1176.40,    -4.50, -1620.30,  1274.20,   200.00},
	{ "Downtown",                    -1700.00,   744.20,    -6.10, -1580.00,  1176.50,   200.00},
	{ "Downtown",                    -1580.00,   744.20,    -6.10, -1499.80,  1025.90,   200.00},
	{ "Downtown",                    -2078.60,   578.30,    -7.60, -1499.80,   744.20,   200.00},
	{ "Downtown",                    -1993.20,   265.20,    -9.10, -1794.90,   578.30,   200.00},
	{ "Downtown Los Santos",          1463.90, -1430.80,   -89.00,  1724.70, -1290.80,   110.90},
	{ "Downtown Los Santos",          1724.70, -1430.80,   -89.00,  1812.60, -1250.90,   110.90},
	{ "Downtown Los Santos",          1463.90, -1290.80,   -89.00,  1724.70, -1150.80,   110.90},
	{ "Downtown Los Santos",          1370.80, -1384.90,   -89.00,  1463.90, -1170.80,   110.90},
	{ "Downtown Los Santos",          1724.70, -1250.90,   -89.00,  1812.60, -1150.80,   110.90},
	{ "Downtown Los Santos",          1370.80, -1170.80,   -89.00,  1463.90, -1130.80,   110.90},
	{ "Downtown Los Santos",          1378.30, -1130.80,   -89.00,  1463.90, -1026.30,   110.90},
	{ "Downtown Los Santos",          1391.00, -1026.30,   -89.00,  1463.90,  -926.90,   110.90},
	{ "Downtown Los Santos",          1507.50, -1385.20,   110.90,  1582.50, -1325.30,   335.90},
	{ "East Beach",                   2632.80, -1852.80,   -89.00,  2959.30, -1668.10,   110.90},
	{ "East Beach",                   2632.80, -1668.10,   -89.00,  2747.70, -1393.40,   110.90},
	{ "East Beach",                   2747.70, -1668.10,   -89.00,  2959.30, -1498.60,   110.90},
	{ "East Beach",                   2747.70, -1498.60,   -89.00,  2959.30, -1120.00,   110.90},
	{ "East Los Santos",              2421.00, -1628.50,   -89.00,  2632.80, -1454.30,   110.90},
	{ "East Los Santos",              2222.50, -1628.50,   -89.00,  2421.00, -1494.00,   110.90},
	{ "East Los Santos",              2266.20, -1494.00,   -89.00,  2381.60, -1372.00,   110.90},
	{ "East Los Santos",              2381.60, -1494.00,   -89.00,  2421.00, -1454.30,   110.90},
	{ "East Los Santos",              2281.40, -1372.00,   -89.00,  2381.60, -1135.00,   110.90},
	{ "East Los Santos",              2381.60, -1454.30,   -89.00,  2462.10, -1135.00,   110.90},
	{ "East Los Santos",              2462.10, -1454.30,   -89.00,  2581.70, -1135.00,   110.90},
	{ "Easter Basin",                -1794.90,   249.90,    -9.10, -1242.90,   578.30,   200.00},
	{ "Easter Basin",                -1794.90,   -50.00,    -0.00, -1499.80,   249.90,   200.00},
	{ "Easter Bay Airport",          -1499.80,   -50.00,    -0.00, -1242.90,   249.90,   200.00},
	{ "Easter Bay Airport",          -1794.90,  -730.10,    -3.00, -1213.90,   -50.00,   200.00},
	{ "Easter Bay Airport",          -1213.90,  -730.10,     0.00, -1132.80,   -50.00,   200.00},
	{ "Easter Bay Airport",          -1242.90,   -50.00,     0.00, -1213.90,   578.30,   200.00},
	{ "Easter Bay Airport",          -1213.90,   -50.00,    -4.50,  -947.90,   578.30,   200.00},
	{ "Easter Bay Airport",          -1315.40,  -405.30,    15.40, -1264.40,  -209.50,    25.40},
	{ "Easter Bay Airport",          -1354.30,  -287.30,    15.40, -1315.40,  -209.50,    25.40},
	{ "Easter Bay Airport",          -1490.30,  -209.50,    15.40, -1264.40,  -148.30,    25.40},
	{ "Easter Bay Chemicals",        -1132.80,  -768.00,     0.00,  -956.40,  -578.10,   200.00},
	{ "Easter Bay Chemicals",        -1132.80,  -787.30,     0.00,  -956.40,  -768.00,   200.00},
	{ "El Castillo del Diablo",       -464.50,  2217.60,     0.00,  -208.50,  2580.30,   200.00},
	{ "El Castillo del Diablo",       -208.50,  2123.00,    -7.60,   114.00,  2337.10,   200.00},
	{ "El Castillo del Diablo",       -208.50,  2337.10,     0.00,     8.40,  2487.10,   200.00},
	{ "El Corona",                    1812.60, -2179.20,   -89.00,  1970.60, -1852.80,   110.90},
	{ "El Corona",                    1692.60, -2179.20,   -89.00,  1812.60, -1842.20,   110.90},
	{ "El Quebrados",                -1645.20,  2498.50,     0.00, -1372.10,  2777.80,   200.00},
	{ "Esplanade East",              -1620.30,  1176.50,    -4.50, -1580.00,  1274.20,   200.00},
	{ "Esplanade East",              -1580.00,  1025.90,    -6.10, -1499.80,  1274.20,   200.00},
	{ "Esplanade East",              -1499.80,   578.30,   -79.60, -1339.80,  1274.20,    20.30},
	{ "Esplanade North",             -2533.00,  1358.90,    -4.50, -1996.60,  1501.20,   200.00},
	{ "Esplanade North",             -1996.60,  1358.90,    -4.50, -1524.20,  1592.50,   200.00},
	{ "Esplanade North",             -1982.30,  1274.20,    -4.50, -1524.20,  1358.90,   200.00},
	{ "Fallen Tree",                  -792.20,  -698.50,    -5.30,  -452.40,  -380.00,   200.00},
	{ "Fallow Bridge",                 434.30,   366.50,     0.00,   603.00,   555.60,   200.00},
	{ "Fern Ridge",                    508.10,  -139.20,     0.00,  1306.60,   119.50,   200.00},
	{ "Financial",                   -1871.70,   744.10,    -6.10, -1701.30,  1176.40,   300.00},
	{ "Fisher's Lagoon",              1916.90,  -233.30,  -100.00,  2131.70,    13.80,   200.00},
	{ "Flint Intersection",           -187.70, -1596.70,   -89.00,    17.00, -1276.60,   110.90},
	{ "Flint Range",                  -594.10, -1648.50,     0.00,  -187.70, -1276.60,   200.00},
	{ "Fort Carson",                  -376.20,   826.30,    -3.00,   123.70,  1220.40,   200.00},
	{ "Foster Valley",               -2270.00,  -430.20,    -0.00, -2178.60,  -324.10,   200.00},
	{ "Foster Valley",               -2178.60,  -599.80,    -0.00, -1794.90,  -324.10,   200.00},
	{ "Foster Valley",               -2178.60, -1115.50,     0.00, -1794.90,  -599.80,   200.00},
	{ "Foster Valley",               -2178.60, -1250.90,     0.00, -1794.90, -1115.50,   200.00},
	{ "Frederick Bridge",             2759.20,   296.50,     0.00,  2774.20,   594.70,   200.00},
	{ "Gant Bridge",                 -2741.40,  1659.60,    -6.10, -2616.40,  2175.10,   200.00},
	{ "Gant Bridge",                 -2741.00,  1490.40,    -6.10, -2616.40,  1659.60,   200.00},
	{ "Ganton",                       2222.50, -1852.80,   -89.00,  2632.80, -1722.30,   110.90},
	{ "Ganton",                       2222.50, -1722.30,   -89.00,  2632.80, -1628.50,   110.90},
	{ "Garcia",                      -2411.20,  -222.50,    -0.00, -2173.00,   265.20,   200.00},
	{ "Garcia",                      -2395.10,  -222.50,    -5.30, -2354.00,  -204.70,   200.00},
	{ "Garver Bridge",               -1339.80,   828.10,   -89.00, -1213.90,  1057.00,   110.90},
	{ "Garver Bridge",               -1213.90,   950.00,   -89.00, -1087.90,  1178.90,   110.90},
	{ "Garver Bridge",               -1499.80,   696.40,  -179.60, -1339.80,   925.30,    20.30},
	{ "Glen Park",                    1812.60, -1449.60,   -89.00,  1996.90, -1350.70,   110.90},
	{ "Glen Park",                    1812.60, -1100.80,   -89.00,  1994.30,  -973.30,   110.90},
	{ "Glen Park",                    1812.60, -1350.70,   -89.00,  2056.80, -1100.80,   110.90},
	{ "Green Palms",                   176.50,  1305.40,    -3.00,   338.60,  1520.70,   200.00},
	{ "Greenglass College",            964.30,  1044.60,   -89.00,  1197.30,  1203.20,   110.90},
	{ "Greenglass College",            964.30,   930.80,   -89.00,  1166.50,  1044.60,   110.90},
	{ "Hampton Barns",                 603.00,   264.30,     0.00,   761.90,   366.50,   200.00},
	{ "Hankypanky Point",             2576.90,    62.10,     0.00,  2759.20,   385.50,   200.00},
	{ "Harry Gold Parkway",           1777.30,   863.20,   -89.00,  1817.30,  2342.80,   110.90},
	{ "Hashbury",                    -2593.40,  -222.50,    -0.00, -2411.20,    54.70,   200.00},
	{ "Hilltop Farm",                  967.30,  -450.30,    -3.00,  1176.70,  -217.90,   200.00},
	{ "Hunter Quarry",                 337.20,   710.80,  -115.20,   860.50,  1031.70,   203.70},
	{ "Idlewood",                     1812.60, -1852.80,   -89.00,  1971.60, -1742.30,   110.90},
	{ "Idlewood",                     1812.60, -1742.30,   -89.00,  1951.60, -1602.30,   110.90},
	{ "Idlewood",                     1951.60, -1742.30,   -89.00,  2124.60, -1602.30,   110.90},
	{ "Idlewood",                     1812.60, -1602.30,   -89.00,  2124.60, -1449.60,   110.90},
	{ "Idlewood",                     2124.60, -1742.30,   -89.00,  2222.50, -1494.00,   110.90},
	{ "Idlewood",                     1971.60, -1852.80,   -89.00,  2222.50, -1742.30,   110.90},
	{ "Jefferson",                    1996.90, -1449.60,   -89.00,  2056.80, -1350.70,   110.90},
	{ "Jefferson",                    2124.60, -1494.00,   -89.00,  2266.20, -1449.60,   110.90},
	{ "Jefferson",                    2056.80, -1372.00,   -89.00,  2281.40, -1210.70,   110.90},
	{ "Jefferson",                    2056.80, -1210.70,   -89.00,  2185.30, -1126.30,   110.90},
	{ "Jefferson",                    2185.30, -1210.70,   -89.00,  2281.40, -1154.50,   110.90},
	{ "Jefferson",                    2056.80, -1449.60,   -89.00,  2266.20, -1372.00,   110.90},
	{ "Julius Thruway East",          2623.10,   943.20,   -89.00,  2749.90,  1055.90,   110.90},
	{ "Julius Thruway East",          2685.10,  1055.90,   -89.00,  2749.90,  2626.50,   110.90},
	{ "Julius Thruway East",          2536.40,  2442.50,   -89.00,  2685.10,  2542.50,   110.90},
	{ "Julius Thruway East",          2625.10,  2202.70,   -89.00,  2685.10,  2442.50,   110.90},
	{ "Julius Thruway North",         2498.20,  2542.50,   -89.00,  2685.10,  2626.50,   110.90},
	{ "Julius Thruway North",         2237.40,  2542.50,   -89.00,  2498.20,  2663.10,   110.90},
	{ "Julius Thruway North",         2121.40,  2508.20,   -89.00,  2237.40,  2663.10,   110.90},
	{ "Julius Thruway North",         1938.80,  2508.20,   -89.00,  2121.40,  2624.20,   110.90},
	{ "Julius Thruway North",         1534.50,  2433.20,   -89.00,  1848.40,  2583.20,   110.90},
	{ "Julius Thruway North",         1848.40,  2478.40,   -89.00,  1938.80,  2553.40,   110.90},
	{ "Julius Thruway North",         1704.50,  2342.80,   -89.00,  1848.40,  2433.20,   110.90},
	{ "Julius Thruway North",         1377.30,  2433.20,   -89.00,  1534.50,  2507.20,   110.90},
	{ "Julius Thruway South",         1457.30,   823.20,   -89.00,  2377.30,   863.20,   110.90},
	{ "Julius Thruway South",         2377.30,   788.80,   -89.00,  2537.30,   897.90,   110.90},
	{ "Julius Thruway West",          1197.30,  1163.30,   -89.00,  1236.60,  2243.20,   110.90},
	{ "Julius Thruway West",          1236.60,  2142.80,   -89.00,  1297.40,  2243.20,   110.90},
	{ "Juniper Hill",                -2533.00,   578.30,    -7.60, -2274.10,   968.30,   200.00},
	{ "Juniper Hollow",              -2533.00,   968.30,    -6.10, -2274.10,  1358.90,   200.00},
	{ "K.A.C.C. Military Fuels",      2498.20,  2626.50,   -89.00,  2749.90,  2861.50,   110.90},
	{ "Kincaid Bridge",              -1339.80,   599.20,   -89.00, -1213.90,   828.10,   110.90},
	{ "Kincaid Bridge",              -1213.90,   721.10,   -89.00, -1087.90,   950.00,   110.90},
	{ "Kincaid Bridge",              -1087.90,   855.30,   -89.00,  -961.90,   986.20,   110.90},
	{ "King's",                      -2329.30,   458.40,    -7.60, -1993.20,   578.30,   200.00},
	{ "King's",                      -2411.20,   265.20,    -9.10, -1993.20,   373.50,   200.00},
	{ "King's",                      -2253.50,   373.50,    -9.10, -1993.20,   458.40,   200.00},
	{ "LVA Freight Depot",            1457.30,   863.20,   -89.00,  1777.40,  1143.20,   110.90},
	{ "LVA Freight Depot",            1375.60,   919.40,   -89.00,  1457.30,  1203.20,   110.90},
	{ "LVA Freight Depot",            1277.00,  1087.60,   -89.00,  1375.60,  1203.20,   110.90},
	{ "LVA Freight Depot",            1315.30,  1044.60,   -89.00,  1375.60,  1087.60,   110.90},
	{ "LVA Freight Depot",            1236.60,  1163.40,   -89.00,  1277.00,  1203.20,   110.90},
	{ "Las Barrancas",                -926.10,  1398.70,    -3.00,  -719.20,  1634.60,   200.00},
	{ "Las Brujas",                   -365.10,  2123.00,    -3.00,  -208.50,  2217.60,   200.00},
	{ "Las Colinas",                  1994.30, -1100.80,   -89.00,  2056.80,  -920.80,   110.90},
	{ "Las Colinas",                  2056.80, -1126.30,   -89.00,  2126.80,  -920.80,   110.90},
	{ "Las Colinas",                  2185.30, -1154.50,   -89.00,  2281.40,  -934.40,   110.90},
	{ "Las Colinas",                  2126.80, -1126.30,   -89.00,  2185.30,  -934.40,   110.90},
	{ "Las Colinas",                  2747.70, -1120.00,   -89.00,  2959.30,  -945.00,   110.90},
	{ "Las Colinas",                  2632.70, -1135.00,   -89.00,  2747.70,  -945.00,   110.90},
	{ "Las Colinas",                  2281.40, -1135.00,   -89.00,  2632.70,  -945.00,   110.90},
	{ "Las Payasadas",                -354.30,  2580.30,     2.00,  -133.60,  2816.80,   200.00},
	{ "Las Venturas Airport",         1236.60,  1203.20,   -89.00,  1457.30,  1883.10,   110.90},
	{ "Las Venturas Airport",         1457.30,  1203.20,   -89.00,  1777.30,  1883.10,   110.90},
	{ "Las Venturas Airport",         1457.30,  1143.20,   -89.00,  1777.40,  1203.20,   110.90},
	{ "Las Venturas Airport",         1515.80,  1586.40,   -12.50,  1729.90,  1714.50,    87.50},
	{ "Last Dime Motel",              1823.00,   596.30,   -89.00,  1997.20,   823.20,   110.90},
	{ "Leafy Hollow",                -1166.90, -1856.00,     0.00,  -815.60, -1602.00,   200.00},
	{ "Lil' Probe Inn",                -90.20,  1286.80,    -3.00,   153.80,  1554.10,   200.00},
	{ "Linden Side",                  2749.90,   943.20,   -89.00,  2923.30,  1198.90,   110.90},
	{ "Linden Station",               2749.90,  1198.90,   -89.00,  2923.30,  1548.90,   110.90},
	{ "Linden Station",               2811.20,  1229.50,   -39.50,  2861.20,  1407.50,    60.40},
	{ "Little Mexico",                1701.90, -1842.20,   -89.00,  1812.60, -1722.20,   110.90},
	{ "Little Mexico",                1758.90, -1722.20,   -89.00,  1812.60, -1577.50,   110.90},
	{ "Los Flores",                   2581.70, -1454.30,   -89.00,  2632.80, -1393.40,   110.90},
	{ "Los Flores",                   2581.70, -1393.40,   -89.00,  2747.70, -1135.00,   110.90},
	{ "Los Santos International",     1249.60, -2394.30,   -89.00,  1852.00, -2179.20,   110.90},
	{ "Los Santos International",     1852.00, -2394.30,   -89.00,  2089.00, -2179.20,   110.90},
	{ "Los Santos International",     1382.70, -2730.80,   -89.00,  2201.80, -2394.30,   110.90},
	{ "Los Santos International",     1974.60, -2394.30,   -39.00,  2089.00, -2256.50,    60.90},
	{ "Los Santos International",     1400.90, -2669.20,   -39.00,  2189.80, -2597.20,    60.90},
	{ "Los Santos International",     2051.60, -2597.20,   -39.00,  2152.40, -2394.30,    60.90},
	{ "Marina",                        647.70, -1804.20,   -89.00,   851.40, -1577.50,   110.90},
	{ "Marina",                        647.70, -1577.50,   -89.00,   807.90, -1416.20,   110.90},
	{ "Marina",                        807.90, -1577.50,   -89.00,   926.90, -1416.20,   110.90},
	{ "Market",                        787.40, -1416.20,   -89.00,  1072.60, -1310.20,   110.90},
	{ "Market",                        952.60, -1310.20,   -89.00,  1072.60, -1130.80,   110.90},
	{ "Market",                       1072.60, -1416.20,   -89.00,  1370.80, -1130.80,   110.90},
	{ "Market",                        926.90, -1577.50,   -89.00,  1370.80, -1416.20,   110.90},
	{ "Market Station",                787.40, -1410.90,   -34.10,   866.00, -1310.20,    65.80},
	{ "Martin Bridge",                -222.10,   293.30,     0.00,  -122.10,   476.40,   200.00},
	{ "Missionary Hill",             -2994.40,  -811.20,     0.00, -2178.60,  -430.20,   200.00},
	{ "Montgomery",                   1119.50,   119.50,    -3.00,  1451.40,   493.30,   200.00},
	{ "Montgomery",                   1451.40,   347.40,    -6.10,  1582.40,   420.80,   200.00},
	{ "Montgomery Intersection",      1546.60,   208.10,     0.00,  1745.80,   347.40,   200.00},
	{ "Montgomery Intersection",      1582.40,   347.40,     0.00,  1664.60,   401.70,   200.00},
	{ "Mulholland",                   1414.00,  -768.00,   -89.00,  1667.60,  -452.40,   110.90},
	{ "Mulholland",                   1281.10,  -452.40,   -89.00,  1641.10,  -290.90,   110.90},
	{ "Mulholland",                   1269.10,  -768.00,   -89.00,  1414.00,  -452.40,   110.90},
	{ "Mulholland",                   1357.00,  -926.90,   -89.00,  1463.90,  -768.00,   110.90},
	{ "Mulholland",                   1318.10,  -910.10,   -89.00,  1357.00,  -768.00,   110.90},
	{ "Mulholland",                   1169.10,  -910.10,   -89.00,  1318.10,  -768.00,   110.90},
	{ "Mulholland",                    768.60,  -954.60,   -89.00,   952.60,  -860.60,   110.90},
	{ "Mulholland",                    687.80,  -860.60,   -89.00,   911.80,  -768.00,   110.90},
	{ "Mulholland",                    737.50,  -768.00,   -89.00,  1142.20,  -674.80,   110.90},
	{ "Mulholland",                   1096.40,  -910.10,   -89.00,  1169.10,  -768.00,   110.90},
	{ "Mulholland",                    952.60,  -937.10,   -89.00,  1096.40,  -860.60,   110.90},
	{ "Mulholland",                    911.80,  -860.60,   -89.00,  1096.40,  -768.00,   110.90},
	{ "Mulholland",                    861.00,  -674.80,   -89.00,  1156.50,  -600.80,   110.90},
	{ "Mulholland Intersection",      1463.90, -1150.80,   -89.00,  1812.60,  -768.00,   110.90},
	{ "North Rock",                   2285.30,  -768.00,     0.00,  2770.50,  -269.70,   200.00},
	{ "Ocean Docks",                  2373.70, -2697.00,   -89.00,  2809.20, -2330.40,   110.90},
	{ "Ocean Docks",                  2201.80, -2418.30,   -89.00,  2324.00, -2095.00,   110.90},
	{ "Ocean Docks",                  2324.00, -2302.30,   -89.00,  2703.50, -2145.10,   110.90},
	{ "Ocean Docks",                  2089.00, -2394.30,   -89.00,  2201.80, -2235.80,   110.90},
	{ "Ocean Docks",                  2201.80, -2730.80,   -89.00,  2324.00, -2418.30,   110.90},
	{ "Ocean Docks",                  2703.50, -2302.30,   -89.00,  2959.30, -2126.90,   110.90},
	{ "Ocean Docks",                  2324.00, -2145.10,   -89.00,  2703.50, -2059.20,   110.90},
	{ "Ocean Flats",                 -2994.40,   277.40,    -9.10, -2867.80,   458.40,   200.00},
	{ "Ocean Flats",                 -2994.40,  -222.50,    -0.00, -2593.40,   277.40,   200.00},
	{ "Ocean Flats",                 -2994.40,  -430.20,    -0.00, -2831.80,  -222.50,   200.00},
	{ "Octane Springs",                338.60,  1228.50,     0.00,   664.30,  1655.00,   200.00},
	{ "Old Venturas Strip",           2162.30,  2012.10,   -89.00,  2685.10,  2202.70,   110.90},
	{ "Palisades",                   -2994.40,   458.40,    -6.10, -2741.00,  1339.60,   200.00},
	{ "Palomino Creek",               2160.20,  -149.00,     0.00,  2576.90,   228.30,   200.00},
	{ "Paradiso",                    -2741.00,   793.40,    -6.10, -2533.00,  1268.40,   200.00},
	{ "Pershing Square",              1440.90, -1722.20,   -89.00,  1583.50, -1577.50,   110.90},
	{ "Pilgrim",                      2437.30,  1383.20,   -89.00,  2624.40,  1783.20,   110.90},
	{ "Pilgrim",                      2624.40,  1383.20,   -89.00,  2685.10,  1783.20,   110.90},
	{ "Pilson Intersection",          1098.30,  2243.20,   -89.00,  1377.30,  2507.20,   110.90},
	{ "Pirates in Men's Pants",       1817.30,  1469.20,   -89.00,  2027.40,  1703.20,   110.90},
	{ "Playa del Seville",            2703.50, -2126.90,   -89.00,  2959.30, -1852.80,   110.90},
	{ "Prickle Pine",                 1534.50,  2583.20,   -89.00,  1848.40,  2863.20,   110.90},
	{ "Prickle Pine",                 1117.40,  2507.20,   -89.00,  1534.50,  2723.20,   110.90},
	{ "Prickle Pine",                 1848.40,  2553.40,   -89.00,  1938.80,  2863.20,   110.90},
	{ "Prickle Pine",                 1938.80,  2624.20,   -89.00,  2121.40,  2861.50,   110.90},
	{ "Queens",                      -2533.00,   458.40,     0.00, -2329.30,   578.30,   200.00},
	{ "Queens",                      -2593.40,    54.70,     0.00, -2411.20,   458.40,   200.00},
	{ "Queens",                      -2411.20,   373.50,     0.00, -2253.50,   458.40,   200.00},
	{ "Randolph Industrial Estate",   1558.00,   596.30,   -89.00,  1823.00,   823.20,   110.90},
	{ "Redsands East",                1817.30,  2011.80,   -89.00,  2106.70,  2202.70,   110.90},
	{ "Redsands East",                1817.30,  2202.70,   -89.00,  2011.90,  2342.80,   110.90},
	{ "Redsands East",                1848.40,  2342.80,   -89.00,  2011.90,  2478.40,   110.90},
	{ "Redsands West",                1236.60,  1883.10,   -89.00,  1777.30,  2142.80,   110.90},
	{ "Redsands West",                1297.40,  2142.80,   -89.00,  1777.30,  2243.20,   110.90},
	{ "Redsands West",                1377.30,  2243.20,   -89.00,  1704.50,  2433.20,   110.90},
	{ "Redsands West",                1704.50,  2243.20,   -89.00,  1777.30,  2342.80,   110.90},
	{ "Regular Tom",                  -405.70,  1712.80,    -3.00,  -276.70,  1892.70,   200.00},
	{ "Richman",                       647.50, -1118.20,   -89.00,   787.40,  -954.60,   110.90},
	{ "Richman",                       647.50,  -954.60,   -89.00,   768.60,  -860.60,   110.90},
	{ "Richman",                       225.10, -1369.60,   -89.00,   334.50, -1292.00,   110.90},
	{ "Richman",                       225.10, -1292.00,   -89.00,   466.20, -1235.00,   110.90},
	{ "Richman",                        72.60, -1404.90,   -89.00,   225.10, -1235.00,   110.90},
	{ "Richman",                        72.60, -1235.00,   -89.00,   321.30, -1008.10,   110.90},
	{ "Richman",                       321.30, -1235.00,   -89.00,   647.50, -1044.00,   110.90},
	{ "Richman",                       321.30, -1044.00,   -89.00,   647.50,  -860.60,   110.90},
	{ "Richman",                       321.30,  -860.60,   -89.00,   687.80,  -768.00,   110.90},
	{ "Richman",                       321.30,  -768.00,   -89.00,   700.70,  -674.80,   110.90},
	{ "Robada Intersection",         -1119.00,  1178.90,   -89.00,  -862.00,  1351.40,   110.90},
	{ "Roca Escalante",               2237.40,  2202.70,   -89.00,  2536.40,  2542.50,   110.90},
	{ "Roca Escalante",               2536.40,  2202.70,   -89.00,  2625.10,  2442.50,   110.90},
	{ "Rockshore East",               2537.30,   676.50,   -89.00,  2902.30,   943.20,   110.90},
	{ "Rockshore West",               1997.20,   596.30,   -89.00,  2377.30,   823.20,   110.90},
	{ "Rockshore West",               2377.30,   596.30,   -89.00,  2537.30,   788.80,   110.90},
	{ "Rodeo",                          72.60, -1684.60,   -89.00,   225.10, -1544.10,   110.90},
	{ "Rodeo",                          72.60, -1544.10,   -89.00,   225.10, -1404.90,   110.90},
	{ "Rodeo",                         225.10, -1684.60,   -89.00,   312.80, -1501.90,   110.90},
	{ "Rodeo",                         225.10, -1501.90,   -89.00,   334.50, -1369.60,   110.90},
	{ "Rodeo",                         334.50, -1501.90,   -89.00,   422.60, -1406.00,   110.90},
	{ "Rodeo",                         312.80, -1684.60,   -89.00,   422.60, -1501.90,   110.90},
	{ "Rodeo",                         422.60, -1684.60,   -89.00,   558.00, -1570.20,   110.90},
	{ "Rodeo",                         558.00, -1684.60,   -89.00,   647.50, -1384.90,   110.90},
	{ "Rodeo",                         466.20, -1570.20,   -89.00,   558.00, -1385.00,   110.90},
	{ "Rodeo",                         422.60, -1570.20,   -89.00,   466.20, -1406.00,   110.90},
	{ "Rodeo",                         466.20, -1385.00,   -89.00,   647.50, -1235.00,   110.90},
	{ "Rodeo",                         334.50, -1406.00,   -89.00,   466.20, -1292.00,   110.90},
	{ "Royal Casino",                 2087.30,  1383.20,   -89.00,  2437.30,  1543.20,   110.90},
	{ "San Andreas Sound",            2450.30,   385.50,  -100.00,  2759.20,   562.30,   200.00},
	{ "Santa Flora",                 -2741.00,   458.40,    -7.60, -2533.00,   793.40,   200.00},
	{ "Santa Maria Beach",             342.60, -2173.20,   -89.00,   647.70, -1684.60,   110.90},
	{ "Santa Maria Beach",              72.60, -2173.20,   -89.00,   342.60, -1684.60,   110.90},
	{ "Shady Cabin",                 -1632.80, -2263.40,    -3.00, -1601.30, -2231.70,   200.00},
	{ "Shady Creeks",                -1820.60, -2643.60,    -8.00, -1226.70, -1771.60,   200.00},
	{ "Shady Creeks",                -2030.10, -2174.80,    -6.10, -1820.60, -1771.60,   200.00},
	{ "Sobell Rail Yards",            2749.90,  1548.90,   -89.00,  2923.30,  1937.20,   110.90},
	{ "Spinybed",                     2121.40,  2663.10,   -89.00,  2498.20,  2861.50,   110.90},
	{ "Starfish Casino",              2437.30,  1783.20,   -89.00,  2685.10,  2012.10,   110.90},
	{ "Starfish Casino",              2437.30,  1858.10,   -39.00,  2495.00,  1970.80,    60.90},
	{ "Starfish Casino",              2162.30,  1883.20,   -89.00,  2437.30,  2012.10,   110.90},
	{ "Temple",                       1252.30, -1130.80,   -89.00,  1378.30, -1026.30,   110.90},
	{ "Temple",                       1252.30, -1026.30,   -89.00,  1391.00,  -926.90,   110.90},
	{ "Temple",                       1252.30,  -926.90,   -89.00,  1357.00,  -910.10,   110.90},
	{ "Temple",                        952.60, -1130.80,   -89.00,  1096.40,  -937.10,   110.90},
	{ "Temple",                       1096.40, -1130.80,   -89.00,  1252.30, -1026.30,   110.90},
	{ "Temple",                       1096.40, -1026.30,   -89.00,  1252.30,  -910.10,   110.90},
	{ "The Camel's Toe",              2087.30,  1203.20,   -89.00,  2640.40,  1383.20,   110.90},
	{ "The Clown's Pocket",           2162.30,  1783.20,   -89.00,  2437.30,  1883.20,   110.90},
	{ "The Emerald Isle",             2011.90,  2202.70,   -89.00,  2237.40,  2508.20,   110.90},
	{ "The Farm",                    -1209.60, -1317.10,   114.90,  -908.10,  -787.30,   251.90},
	{ "The Four Dragons Casino",      1817.30,   863.20,   -89.00,  2027.30,  1083.20,   110.90},
	{ "The High Roller",              1817.30,  1283.20,   -89.00,  2027.30,  1469.20,   110.90},
	{ "The Mako Span",                1664.60,   401.70,     0.00,  1785.10,   567.20,   200.00},
	{ "The Panopticon",               -947.90,  -304.30,    -1.10,  -319.60,   327.00,   200.00},
	{ "The Pink Swan",                1817.30,  1083.20,   -89.00,  2027.30,  1283.20,   110.90},
	{ "The Sherman Dam",              -968.70,  1929.40,    -3.00,  -481.10,  2155.20,   200.00},
	{ "The Strip",                    2027.40,   863.20,   -89.00,  2087.30,  1703.20,   110.90},
	{ "The Strip",                    2106.70,  1863.20,   -89.00,  2162.30,  2202.70,   110.90},
	{ "The Strip",                    2027.40,  1783.20,   -89.00,  2162.30,  1863.20,   110.90},
	{ "The Strip",                    2027.40,  1703.20,   -89.00,  2137.40,  1783.20,   110.90},
	{ "The Visage",                   1817.30,  1863.20,   -89.00,  2106.70,  2011.80,   110.90},
	{ "The Visage",                   1817.30,  1703.20,   -89.00,  2027.40,  1863.20,   110.90},
	{ "Unity Station",                1692.60, -1971.80,   -20.40,  1812.60, -1932.80,    79.50},
	{ "Valle Ocultado",               -936.60,  2611.40,     2.00,  -715.90,  2847.90,   200.00},
	{ "Verdant Bluffs",                930.20, -2488.40,   -89.00,  1249.60, -2006.70,   110.90},
	{ "Verdant Bluffs",               1073.20, -2006.70,   -89.00,  1249.60, -1842.20,   110.90},
	{ "Verdant Bluffs",               1249.60, -2179.20,   -89.00,  1692.60, -1842.20,   110.90},
	{ "Verdant Meadows",                37.00,  2337.10,    -3.00,   435.90,  2677.90,   200.00},
	{ "Verona Beach",                  647.70, -2173.20,   -89.00,   930.20, -1804.20,   110.90},
	{ "Verona Beach",                  930.20, -2006.70,   -89.00,  1073.20, -1804.20,   110.90},
	{ "Verona Beach",                  851.40, -1804.20,   -89.00,  1046.10, -1577.50,   110.90},
	{ "Verona Beach",                 1161.50, -1722.20,   -89.00,  1323.90, -1577.50,   110.90},
	{ "Verona Beach",                 1046.10, -1722.20,   -89.00,  1161.50, -1577.50,   110.90},
	{ "Vinewood",                      787.40, -1310.20,   -89.00,   952.60, -1130.80,   110.90},
	{ "Vinewood",                      787.40, -1130.80,   -89.00,   952.60,  -954.60,   110.90},
	{ "Vinewood",                      647.50, -1227.20,   -89.00,   787.40, -1118.20,   110.90},
	{ "Vinewood",                      647.70, -1416.20,   -89.00,   787.40, -1227.20,   110.90},
	{ "Whitewood Estates",             883.30,  1726.20,   -89.00,  1098.30,  2507.20,   110.90},
	{ "Whitewood Estates",            1098.30,  1726.20,   -89.00,  1197.30,  2243.20,   110.90},
	{ "Willowfield",                  1970.60, -2179.20,   -89.00,  2089.00, -1852.80,   110.90},
	{ "Willowfield",                  2089.00, -2235.80,   -89.00,  2201.80, -1989.90,   110.90},
	{ "Willowfield",                  2089.00, -1989.90,   -89.00,  2324.00, -1852.80,   110.90},
	{ "Willowfield",                  2201.80, -2095.00,   -89.00,  2324.00, -1989.90,   110.90},
	{ "Willowfield",                  2541.70, -1941.40,   -89.00,  2703.50, -1852.80,   110.90},
	{ "Willowfield",                  2324.00, -2059.20,   -89.00,  2541.70, -1852.80,   110.90},
	{ "Willowfield",                  2541.70, -2059.20,   -89.00,  2703.50, -1941.40,   110.90},
	{ "Yellow Bell Station",          1377.40,  2600.40,   -21.90,  1492.40,  2687.30,    78.00},
	// Main Zones
	{ "Los Santos",                     44.60, -2892.90,  -242.90,  2997.00,  -768.00,   900.00},
	{ "Las Venturas",                  869.40,   596.30,  -242.90,  2997.00,  2993.80,   900.00},
	{ "Bone County",                  -480.50,   596.30,  -242.90,   869.40,  2993.80,   900.00},
	{ "Tierra Robada",               -2997.40,  1659.60,  -242.90,  -480.50,  2993.80,   900.00},
	{ "Tierra Robada",               -1213.90,   596.30,  -242.90,  -480.50,  1659.60,   900.00},
	{ "San Fierro",                  -2997.40, -1115.50,  -242.90, -1213.90,  1659.60,   900.00},
	{ "Red County",                  -1213.90,  -768.00,  -242.90,  2997.00,   596.30,   900.00},
	{ "Flint County",                -1213.90, -2892.90,  -242.90,    44.60,  -768.00,   900.00},
	{ "Whetstone",                   -2997.40, -2892.90,  -242.90, -1213.90, -1115.50,   900.00}
};

new player_zone[MAX_PLAYERS];

new GoldPotCheckpoints[32] = {
    CP_GOLD00,
    CP_GOLD01,
    CP_GOLD02,
    CP_GOLD03,
    CP_GOLD04,
    CP_GOLD05,
    CP_GOLD06,
    CP_GOLD07,
    CP_GOLD08,
    CP_GOLD09,
    CP_GOLD10,
    CP_GOLD11,
    CP_GOLD12,
    CP_GOLD13,
    CP_GOLD14,
    CP_GOLD15,
    CP_GOLD16,
    CP_GOLD17,
    CP_GOLD18,
    CP_GOLD19,
    CP_GOLD20,
    CP_GOLD21,
    CP_GOLD22,
    CP_GOLD23,
    CP_GOLD24,
    CP_GOLD25,
    CP_GOLD26,
    CP_GOLD27,
    CP_GOLD28,
    CP_GOLD29,
    CP_GOLD30,
    CP_GOLD31
};

new GoldPotCountup=10;
new GoldPotFiveMinute;
new GoldPotActive;
new GoldPotChoice;
new GoldPotPrice;

new HUDColor[MAX_PLAYERS];
new HUDColorNames[8][16] = {
	"default",
	"red",
	"blue",
	"green",
	"yellow",
	"purple",
	"white",
	"black"
};

new HUDColorCodes[8][7] = {
	"",
	"~r~",
	"~b~",
	"~g~",
	"~y~",
	"~p~",
	"~w~",
	"~l~"
};

main()
{
		print("\n----------------------------------------------------------------------");
		print("   Running Freeroam (by ProRaiL) + Nitro RPG (by Nitro)");
		print("----------------------------------------------------------------------\n");
		worldTime = 12;
		GameHours = 12;
}

public getCheckpointType(playerID) {
	return checkpointType[playerCheckpoint[playerID]];
}

public getTaxiCheckpointType(playerID) {
	return TaxiDriverLocs[playerCheckpoint[playerID]];
}

public getRace1CheckpointType(playerID) {
	return SprintRace3CP[playerCheckpoint[playerID]];
}

public getRace2CheckpointType(playerID) {
	return SprintRace4CP[playerCheckpoint[playerID]];
}

public getRace3CheckpointType(playerID) {
	return SprintRace5CP[playerCheckpoint[playerID]];
}

public getRace4CheckpointType(playerID) {
	return SprintRace6CP[playerCheckpoint[playerID]];
}

public getRace5CheckpointType(playerID) {
	return SprintRace7CP[playerCheckpoint[playerID]];
}

public getRace6CheckpointType(playerID) {
	return MotorRace1CP[playerCheckpoint[playerID]];
}

public getRace7CheckpointType(playerID) {
	return MotorRace2CP[playerCheckpoint[playerID]];
}

public getRace8CheckpointType(playerID) {
	return MotorRace3CP[playerCheckpoint[playerID]];
}

public getRace9CheckpointType(playerID) {
	return MotorRace4CP[playerCheckpoint[playerID]];
}

public getRace10CheckpointType(playerID) {
	return MotorRace5CP[playerCheckpoint[playerID]];
}

public isPlayerInArea(playerID, Float:data[4])
{
    if(IsPlayerConnected(playerID)) {
		if(X250[playerID] >= data[0] && X250[playerID] <= data[2] && Y250[playerID] >= data[1] && Y250[playerID] <= data[3]) {
			return 1;
		}
    }

	return 0;
}

public isPlayerInArea2(playerID, Float:data[4])
{
    if(IsPlayerConnected(playerID)) {
		if(X250[playerID] >= data[0] && X250[playerID] <= data[2] && Y250[playerID] >= data[1] && Y250[playerID] <= data[3]) {
			return 1;
		}
    }
	return 0;
}


public PayPlayerInArea(playerID, Float:x1, Float:y1, Float:x2, Float:y2, cash)
{

	if(IsPlayerConnected(playerID))
	{
		if(X250[playerID] >= x1 && X250[playerID] <= x2 && Y250[playerID] >= y1 && Y250[playerID] <= y2)
		{
			// TO-DO moneyscanner update
			format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d was in a paying-area", cash, GetPlayerMoney(playerID), playerID);
			StatGivePlayerMoney(playerID, cash, moneyreason);
			return 1;
		}
	}
	return 0;
}

public TimeUpdate() {
	new Hour, Minute, Seconds;

	tmps1 = dini_Get(FILE_SETTINGS, "timeupdate");
	if (strval(tmps1) == 0) return 0;

	worldTime++;
	if(worldTime == 24){
	    DayOTWeek++;
	    if(DayOTWeek == 7) DayOTWeek = 0;
	}
	worldTime%=24;
	Uptime++;
	if(Uptime == 60){
	    Uptime = 0;
	    Uptime_hours++;
	    if(Uptime_hours == 24){
			Uptime_days++;
			Uptime_hours = 0;
		}
	}
	SetWorldTime(worldTime);

	gettime(Hour, Minute, Seconds);
	if(Hour < 10) {
	    format(SystemTime, sizeof(SystemTime), "0%d",Hour);
	} else {
	    format(SystemTime, sizeof(SystemTime), "%d",Hour);
	}
	if(Minute < 10) {
	    format(SystemTime, sizeof(SystemTime), "%s:0%d",SystemTime,Minute);
	} else {
	    format(SystemTime, sizeof(SystemTime), "%s:%d",SystemTime,Minute);
	}
	format(strings, sizeof(strings), "System time: %s", SystemTime);
	printf(strings);

	if(worldTime == 0){
		if(DayOTWeek == 2 || DayOTWeek == 4 || DayOTWeek == 6) {
			BankTaxing();
		} else {
			BankProfit();
		}
	}

	GameHours=worldTime;
	GameMinutes=0;

	return 1;
}

public IsVehicleAtStation(playerid){
	for (new station=0;station<MAX_STATIONS;station++){
		if(X250[playerid] >= Station[station][0] && X250[playerid] <= Station[station][2] && Y250[playerid] >= Station[station][1] && Y250[playerid] <= Station[station][3] && Z250[playerid] <= Station[station][4]) {
			return station;
		}
	}
	return 999;
}

public IsPlayerInCasino(playerid)
{
	if(IsPlayerConnected(playerid)) {
        for(new i=0; i < MAX_3DLOCS; i++) {
			if(X250[playerid] >= casCoords[i][0] && X250[playerid] <= casCoords[i][3] && Y250[playerid] >= casCoords[i][1] && Y250[playerid] <= casCoords[i][4] && Z250[playerid] >= casCoords[i][2] && Z250[playerid] <= casCoords[i][5]) {
				return 1;
			}
		}
	}

	return 0;
}

public CasinoUpdate()
{
	tmps1 = dini_Get(FILE_SETTINGS, "casinos");

	for(new i=0; i<MAX_PLAYERS; i++) {
		if(IsPlayerConnected(i)) {
          for(new j=0; j < MAX_3DLOCS; j++) {
				if(X250[i] >= casCoords[j][0] && X250[i] <= casCoords[j][3] && Y250[i] >= casCoords[j][1] && Y250[i] <= casCoords[j][4] && Z250[i] >= casCoords[j][2] && Z250[i] <= casCoords[j][5]) {
     				if (strval(tmps1) == 1) {
					    if(gamblelicence[i] == 1) {
					        isincasino[i] = 1;
					        currentmoney[i] = GetPlayerMoney(i);
							return 1;
					    } else {
					        format(GameTextForPlayers1[i], 36, "~w~YOU DON'T HAVE A GAMBLE LICENCE");
					        format(GameTextForPlayers2[i], 36, "BUY ONE WITH /GAMBLE!");
							GameTextForPlayersCounter[i]=5;
				   			SetPlayerInterior(i, 0);
							SetPlayerPos(i, casSpawn[j][0], casSpawn[j][1], casSpawn[j][2]);
							return 1;
					    }
					} else {
					    GameTextForPlayer(i,"~w~CASINO'S ARE DISABLED. EARN YOUR MONEY ANOTHER WAY!",5000,3);
			   			SetPlayerInterior(i, 0);
						SetPlayerPos(i, casSpawn[j][0], casSpawn[j][1], casSpawn[j][2]);
						return 1;
					}
				} else {
					if(isincasino[i] == 1){
					    isincasino[i] = 0;
					}
				}
            }
		}
	}
 	return 1;
}

public PirateShipScoreUpdate()
{

	tmps1 = dini_Get(FILE_SETTINGS, "pirateship");
	if (strval(tmps1) == 0) return 0;

	for(new i=0; i<MAX_PLAYERS; i++)
	{
		// TO-DO moneyscanner update
		PayPlayerInArea(i, 1995.5, 1518.0, 2006.0, 1569.0, 100);
	}

	return 1;
}

public AdminHideout()
{
    new Float:adHideout1[4] = {96.5619,1798.7268,286.5391,1941.6786};
    new Float:adHideout2[4] = {184.1384,1806.9722,355.9164,2081.7712};

	tmps1 = dini_Get(FILE_SETTINGS, "adminhideout");
	if (strval(tmps1) == 0) return 0;

	for(new i=0; i<MAX_PLAYERS; i++) {
		if (IsPlayerConnected(i)) {
		    if(IsAdmin(i)) {
				PayPlayerInArea(i, 195.8144, 1873.6307, 232.2818, 1923.3119, 50);
			} else {
			    if(isPlayerInArea(i,adHideout1)) {
			        format(GameTextForPlayers1[i], 36, "~w~YOU ARE IN AN ADMIN ZONE!");
			        format(GameTextForPlayers2[i], 36, "Leave now or be ~r~KILLED");
					GameTextForPlayersCounter[i]=10;
					hideoutwarning[i]++;
					if(hideoutwarning[i] > 2) {
						SetPlayerHealth(i,0);
                        format(moneyreason, sizeof(moneyreason), "* Money reset to $0 (old: $%d), because player-id %d was in an admin-zone.", GetPlayerMoney(i), i);
						StatGivePlayerMoney(i, -GetPlayerMoney(i), moneyreason);
						hideoutwarning[i] = 0;
					}
				}
			    if(isPlayerInArea(i,adHideout2)) {
			        format(GameTextForPlayers1[i], 36, "~w~YOU ARE IN AN ADMIN ZONE!");
			        format(GameTextForPlayers2[i], 36, "Leave now or be ~r~KILLED");
					GameTextForPlayersCounter[i]=10;
					hideoutwarning[i]++;
					if(hideoutwarning[i] > 2) {
						SetPlayerHealth(i,0);
                        format(moneyreason, sizeof(moneyreason), "* Money reset to $0 (old: $%d), because player-id %d was in an admin-zone.", GetPlayerMoney(i), i);
						StatGivePlayerMoney(i, -GetPlayerMoney(i), moneyreason);
						hideoutwarning[i] = 0;
					}
				}

			}
 		}
  	}
 	return 1;
}

public checkpointUpdate()
{
	for(new i=0; i<MAX_PLAYERS; i++){
	    if(IsPlayerConnected(i)) {
	        if(TaxiDriver[i] == 1 || sprintracer[i]==1 || motorracer[i] == 1){
				if(TaxiDriver[i] == 1){
			        for(new j=1; j < MAX_TAXIPOINTS; j++) {
			            if(isPlayerInArea(i, TaxiCheckCheckpoints[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
				        }
					}
				}
				if(deathmatcher18[i] == 1){
			        for(new j=1; j < SPRINTRACE3CPS; j++) {
			            if(isPlayerInArea2(i, SprintRace3Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher19[i] == 1){
			        for(new j=1; j < SPRINTRACE4CPS; j++) {
			            if(isPlayerInArea2(i, SprintRace4Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher20[i] == 1){
			        for(new j=1; j < SPRINTRACE5CPS; j++) {
			            if(isPlayerInArea2(i, SprintRace5Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher21[i] == 1){
			        for(new j=1; j < SPRINTRACE6CPS; j++) {
			            if(isPlayerInArea2(i, SprintRace6Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher22[i] == 1){
			        for(new j=1; j < SPRINTRACE7CPS; j++) {
			            if(isPlayerInArea2(i, SprintRace7Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher24[i] == 1){
			        for(new j=1; j < MOTORRACE1CPS; j++) {
			            if(isPlayerInArea2(i, MotorRace1Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher25[i] == 1){
			        for(new j=1; j < MOTORRACE2CPS; j++) {
			            if(isPlayerInArea2(i, MotorRace2Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher26[i] == 1){
			        for(new j=1; j < MOTORRACE3CPS; j++) {
			            if(isPlayerInArea2(i, MotorRace3Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher27[i] == 1){
			        for(new j=1; j < MOTORRACE4CPS; j++) {
			            if(isPlayerInArea2(i, MotorRace4Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
				if(deathmatcher28[i] == 1){
			        for(new j=1; j < MOTORRACE5CPS; j++) {
			            if(isPlayerInArea2(i, MotorRace5Boundaries[j])) {
			                if(playerCheckpoint[i]!=j) {
								playerCheckpoint[i] = j;
							}
						}
			        }
				}
			} else {
		        for(new j=0; j < MAX_POINTS; j++) {
		            if(isPlayerInArea(i, checkCoords[j])) {
		                if(j >= 206 && j <= 237){
		                    if(GoldPotActive == 0) {
		                        GoldPotActive = 0;
		                    } else {
				                if(playerCheckpoint[i]!=j) {
									if(j == GoldPotChoice) {
					                    DisablePlayerCheckpoint(i);
										SetPlayerCheckpoint(i, checkpoints[j][0],checkpoints[j][1],checkpoints[j][2], 2);
										playerCheckpoint[i] = j;
									}
								}
							}
						} else {
			                if(playerCheckpoint[i]!=j) {
						        if(Pizza[i] == 0){
				                    DisablePlayerCheckpoint(i);
									SetPlayerCheckpoint(i, checkpoints[j][0],checkpoints[j][1],checkpoints[j][2], 2);
								}
								playerCheckpoint[i] = j;
							}
						}
		            } else {
				        if(Pizza[i] == 0){
			            	if(playerCheckpoint[i]==j) {
		    	        	    DisablePlayerCheckpoint(i);
		        	    	    playerCheckpoint[i] = 999;
		        	    	}
	         	    	}
			        }
				}
			}
		}
	}
}

public GetNumberOfProperties(playerid)
{
    new numberofproperties = 0;
    if(IsPlayerConnected(playerid)) {
        for(new i=0; i < MAX_PROPERTIES; i++) {
	        if(propertyOwner[i] < 999) {
	            if(propertyOwner[i]==playerid) {
	                    numberofproperties++;
	            }
	        }
	    }
    }

    return numberofproperties;
}

public PropertyScoreUpdate()
{
	new update, Float:CurrentValue,temp,owner;
	new owners[MAX_PROPERTIES];
	new payments[MAX_PROPERTIES];

	for(new i=0; i<MAX_PROPERTIES; i++) {
		if(ownedtime[propertyShortNames[i]] > 0) ownedtime[propertyShortNames[i]]--;
	}

	for(new i=0; i < MAX_PROPERTIES; i++)
	    owners[i]=999;

	for(new i=0; i < MAX_PROPERTIES; i++)
	{
		if(propertyOwner[i] < 999 && jailed[propertyOwner[i]] == 0) {
			for(new j=0; j < MAX_PROPERTIES; j++) {
			    if(owners[j]==propertyOwner[i]) {
					CurrentValue=propertyCurrentValue[i];
			        owner=propertyOwner[i];
			        temp=random(30)+5;
					update=floatround(floatmul(CurrentValue,floatdiv(temp,1000)));
					if(propertyCurrentValue[i]+update > 10000000){
						update=10000000 - propertyCurrentValue[i];
					}
					if(Payout[owner] == 0)propertyCurrentValue[i]+=update;
			        payments[owner]+=update;
			        j = MAX_PROPERTIES;
			    } else if (owners[j]==999) {
					CurrentValue=propertyCurrentValue[i];
			        owner=propertyOwner[i];
					owners[j]=propertyOwner[i];
			        temp=random(30)+5;
					update=floatround(floatmul(CurrentValue,floatdiv(temp,1000)));
					if(propertyCurrentValue[i]+update > 10000000){
						update=10000000 - propertyCurrentValue[i];
					}
					if(Payout[owner] == 0)propertyCurrentValue[i]+=update;
			        payments[owner]+=update;
			        j = MAX_PROPERTIES;
				}
			}
		} else {
		    if(propertyCurrentValue[i] > propertyValues[i]){
				propertyCurrentValue[i]=floatround(floatmul(propertyCurrentValue[i],0.95));
			    if(propertyCurrentValue[i] < propertyValues[i]){
			        propertyCurrentValue[i] = propertyValues[i];
				}
			}
		}
	}

	for(new i=0; i < MAX_PROPERTIES; i++) {
		if(owners[i] < 999 && IsPlayerConnected(owners[i])) {
			owner=owners[i];
			SaveProperties(owner);
			if(jailed[owner] != 1) {
				// TO-DO moneyscanner update
				if(Payout[owner] == 0){
					format(strings, sizeof(strings), "* Your properties increased $%d in value.", payments[owner]);
					SendClientMessage(owner, COLOR_MONEY_INC, strings);
				} else {
					format(strings, sizeof(strings), "* You received $%d in profit from your properties.", payments[owner]);
					format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d chose for property payout", payments[owner], GetPlayerMoney(owner), owner);
					StatGivePlayerMoney(owner, payments[owner], moneyreason);
					SendClientMessage(owner, COLOR_MONEY_INC, strings);
				}
			} else {
				SendClientMessage(owner, COLOR_SYSTEM_PW, "* Your properties does not gain anything in value neither do they pay out, since you are in jail.");
			}
		}
	}
	if(PropUpDateTimer==0){
		for(new playerid=0; playerid<MAX_PLAYERS; playerid++){
			if(IsPlayerConnected(playerid)){
			    if(logged[playerid] == 1 && spawned[playerid] == 1){
					new m, propertyID;
				    GetPlayerName(playerid, playername, sizeof(playername));
					for(new i=0; i<8; i++){
						m=i+1;
						format(strings, sizeof(strings), "value%d", m);
						if(propertyArray[playerid][i] != 0){
							propertyID = propertyArray[playerid][i];
							dini_IntSet(udb_encode(playername), strings, propertyCurrentValue[propertyID]);
						} else {
							dini_IntSet(udb_encode(playername), strings, 0);
						}
					}
				}
			}
		}
		PropUpDateTimer=1;
	} else {
		PropUpDateTimer=0;
	}
}

public KickMsg(playerid, kickerid, kickreason[])
{
	new kicktext[256];
	new kickername[256];
	new kickedplayer[MAX_PLAYER_NAME];

	if(IsPlayerConnected(playerid) && !IsAdmin(playerid)){
	    GetPlayerName(playerid, kickedplayer, sizeof(kickedplayer));
	    if(kickerid == -1) {
	        kickername = "Protection";
	        ResetPlayerMoney(playerid);
	    } else GetPlayerName(kickerid, kickername, sizeof(kickername));
		format(kicktext, sizeof(kicktext), "%s * %s (id: %d) kicked by %s. Reason: %s", SystemTime,kickedplayer, playerid, kickername, kickreason);
		printf(kicktext);
		SendClientMessageToAll(COLOR_SYSTEM_GW, kicktext);
		ResetPlayerWeapons(playerid);
		ToBeKicked[playerid]=1;
    	jailed[playerid] = 0;
	} else {
		if(IsPlayerConnected(playerid) && ForbiddenTuningBool[playerid] == 1){
		    GetPlayerName(playerid, kickedplayer, sizeof(kickedplayer));
		    if(kickerid == -1) {
		        kickername = "Protection";
		        ResetPlayerMoney(playerid);
		    } else GetPlayerName(kickerid, kickername, sizeof(kickername));
			format(kicktext, sizeof(kicktext), "%s * %s (id: %d) kicked by %s. Reason: %s", SystemTime,kickedplayer, playerid, kickername, kickreason);
			printf(kicktext);
			SendClientMessageToAll(COLOR_SYSTEM_GW, kicktext);
			ResetPlayerWeapons(playerid);
			ToBeKicked[playerid]=1;
	    	jailed[playerid] = 0;
	    	return 1;
		}
	    if(kickerid != -1) {
			format(kicktext, sizeof(kicktext), "* Player (id: %d) is not connected.", playerid);
			SendClientMessage(kickerid, COLOR_SYSTEM_PW, kicktext);
		}
	}
	return 1;
}

public BanMsg(playerid, bannerid, banreason[])
{
	new bantext[256];
	new bannername[256];
	new bannedplayer[MAX_PLAYER_NAME];
	if(IsPlayerConnected(playerid)){
		GetPlayerName(playerid, bannedplayer, sizeof(bannedplayer));
  		if(isprotected[playerid] == 1) {
  		    if(bannerid != -1) {
  		        format(bantext, sizeof(bantext), "* Player %s (id: %d) is ban protected.", bannedplayer, playerid);
				SendClientMessage(bannerid, COLOR_ADMIN_PW, bantext);
			}
			return 1;
		}
		if(bannerid == -1) {
	        bannername = "Protection";
	    } else GetPlayerName(bannerid, bannername, sizeof(bannername));
   		format(bantext, sizeof(bantext), "%s * %s (id: %d) banned by %s. Reason: %s", SystemTime,bannedplayer, playerid, bannername, banreason);
		printf(bantext);
		SendClientMessageToAll(COLOR_SYSTEM_GW, bantext);
        ResetPlayerWeapons(playerid);
        ResetPlayerMoney(playerid);
		if (dini_Exists(udb_encode(playername))) dini_IntSet(udb_encode(bannedplayer), "banned", 1);
		ToBeBanned[playerid] = 1;
    	jailed[playerid] = 0;
	} else {
	    if(bannerid != -1) {
	    	format(bantext, sizeof(bantext), "* Player (id: %d) is not connected.", playerid);
			SendClientMessage(bannerid, COLOR_SYSTEM_PW, bantext);
		}
	}
	return 1;
}

public MoneyScan() {

    tmps1 = dini_Get(FILE_SETTINGS, "moneyscan");
	if (strval(tmps1) == 0) return 0;

    for(new i=0; i<MAX_PLAYERS; i++) {
		if (IsPlayerConnected(i) && (isprotected[i] == 0 && MoneyChecking[i] == 0)) {
		    MoneyChecking[i] = 1;
		    GetPlayerName(i, playername, sizeof(playername));
			// TO-DO moneyscanner update
		    tmps1 = dini_Get(FILE_SETTINGS, "maxmoney");
			isincasino[i]=0;
	        for(new j=0; j < MAX_3DLOCS; j++) {
				if(X250[i] >= casCoords[j][0] && X250[i] <= casCoords[j][3] && Y250[i] >= casCoords[j][1] && Y250[i] <= casCoords[j][4] && Z250[i] >= casCoords[j][2] && Z250[i] <= casCoords[j][5]) {
				    if(gamblelicence[i] == 1) {
				        isincasino[i] = 1;
				    }
				}
			}
		    if(isincasino[i] == 1) {
				currentmoney[i] = GetPlayerMoney(i);
			} else {
				if(GetPlayerMoney(i) > MAX_MONEY){
					format(strings, sizeof(strings), "%s --- %s (id: %d) money cheat. Amount: $%d.", SystemTime,playername, i, GetPlayerMoney(i));
			  		printf(strings);
			  		format(strings, sizeof(strings), "* %s (id: %d) scanner detected money cheat. Amount: $%d!!!", playername, i, GetPlayerMoney(i));
					SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
					// TO-DO moneyscanner update
					format(moneyreason, sizeof(moneyreason), "* Money reset to $0 (old: $%d), because player-id %d money cheated.", currentmoney[i], i);
					StatGivePlayerMoney(i, -GetPlayerMoney(i), moneyreason);
					BanMsg(i, -1, "Money cheat!");
				}
			}
		    MoneyChecking[i] = 0;
		}
	}
	return 1;
}

public HealthScan()
{
    new Float:hp;

    tmps1 = dini_Get(FILE_SETTINGS, "healthscan");
	if (strval(tmps1) == 0) return 0;

    for(new i=0; i<MAX_PLAYERS; i++)
	{
		if (IsPlayerConnected(i) && !IsPlayerAdmin(i))
		{
		    GetPlayerName(i, playername, sizeof(playername));
		    GetPlayerHealth(i, hp);

            tmps1 = dini_Get(FILE_SETTINGS, "maxhealth");
			if (hp > floatstr(tmps1) && !god[i]) {
				format(strings, sizeof(strings), "%s --- %s (id: %d) possible health cheat.", SystemTime,playername, i);
		  		printf(strings);
		  		format(strings, sizeof(strings), "* %s (id: %d) scanner detected possible health cheat!!!", playername, i);
				SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
				KickMsg(i, -1, "Possible health cheat!");
			}
		}
	}
	return 1;
}

public JailUpdate() {

    for(new i=0; i<MAX_PLAYERS; i++)
	{
	    if(IsPlayerConnected(i) && (jailed[i] == 1)) {
 			if (jailtime[i] > 0) {
				format(strings, sizeof(strings), "You have %d minutes left in jail", jailtime[i]);
				SendClientMessage(i, COLOR_SYSTEM_PW, strings);
				jailtime[i] = jailtime[i]-1;
			} else {
			    GetPlayerName(i, playername, sizeof(playername));
				SendClientMessage(i, COLOR_SYSTEM_PM, "You are now free. Please behave from now on!");
				SetPlayerInterior(i,0);
				SetPlayerPos(i,-1619.7941,692.6453,7.1875);
				jailed[i] = 0;
				if (dini_Exists(udb_encode(playername)) && logged[i] == 1) {
				    dini_IntSet(udb_encode(playername), "jailed", 0);
					dini_IntSet(udb_encode(playername), "jailtime", 0);
				}
				for(new j = 0; j < MAX_PLAYERS; j++) {
			    	if(IsPlayerConnected(j) && IsAdmin(j)) {
				  		format(strings, sizeof(strings), "* Player %s (id: %d) has been released from jail.", playername, i);
						SendClientMessage(j, COLOR_ADMINCHAT, strings);
					}
				}
            }
	    }
	}
	return 1;
}

public VehicleDriver(vehicleid)
{
	for (new i=0;i<MAX_PLAYERS;i++) {
		if (IsPlayerConnected(i) && GetPlayerVehicleID(i) == vehicleid && GetPlayerState(i) == 2)  return i;
	}

	return -1;
}

public AutoOpenCar()
{
	for (new c=1;c<255;c++) {
		if(VehicleDriver(c) == -1){
			for (new i=0;i<MAX_PLAYERS;i++) {
				SetVehicleParamsForPlayer(c, i, 0, 0);
			}
			manuallock[c]=0;
		}
	}
	return 1;
}

public TaxiCheck()
{
	new driver;
	new drivername[MAX_PLAYER_NAME];

    for (new c=1;c<254;c++) {
        driver = VehicleDriver(c);
		if(driver != -1) {
			for (new i=0;i<MAX_PLAYERS;i++) {
			    if(IsPlayerConnected(i)) {
			        if (GetPlayerVehicleID(i) == c && GetPlayerState(i) == PLAYER_STATE_PASSENGER && payment[driver] != 0) {
	                    GetPlayerName(driver, drivername, sizeof(drivername));
					    GetPlayerName(i, playername, sizeof(playername));
					    if (GetPlayerMoney(i) > payment[driver]) {
							// TO-DO moneyscanner update
							format(moneyreason, sizeof(moneyreason), "* Money increased with $%d (old: $%d), because player-id %d earned it from driver service", payment[driver], GetPlayerMoney(driver), driver);
						    if(!StatGivePlayerMoney(driver, payment[driver], moneyreason)) return 0;
							// TO-DO moneyscanner update
							format(moneyreason, sizeof(moneyreason), "* Money decreased with $%d (old: $%d), because player-id %d used the driver service", payment[driver], GetPlayerMoney(i), i);
					    	StatGivePlayerMoney(i, 0-payment[driver], moneyreason);

					    	format(strings, sizeof(strings), "--- %s (id: %d) pays $%d to %s (id: %d) for his driver service.", playername,i,payment[driver],drivername,driver);
							printf(strings);
							format(strings, sizeof(strings), "* You paid $%d to %s (id: %d) for his driver service.", payment[driver],drivername,driver);
	                    	SendClientMessage(i, COLOR_MONEY_DEC, strings);
	                    	format(strings, sizeof(strings), "* You received $%d from %s (id: %d) for your driver service.", payment[driver],playername,i);
	                    	SendClientMessage(driver, COLOR_MONEY_INC, strings);
						}
						else {
							RemovePlayerFromVehicle(i);
						    format(strings, sizeof(strings), "--- %s (id: %d) doesn't have $%d to pay to %s (id: %d) for his driver service. Ejected from vehicle.", playername,i,payment[driver],drivername,driver);
							printf(strings);
							format(strings, sizeof(strings), "* You don't have $%d to pay to %s (id: %d) driver service.", payment[driver],drivername,driver);
	                    	SendClientMessage(i, COLOR_SYSTEM_PW, strings);
						}
					}
                }
			}
		}
 	}

	return 1;
}

public SaveAllData()
{
    for (new i=0;i<MAX_PLAYERS;i++) {
		if(IsPlayerConnected(i)) SaveFile(i);
	}

	printf("--- Global progress saved to database.");

    return 1;
}
// TO-DO moneyscanner update
public StatGivePlayerMoney(playerid, amount, moneyreasons[])
{
	new balance[MAX_PLAYERS];

	if (IsPlayerConnected(playerid) && logged[playerid] == 1) {
		if (GetPlayerMoney(playerid)+amount <= MAX_MONEY) {
		    if(MoneyChecking[playerid] == 1){
				MoneyTransferAmount[playerid]=amount;
				format(MoneyTransferReason[playerid],128, "%s", moneyreasons);
				return 1;
			}
		    MoneyChecking[playerid]=1;
			// TO-DO moneyscanner update
            GetPlayerName(playerid, playername, sizeof(playername));
			if (moneyscanner == 1){
			    if(isincasino[playerid] == 1) {
					currentmoney[playerid] = GetPlayerMoney(playerid);
//			        isincasino[playerid] = 0;
				} else {
				    balance[playerid] = GetPlayerMoney(playerid);
/*					if(balance[playerid] > MAX_MONEY) {
						format(strings, sizeof(strings), "Protection: %s (id: %d) possible money cheat. Amount: $%d.", playername, playerid, balance[playerid]-currentmoney[playerid]);
				  		printf(strings);
				  		format(strings, sizeof(strings), "* %s (id: %d) scanner detected possible money cheat. Amount: $%d!!!", playername, playerid, balance[playerid]-currentmoney[playerid]);
						SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
						KickMsg(playerid, -1, "Possible money cheat!");
						return 0;
					}*/
					if(balance[playerid] > currentmoney[playerid]) {
/*					    if(amount < 0) {
					        balance[playerid]=balance[playerid]+amount;
							if(balance[playerid] != currentmoney[playerid]) {
								format(strings, sizeof(strings), "* Balance player: %d Current money: %d", balance[playerid], currentmoney[playerid]);
								SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
								format(strings, sizeof(strings), "Protection: %s (id: %d) possible money cheat. Amount: $%d.", playername, playerid, balance[playerid]-currentmoney[playerid]);
						  		printf(strings);
						  		format(strings, sizeof(strings), "* %s (id: %d) scanner detected possible money cheat. Amount: $%d!!!", playername, playerid, balance[playerid]-currentmoney[playerid]);
								SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
								KickMsg(playerid, -1, "Possible money cheat!");
								return 0;
							}
						} else {*/
							format(strings, sizeof(strings), "* Balance player: %d Current money: %d", balance[playerid], currentmoney[playerid]);
							SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
							format(strings, sizeof(strings), "Protection: %s (id: %d) possible money cheat. Amount: $%d.", playername, playerid, balance[playerid]-currentmoney[playerid]);
					  		printf(strings);
					  		format(strings, sizeof(strings), "* %s (id: %d) scanner detected possible money cheat. Amount: $%d!!!", playername, playerid, balance[playerid]-currentmoney[playerid]);
							SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
							KickMsg(playerid, -1, "Possible money cheat!");
							return 0;
						//}
					}
				}
			}
		    currentmoney[playerid] = currentmoney[playerid]+amount;
		    GivePlayerMoney(playerid, amount);
		    printf(moneyreasons);
		    MoneyChecking[playerid]=0;
		} else {
		    format(strings,sizeof(strings),"* WARNING! You can't carry more money than $%d! You can't receive more money than $%d!",MAX_MONEY, MAX_MONEY-GetPlayerMoney(playerid));
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You CAN store your current money in bank or give away some, in order to receive more.");
		    return 0;
		}
	}
	return 1;
}

public SettingsExistsCheck()
{
	if (!dini_Exists(FILE_SETTINGS)) {
		dini_Create(FILE_SETTINGS);
		dini_IntSet(FILE_SETTINGS, "protected", 0);
		dini_IntSet(FILE_SETTINGS, "timeupdate", 1);
		dini_IntSet(FILE_SETTINGS, "pirateship", 1);
		dini_IntSet(FILE_SETTINGS, "adminhideout", 1);
		dini_IntSet(FILE_SETTINGS, "healthscan", 1);
		dini_FloatSet(FILE_SETTINGS, "maxhealth", 100.0);
		dini_IntSet(FILE_SETTINGS, "moneyscan", 1);
		dini_IntSet(FILE_SETTINGS, "maxmoney", 100000000);
		dini_Set(FILE_SETTINGS, "forbiddenweapons", "1,16,17,18,35,36,38,39,40"); //removed flamethrower
		dini_Set(FILE_SETTINGS, "lvweaponcheat", "1,16,17,18,22,23,24,25,26,27,29,30,31,32,33,34,35,36,38,39,40"); //removed flamethrower
		dini_IntSet(FILE_SETTINGS, "positionsave", 1);
		dini_IntSet(FILE_SETTINGS, "locking", 1);
		dini_IntSet(FILE_SETTINGS, "bank", 1);
		dini_IntSet(FILE_SETTINGS, "send", 1);
		dini_IntSet(FILE_SETTINGS, "bounty", 1);
		dini_IntSet(FILE_SETTINGS, "properties", 1);
		dini_IntSet(FILE_SETTINGS, "spawnweapons", 1);
		dini_IntSet(FILE_SETTINGS, "skydive", 1);
		dini_IntSet(FILE_SETTINGS, "parachute", 1);
		dini_IntSet(FILE_SETTINGS, "driverservice", 1);
		dini_IntSet(FILE_SETTINGS, "protectionchange", 1);
		dini_IntSet(FILE_SETTINGS, "manualsaving", 1);
		dini_IntSet(FILE_SETTINGS, "casinos", 1);
	}
}

public IsAdmin(playerid)
{
	if(IsPlayerConnected(playerid)) {
     	if(IsPlayerAdmin(playerid)) {
			adminlevel[playerid] = MAX_ADMIN_LEVEL;
			return 1;
		}
		if(logged[playerid] == 1 && adminlevel[playerid] > 0) {
	    	return 1;
		}
	}
	return 0;
}

public OnPlayerConnect(playerid)
{
	OwnPlayerColor[playerid] = 999;
	spawned[playerid] = 0;
    SetPlayerColor(playerid, playerColors[playerid]);
	ResetPlayerArrays(playerid);

	format(strings, sizeof(strings), "~r~Welcome to the ~n~~w~Nitro Freeroam RPG ~n~~b~version %s~n~~p~new: /payout and /nopayout", ScriptVersion);
	GameTextForPlayer(playerid, strings,10000,3);
	SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Welcome to Nitro's Freeroam RPG. In this gamemode, you can earn money or just roam around.");
	SendClientMessage(playerid, COLOR_SYSTEM_PM, "* This server is based on Freeroam v2.3 with modifications made by Nitro.");
    SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Use the command /new to view the recent changes, use /help to get started.");

	playerCheckpoint[playerid] = 999;

	GetPlayerName(playerid, playername, sizeof(playername));
	format(strings, sizeof(strings), "Player %s connected at %s", playername, SystemTime);
	printf(strings);
	
	muted[playerid] = 1;

	if (dini_Exists(udb_encode(playername))) {
        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* This nick is registered! If you are the owner, log in using the /login command.");
		SendClientMessage(playerid, COLOR_SYSTEM_PW, "* If you are not the owner, choose a different nick.");
    }
    else {
    	SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Before you can play, you need to register. You can type /register <your password>.");
        SendClientMessage(playerid, COLOR_SYSTEM_PM, "* After successful registration, identify yourself using /login <your password>.");
        SendClientMessage(playerid, COLOR_SYSTEM_PM, "* This server saves your progress(money, frags, etc).");
	}

	payment[playerid] = 0;
	query[playerid] = 255;
	admindived[playerid] = 0;
	FirstSpawn[playerid] = 1;
	SpyPlayer[playerid]=0;

	return 1;
}

public OnPlayerDisconnect(playerid)
{
	if(SpyPlayer[playerid]==1)
	{
	    SpyPlayer[playerid]=0;
	    KillTimer(SpyTimer[playerid]);
	    TogglePlayerControllable(playerid,1);
    }
    for(new l=0; l<MAX_PLAYERS; l++){
        IgnorePlayerlist[l][playerid] = 0;
    }
	if (SaveFile(playerid) == 1) {
		ResetPlayerArrays(playerid);
 	} else printf("Saving and resetting player-array failed!");
 	return 1;
}

public OnPlayerCommandText(playerid, cmdtext[])
{
	if(!IsPlayerConnected(playerid)){
	    return 0;
	}

	if((cmdtext[0] == '/') && strlen(cmdtext) > 1) {

	    new character[256];
	    new i, j;
	    new found = 0;
	    new foundchar[256];

		for(i=1; i<(strlen(cmdtext)); i++) {
			//next character
			strmid(character, cmdtext, i, i+1, 2);
		    for(j = 0; j<MAX_ALLOWED_CHARS; j++) {
		    	tmps1 = allowedchars[j];
		        if(strcmp(hash(character), hash(tmps1), false) == 0) {
		            found = 1;
		            foundchar = tmps1;
          		}
 		    }
 		    if(found == 1) {
	 			found = 0;
			} else return SendClientMessage(playerid, COLOR_SYSTEM_PW,"Illegal character(s) used. Use [0-1], [a-z], [A-Z] or [!@#$%^&*()-[];:,.<>?/]");
		}
	}

	if(commandlogenabled == 1) {

		new text[256];
		new hour, minutes, seconds;

		GetPlayerName(playerid, playername, sizeof(sendername));

		if(strlen(cmdtext) > 1) {
		    strmid(text, cmdtext, 0, strlen(cmdtext));
		    gettime(hour, minutes, seconds);
			format(strings,sizeof(strings),"(%d:%d) %s", hour, minutes, text);
		    if (!dini_Exists(FILE_COMMANDLOG)) {
				dini_Create(FILE_COMMANDLOG);
			}
			dini_Set(FILE_COMMANDLOG, playername, strings);
			format(strings, sizeof(strings), "%s * %s (id: %d) issues command: %s", SystemTime, playername, playerid, text);
			printf(strings);
		}
    }

	if(logged[playerid] == 0){
		dcmd(help,4,cmdtext);
		dcmd(register,8,cmdtext);
		dcmd(login,5,cmdtext);
		dcmd(accounthelp,11,cmdtext);
		return SendClientMessage(playerid,COLOR_MENU,"* You need to login before other commands are available. Check /accounthelp for the available commands.");
	}
	if(logged[playerid] == 1 && spawned[playerid] == 0){
		return SendClientMessage(playerid,COLOR_MENU,"* You need to spawn before other commands are available.");
	}
	if(logged[playerid] == 1 && spawned[playerid] == 1){
		dcmd(register,8,cmdtext);
		dcmd(login,5,cmdtext);
		dcmd(help,4,cmdtext);
		dcmd(accounthelp,11,cmdtext);
		dcmd(setpass,7,cmdtext);
		dcmd(carhelp,7,cmdtext);
		dcmd(tunerhelp,9,cmdtext);
		dcmd(chathelp,8,cmdtext);
		dcmd(spawnhelp,9,cmdtext);
		dcmd(moneyhelp,9,cmdtext);
		dcmd(stealhelp,9,cmdtext);
		dcmd(weaponhelp,10,cmdtext);
		dcmd(jobhelp,7,cmdtext);
		dcmd(funhelp,7,cmdtext);
		dcmd(funhelp2,8,cmdtext);
		dcmd(bountyhelp,10,cmdtext);
		dcmd(otherhelp,9,cmdtext);
		dcmd(propertyhelp,12,cmdtext);
		dcmd(deathmatch,10,cmdtext);
		dcmd(races,5,cmdtext);
		dcmd(races2,6,cmdtext);
		dcmd(races3,6,cmdtext);
		dcmd(races4,6,cmdtext);
		dcmd(races5,6,cmdtext);
		dcmd(rules,5,cmdtext);
		dcmd(rulesnl,7,cmdtext);
		dcmd(gamble,6,cmdtext);
		dcmd(lock,4,cmdtext);
		dcmd(close,5,cmdtext);
		dcmd(unlock,6,cmdtext);
		dcmd(open,4,cmdtext);
		dcmd(bank,4,cmdtext);
		dcmd(bankall,7,cmdtext);
		dcmd(withdraw,8,cmdtext);
		dcmd(transfer,8,cmdtext);
		dcmd(balance,7,cmdtext);
		dcmd(givecash,8,cmdtext);
		dcmd(hitman,6,cmdtext);
		dcmd(bounty,6,cmdtext);
		dcmd(buy,3,cmdtext);
		dcmd(creditbuy,9,cmdtext);
		dcmd(sell,4,cmdtext);
		dcmd(flog,4,cmdtext);
		dcmd(buyautolock,11,cmdtext);
		dcmd(creditautolock,14,cmdtext);
		dcmd(sellautolock,12,cmdtext);
		dcmd(buyfuelcan,10,cmdtext);
		dcmd(creditfuelcan,13,cmdtext);
		dcmd(sellfuelcan,11,cmdtext);
		dcmd(fillupcan,9,cmdtext);
		dcmd(property,8,cmdtext);
		dcmd(properties,10,cmdtext);
		dcmd(lsprop1,7,cmdtext);
		dcmd(lsprop2,7,cmdtext);
		dcmd(lsprop3,7,cmdtext);
		dcmd(blprop1,7,cmdtext);
		dcmd(blprop2,7,cmdtext);
		dcmd(sfprop1,7,cmdtext);
		dcmd(sfprop2,7,cmdtext);
		dcmd(deprop1,7,cmdtext);
		dcmd(deprop2,7,cmdtext);
		dcmd(deprop3,7,cmdtext);
		dcmd(lvprop1,7,cmdtext);
		dcmd(lvprop2,7,cmdtext);
		dcmd(lvprop3,7,cmdtext);
		dcmd(roprop1,7,cmdtext);
		dcmd(bwmelee,7,cmdtext);
		dcmd(bwpistol,8,cmdtext);
		dcmd(bwshotgun,9,cmdtext);
		dcmd(bwsmg,5,cmdtext);
		dcmd(bwrifle,7,cmdtext);
		dcmd(bwgift,6,cmdtext);
		dcmd(weaplist,8,cmdtext);
		dcmd(giftlist,8,cmdtext);
		dcmd(skydive,7,cmdtext);
		dcmd(slap,4,cmdtext);
		dcmd(para,4,cmdtext);
		dcmd(me,2,cmdtext);
		dcmd(query,5,cmdtext);
		dcmd(setpay,6,cmdtext);
		dcmd(getpay,6,cmdtext);
		dcmd(stat,4,cmdtext);
		dcmd(sv,2,cmdtext);
		dcmd(myproperties,12,cmdtext);
		dcmd(taxi,4,cmdtext);
		dcmd(credittaxi,10,cmdtext);
		dcmd(taxilocs,8,cmdtext);
		dcmd(new,3,cmdtext);
		dcmd(hackthebank,11,cmdtext);
		dcmd(hacklist,8,cmdtext);
		dcmd(hackpass,8,cmdtext);
		dcmd(springbreak,11,cmdtext);
		dcmd(springlist,10,cmdtext);
		dcmd(springpass,10,cmdtext);
		dcmd(hackthebankhelp,15,cmdtext);
		dcmd(springbreakhelp,15,cmdtext);
		dcmd(taxirates,9,cmdtext);
		dcmd(speedo,6,cmdtext);
		dcmd(clearchat,9,cmdtext);
		dcmd(callmedic,9,cmdtext);
		dcmd(eaglematch,10,cmdtext);
		dcmd(chainmatch,10,cmdtext);
		dcmd(minimatch,9,cmdtext);
		dcmd(uzimatch,8,cmdtext);
		dcmd(rusroulette,11,cmdtext);
		dcmd(dragrace1,9,cmdtext);
		dcmd(dragrace2,9,cmdtext);
		dcmd(dragrace3,9,cmdtext);
		dcmd(dragrace4,9,cmdtext);
		dcmd(dragrace5,9,cmdtext);
		dcmd(dragrace6,9,cmdtext);
		dcmd(dragrace7,9,cmdtext);
		dcmd(dragrace8,9,cmdtext);
		dcmd(dragrace9,9,cmdtext);
		dcmd(sprintrace1,11,cmdtext);
		dcmd(sprintrace2,11,cmdtext);
		dcmd(buyspeedo,9,cmdtext);
		dcmd(speedooff,9,cmdtext);
		dcmd(speedoon,8,cmdtext);
		dcmd(sellspeedo,10,cmdtext);
		dcmd(flip,4,cmdtext);
		dcmd(clue,4,cmdtext);
		dcmd(kickpassenger,13,cmdtext);
		dcmd(payandspray,11,cmdtext);
		dcmd(lowtuner,8,cmdtext);
		dcmd(streettuner,11,cmdtext);
		dcmd(backtolv,8,cmdtext);
		dcmd(cancelback,10,cmdtext);
		dcmd(canceltuner,11,cmdtext);
		dcmd(grouptalk,9,cmdtext);
		dcmd(groupinvite,11,cmdtext);
		dcmd(groupaccept,11,cmdtext);
		dcmd(groupdeny,9,cmdtext);
		dcmd(grouplist,9,cmdtext);
		dcmd(groupleave,10,cmdtext);
		dcmd(grouphelp,9,cmdtext);
		dcmd(report,6,cmdtext);
		dcmd(fillup,6,cmdtext);
		dcmd(fillstop,8,cmdtext);
		dcmd(gaslocs,7,cmdtext);
		dcmd(fuelmeteron,11,cmdtext);
		dcmd(fuelmeteroff,12,cmdtext);
		dcmd(spawnmethere,12,cmdtext);
		dcmd(spawnlocoff,11,cmdtext);
		dcmd(spawnlocs,9,cmdtext);
		dcmd(spawnview,9,cmdtext);
		dcmd(medic,5,cmdtext);
		dcmd(medicoff,8,cmdtext);
		dcmd(test,4,cmdtext);
		dcmd(tip,3,cmdtext);
		dcmd(tipnl,5,cmdtext);
		dcmd(resetdm,7,cmdtext);
		dcmd(cardive,7,cmdtext);
		dcmd(pcd,3,cmdtext);
		dcmd(viewtank,8,cmdtext);
		dcmd(patrol,6,cmdtext);
		dcmd(stoppatrol,10,cmdtext);
		dcmd(liftme,6,cmdtext);
		dcmd(pizza,5,cmdtext);
		dcmd(pizzastop,9,cmdtext);
		dcmd(pizzaboard,10,cmdtext);
		dcmd(helperhelp,10,cmdtext);
		dcmd(introduce,9,cmdtext);
		dcmd(whoneedshelp,12,cmdtext);
		dcmd(taxidriver,10,cmdtext);
		dcmd(notaxidriver,12,cmdtext);
		dcmd(taxistop,8,cmdtext);
		dcmd(taxiboard,9,cmdtext);
		dcmd(sprintrace3,11,cmdtext);
		dcmd(sprintrace4,11,cmdtext);
		dcmd(sprintrace5,11,cmdtext);
		dcmd(sprintrace6,11,cmdtext);
		dcmd(sprintrace7,11,cmdtext);
		dcmd(motorrace1,10,cmdtext);
		dcmd(motorrace2,10,cmdtext);
		dcmd(motorrace3,10,cmdtext);
		dcmd(motorrace4,10,cmdtext);
		dcmd(motorrace5,10,cmdtext);
		dcmd(cancelrace,10,cmdtext);
		dcmd(ignore,6,cmdtext);
		dcmd(ignorelist,10,cmdtext);
		dcmd(unignore,8,cmdtext);
		dcmd(visit,5,cmdtext);
		dcmd(leave,5,cmdtext);
		dcmd(hudcolor,8,cmdtext);
		dcmd(colors,6,cmdtext);
		dcmd(colors1,7,cmdtext);
		dcmd(colors2,7,cmdtext);
		dcmd(colors3,7,cmdtext);
		dcmd(colors4,7,cmdtext);
		dcmd(colors5,7,cmdtext);
		dcmd(colors6,7,cmdtext);
		dcmd(colors7,7,cmdtext);
		dcmd(colors8,7,cmdtext);
		dcmd(owncolor,8,cmdtext);
		dcmd(removeowncolor,14,cmdtext);
		dcmd(payout,6,cmdtext);
		dcmd(nopayout,8,cmdtext);

		if(IsAdmin(playerid)){
			dcmd(adminhelp,9,cmdtext);
			dcmd(adminhelp2,10,cmdtext);
			dcmd(shortcuts,9,cmdtext);
			dcmd(sk,2,cmdtext);
			dcmd(giveweaplist,12,cmdtext);
			dcmd(goto,4,cmdtext);
			dcmd(get,3,cmdtext);
			dcmd(jaillist,8,cmdtext);
			dcmd(announce,8,cmdtext);
			dcmd(ann,3,cmdtext);
			dcmd(countdown,9,cmdtext);
			dcmd(cd,2,cmdtext);
			dcmd(stopcountdown,13,cmdtext);
			dcmd(stopcd,6,cmdtext);
			dcmd(admindive,9,cmdtext);
			dcmd(getprop,7,cmdtext);
			dcmd(giveloc,7,cmdtext);
			dcmd(jail,4,cmdtext);
			dcmd(j,1,cmdtext);
			dcmd(unjail,6,cmdtext);
			dcmd(unj,3,cmdtext);
			dcmd(mute,4,cmdtext);
			dcmd(unmute,6,cmdtext);
			dcmd(heal,4,cmdtext);
			dcmd(h,1,cmdtext);
			dcmd(god,3,cmdtext);
			dcmd(murder,6,cmdtext);
			dcmd(freeze,6,cmdtext);
			dcmd(f,1,cmdtext);
			dcmd(unfreeze,8,cmdtext);
			dcmd(unf,3,cmdtext);
			dcmd(givemoney,9,cmdtext);
			dcmd(gm,2,cmdtext);
			dcmd(giveweapon,10,cmdtext);
			dcmd(gw,2,cmdtext);
			dcmd(disarm,6,cmdtext);
			dcmd(saveloc,7,cmdtext);
			dcmd(tp,2,cmdtext);
			dcmd(cartp,5,cmdtext);
			dcmd(cargoto,7,cmdtext);
			dcmd(tpto,4,cmdtext);
			dcmd(deluser,7,cmdtext);
			dcmd(setmoney,8,cmdtext);
			dcmd(setbank,7,cmdtext);
			dcmd(removeadmin,11,cmdtext);
			dcmd(radmin,6,cmdtext);
			dcmd(setadmin,8,cmdtext);
			dcmd(sadmin,6,cmdtext);
			dcmd(setlevel,8,cmdtext);
			dcmd(getlevel,8,cmdtext);
			dcmd(admins,6,cmdtext);
			dcmd(ad,2,cmdtext);
			dcmd(hideout,7,cmdtext);
			dcmd(hid,3,cmdtext);
			dcmd(stadium,7,cmdtext);
			dcmd(sex,3,cmdtext);
			dcmd(villa,5,cmdtext);
			dcmd(kick,4,cmdtext);
			dcmd(k,1,cmdtext);
			dcmd(ban,3,cmdtext);
			dcmd(b,1,cmdtext);
			dcmd(pmspyon,7,cmdtext);
			dcmd(pmspyoff,8,cmdtext);
			dcmd(pmspyoffall,8,cmdtext);
			dcmd(chatoff,7,cmdtext);
			dcmd(chaton,6,cmdtext);
			dcmd(setdawn,7,cmdtext);
			dcmd(setnoon,7,cmdtext);
			dcmd(setdusk,7,cmdtext);
			dcmd(setnight,8,cmdtext);
			dcmd(settime,7,cmdtext);
			dcmd(protect,7,cmdtext);
			dcmd(p,1,cmdtext);
			dcmd(setprot,7,cmdtext);
			dcmd(svall,5,cmdtext);
			dcmd(getuser,7,cmdtext);
			dcmd(whois,5,cmdtext);
			dcmd(20,2,cmdtext);
			dcmd(30,2,cmdtext);
			dcmd(40,2,cmdtext);
			dcmd(invisible,9,cmdtext);
			dcmd(invis,5,cmdtext);
			dcmd(noadinvis,9,cmdtext);
			dcmd(visible,7,cmdtext);
			dcmd(vis,3,cmdtext);
			dcmd(iamnoadmin,10,cmdtext);
			dcmd(noad,4,cmdtext);
			dcmd(iamadmin,8,cmdtext);
			dcmd(iad,3,cmdtext);
			dcmd(givespeedo,10,cmdtext);
			dcmd(spyon,5,cmdtext);
			dcmd(spyoff,6,cmdtext);
			dcmd(spystaton,9,cmdtext);
			dcmd(spystatoff,10,cmdtext);
			dcmd(ssn,3,cmdtext);
			dcmd(ssf,3,cmdtext);
			dcmd(adminspawn,10,cmdtext);
			dcmd(regular,7,cmdtext);
			dcmd(notregular,10,cmdtext);
			dcmd(veid,4,cmdtext);
			dcmd(givetime,8,cmdtext);
			dcmd(locs,4,cmdtext);
			dcmd(resetalldrags,13,cmdtext);
			dcmd(resetdrag1,10,cmdtext);
			dcmd(resetdrag2,10,cmdtext);
			dcmd(resetdrag3,10,cmdtext);
			dcmd(resetdrag4,10,cmdtext);
			dcmd(resetdrag5,10,cmdtext);
			dcmd(resetdrag6,10,cmdtext);
			dcmd(resetdrag7,10,cmdtext);
			dcmd(resetdrag8,10,cmdtext);
			dcmd(resetdrag9,10,cmdtext);
			dcmd(resetsprint1,12,cmdtext);
			dcmd(resetsprint2,12,cmdtext);
			dcmd(setbounty,9,cmdtext);
			dcmd(uptime,6,cmdtext);
			dcmd(url,3,cmdtext);
			dcmd(helper,6,cmdtext);
			dcmd(nohelper,8,cmdtext);
			dcmd(unban,5,cmdtext);
			dcmd(disablepatrol,13,cmdtext);
			dcmd(enablepatrol,12,cmdtext);
			dcmd(lvplaytime,10,cmdtext);
		}
	}
	if(ErrorCounter < 33) {
		ErrorCounter++;
	} else {
		ErrorCounter = 0;
	}
	return SendClientMessage(playerid,COLOR_MENU,ErrorMessages[ErrorCounter]);
}

dcmd_help(playerid,params[])  {
	new question[256];
	new correct;
	new index = 0;
	question = strtok(params, index);

	if(!strlen(question)) {
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"__________________________________________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* Use the following commands to see help topics on the specific topics and the related coomands:");
		SendClientMessage(playerid, COLOR_MENU,"* /accounthelp for the commands related with your account *** /funhelp for the fun related commands");
		SendClientMessage(playerid, COLOR_MENU,"* /chathelp for commands related to chatting to people *** /spawnhelp for commands related to spawning");
		SendClientMessage(playerid, COLOR_MENU,"* /carhelp for the commands related with vehicles  *** /tunerhelp for car tuning related commands");
		SendClientMessage(playerid, COLOR_MENU,"* /stealhelp for the commands related to stealing money of other players *** /jobhelp for the jobs available");
		SendClientMessage(playerid, COLOR_MENU,"* /weaponhelp for the commands related to buying spawn weapons *** /moneyhelp for commands related to your money");
		SendClientMessage(playerid, COLOR_MENU,"* /propertyhelp for the commands related to buying and selling properties");
		SendClientMessage(playerid, COLOR_MENU,"* /bountyhelp for the commands related to setting a bounty on someone");
		SendClientMessage(playerid, COLOR_MENU,"* /otherhelp  for all the commands not related to any other group");
		SendClientMessage(playerid, COLOR_MENU,"__________________________________________________________________________________________________________________");
		return 1;
	}

	if(strcmp(question, "register", true) == 0 ||strcmp(question, "/register", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can register yourself (your nickname) on this");
		SendClientMessage(playerid, COLOR_MENU,"* server, so that all your personal data (money, owned properties, weapons)");
		SendClientMessage(playerid, COLOR_MENU,"* are stored. You need also register yourself in order to login and");
		SendClientMessage(playerid, COLOR_MENU,"* interact fully with the other players.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /register [yourpassword]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "setpass", true) == 0 ||strcmp(question, "/setpass", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can change your password you use when logging in.");
		SendClientMessage(playerid, COLOR_MENU,"* This is handy when you have the idea that other people might have gained");
		SendClientMessage(playerid, COLOR_MENU,"* control over your account.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /setpass [yournewpassword]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "login", true) == 0 ||strcmp(question, "/login", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This is necessary to play fully on this server. In order to login you");
		SendClientMessage(playerid, COLOR_MENU,"* need to register your account (see  /help register  for more information");
		SendClientMessage(playerid, COLOR_MENU,"* on this).");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /login [yourpassword]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "sv", true) == 0 ||strcmp(question, "/sv", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can save your progress manually.");
		SendClientMessage(playerid, COLOR_MENU,"* Your money, banked money, weapons and owned properties are saved.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /sv");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "stat", true) == 0 ||strcmp(question, "/stat", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command allows you to see your personal statistics.");
		SendClientMessage(playerid, COLOR_MENU,"* It will display the number of people you killed, the times people killed");
		SendClientMessage(playerid, COLOR_MENU,"* you, the times you committed suicide and your total wealth.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /stat");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "pm", true) == 0 ||strcmp(question, "/pm", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can talk in private with someone, other people will");
		SendClientMessage(playerid, COLOR_MENU,"* not see your message. You can view the playerid of the person you want to");
		SendClientMessage(playerid, COLOR_MENU,"* address with your TAB key, it is in front of the users name.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /pm [playerid] [message]");
		SendClientMessage(playerid, COLOR_MENU,"* Note: Your message IS logged and can be reviewed later by the admins.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "me", true) == 0 ||strcmp(question, "/me", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this function you can display an action in the public chat area.");
		SendClientMessage(playerid, COLOR_MENU,"* For example /me is taking a cup of tea.  with result in");
		SendClientMessage(playerid, COLOR_MENU,"* * <yourname> is taking a cup of tea , displayed in blue.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /me [message]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "slap", true) == 0 ||strcmp(question, "/slap", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this function you can slap someone with a big trout.");
		SendClientMessage(playerid, COLOR_MENU,"* If an admin slaps you, you will loose some health.");
		SendClientMessage(playerid, COLOR_MENU,"* For example: /slap 0   (your name: Bert, name playerid 0: Ernie");
		SendClientMessage(playerid, COLOR_MENU,"* Will result in: * Bert slaps Ernie around a bit with a large trout");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /slap [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "query", true) == 0 ||strcmp(question, "/query", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This function is an advanced private message function. Unlike the /pm");
		SendClientMessage(playerid, COLOR_MENU,"* function you do not need to include the players id every time you want");
		SendClientMessage(playerid, COLOR_MENU,"* to tell him something.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage starting query session: /query [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"* Usage using query to talk: ! [your message]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "grouptalk", true) == 0 ||strcmp(question, "/grouptalk", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"________________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This function is an advanced query function. Unlike the /query");
		SendClientMessage(playerid, COLOR_MENU,"* function you can talk with more than one person at a time, without letting");
		SendClientMessage(playerid, COLOR_MENU,"* the other players see what you are saying.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage starting a grouptalk session: /grouptalk");
		SendClientMessage(playerid, COLOR_MENU,"* Usaging grouptalk to talk: # [your message]");
		SendClientMessage(playerid, COLOR_MENU,"* More grouptalk related help in /grouphelp - only viewable when you are in a grouptalk.");
		SendClientMessage(playerid, COLOR_MENU,"________________________________________________________________________________________");
	}
	if(strcmp(question, "report", true) == 0 ||strcmp(question, "/report", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"________________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this function you can notify any connected admin about a situation that");
		SendClientMessage(playerid, COLOR_MENU,"* requires their attention.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /report [message]");
		SendClientMessage(playerid, COLOR_FIREBRICK,"* DO NOT MISUSE THIS FUNCTION. Abusive use can lead to your own ban.");
		SendClientMessage(playerid, COLOR_MENU,"________________________________________________________________________________________");
	}
	if(strcmp(question, "clearchat", true) == 0 ||strcmp(question, "/clearchat", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will clear your chatlist on the left.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /clearchat");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "lock", true) == 0 ||strcmp(question, "/lock", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can lock the doors of your car to prevent you");
		SendClientMessage(playerid, COLOR_MENU,"* becoming a target of carjacking. When leaving the car, it will be locked");
		SendClientMessage(playerid, COLOR_MENU,"* and only accessible for you for 30 seconds, after that it will unlock");
		SendClientMessage(playerid, COLOR_MENU,"* automatically.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /lock");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "unlock", true) == 0 ||strcmp(question, "/unlock", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can open the doors of your car, so everyone can get");
		SendClientMessage(playerid, COLOR_MENU,"* in and possibly take over your car.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /unlock");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bank", true) == 0 ||strcmp(question, "/bank", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can place an amount of the cash you are carrying on");
		SendClientMessage(playerid, COLOR_MENU,"* your bank account, so you will not loose it when you get killed or");
		SendClientMessage(playerid, COLOR_MENU,"* gets disconnected.print If you type an exact amount, like 500000,");
		SendClientMessage(playerid, COLOR_MENU,"* the server will tries to bank 500000 and lower your cash with 500000.");
		SendClientMessage(playerid, COLOR_MENU,"* If you would be carrying only 400000, the server will bank 400000.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bank [amount]");
		SendClientMessage(playerid, COLOR_MENU,"* Note: this command can only be performed standing");
		SendClientMessage(playerid, COLOR_MENU,"*       in the checkpoint of a bank.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "withdraw", true) == 0 ||strcmp(question, "/withdraw", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can take money out of your account and put it in");
		SendClientMessage(playerid, COLOR_MENU,"* your wallet. After the withdraw command you need to specify the amount");
		SendClientMessage(playerid, COLOR_MENU,"* you want to withdraw. If you specify a value greater than the banked");
		SendClientMessage(playerid, COLOR_MENU,"* cash, you will withdraw all your banked cash, otherwise you will withdraw");
		SendClientMessage(playerid, COLOR_MENU,"* only that specified amount.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /withdraw [amount]");
		SendClientMessage(playerid, COLOR_MENU,"* Note: this command can only be performed standing");
		SendClientMessage(playerid, COLOR_MENU,"*       in the checkpoint of a bank.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "transfer", true) == 0 ||strcmp(question, "/transfer", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can take money out of your account and put it in");
		SendClientMessage(playerid, COLOR_MENU,"* your wallet. After the transfer command you need to specify the amount");
		SendClientMessage(playerid, COLOR_MENU,"* you want to transfered. You do not have to visit a bankoffice to execute this action.");
		SendClientMessage(playerid, COLOR_MENU,"* However, due to this freedom, the transfer option comes with a cost:");
		SendClientMessage(playerid, COLOR_MENU,"* you will have to pay the same amount to be able to make the transfer.");
		SendClientMessage(playerid, COLOR_MENU,"* So transfering $ 100.000 will actually costs you $200.000");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /transfer [amount]");
		SendClientMessage(playerid, COLOR_MENU,"* Note: this command can only be performed once every 5 minutes");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "balance", true) == 0 ||strcmp(question, "/balance", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you will be prompted by the amount of cash you have on");
		SendClientMessage(playerid, COLOR_MENU,"* your bankaccount.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /balance");
		SendClientMessage(playerid, COLOR_MENU,"* Note: this command can only be performed standing");
		SendClientMessage(playerid, COLOR_MENU,"*       in the checkpoint of a bank.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "setpay", true) == 0 ||strcmp(question, "/setpay", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can set the amount of cash a passenger will have to");
		SendClientMessage(playerid, COLOR_MENU,"* pay every minute when he or she is traveling along with you.");
		SendClientMessage(playerid, COLOR_MENU,"* You can set a value between 0 and 500.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /setpay [amount]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "getpay", true) == 0 ||strcmp(question, "/getpay", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can view how much money you have earned of that");
		SendClientMessage(playerid, COLOR_MENU,"* specified person. Without setting a value with");
		SendClientMessage(playerid, COLOR_MENU,"* /setpay this command is of no use.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /getpay [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "hackthebank", true) == 0 ||strcmp(question, "/hackthebank", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can hack someones bank account and transfer at most");
		SendClientMessage(playerid, COLOR_MENU,"* $1,000,000 to your own bank account. You need to be in a safe house in");
		SendClientMessage(playerid, COLOR_MENU,"* Los Santos. Review /hackthebankhelp for additional help on this topic.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /hackthebank [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "springbreak", true) == 0 ||strcmp(question, "/springbreak", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can hack into the police computer and release");
		SendClientMessage(playerid, COLOR_MENU,"* everyone in the prison. You need to be at a specific police computer.");
		SendClientMessage(playerid, COLOR_MENU,"* Review /springbreakhelp for additional help on this topic.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /springbreak");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "hackthebankhelp", true) == 0 ||strcmp(question, "/hackthebankhelp", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display additional information about hacking into the");
		SendClientMessage(playerid, COLOR_MENU,"* San Andreas bank with the /hackthebank command.");
		SendClientMessage(playerid, COLOR_MENU,"* See also /help hackthebank");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "springbreakhelp", true) == 0 ||strcmp(question, "/springbreakhelp", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display additional information about hacking into the");
		SendClientMessage(playerid, COLOR_MENU,"* police computer with the /springbreak command.");
		SendClientMessage(playerid, COLOR_MENU,"* See also /help springbreak");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bw", true) == 0 ||strcmp(question, "/bw", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* You can buy spawn weapons at ammunations in Las Venturas.");
		SendClientMessage(playerid, COLOR_MENU,"* For melee weapons use /bwmelee  - see /help bwmelee for additional help");
		SendClientMessage(playerid, COLOR_MENU,"* For pistols use /bwpistol       - see /help bwpistol for additional help");
		SendClientMessage(playerid, COLOR_MENU,"* For shotguns use /bwshotgun     - see /help bwshotgun for additional help");
		SendClientMessage(playerid, COLOR_MENU,"* For machine guns use /bwsmg     - see /help bwsmg for additional help");
		SendClientMessage(playerid, COLOR_MENU,"* For assault rifles use /bwrifle - see /help bwrifle for additional help");
		SendClientMessage(playerid, COLOR_MENU,"* For gifts use /bwgift           - see /help bwgift for additional help");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bwmelee", true) == 0 ||strcmp(question, "/bwmelee", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a spawn melee weapon at ammunations in LV.");
		SendClientMessage(playerid, COLOR_MENU,"* Possible melee weapons:");
		SendClientMessage(playerid, COLOR_MENU,"* Knife (id 0)     -  Bat (id 1)");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bwmelee [weaponid] ");
		SendClientMessage(playerid, COLOR_MENU,"* For example buying the bat: /bwmelee 1");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bwpistol", true) == 0 ||strcmp(question, "/bwpistol", true) == 0){
	correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a spawn pistol at ammunations in LV.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to specify the number of bullets you want with your pistol.");
		SendClientMessage(playerid, COLOR_MENU,"* Possible pistols:");
		SendClientMessage(playerid, COLOR_MENU,"* 9 mm (id 0)      -  Silenced 9 mm (id 1)     - Desert eagle (id 2)");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bwpistol [weaponid] [bullets]");
		SendClientMessage(playerid, COLOR_MENU,"* For example buying the 9 mm with 400 bullets: /bwpistol 0 400");
		SendClientMessage(playerid, COLOR_MENU,"* Note: Buying id 0 or 1 will override the default desert eagle.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bwshotgun", true) == 0 ||strcmp(question, "/bwshotgun", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a spawn shotgun at ammunations in LV.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to specify the number of bullets you want with your shotgun.");
		SendClientMessage(playerid, COLOR_MENU,"* Possible shotguns:");
		SendClientMessage(playerid, COLOR_MENU,"* shotgun (id 0)      -  sawn-off (id 1)      - combat shotgun (id 2)");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bwshotgun [weaponid] [bullets]");
		SendClientMessage(playerid, COLOR_MENU,"* For example buying the combat shotgun with 300 bullets: /bwshotgun 2 300");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bwsmg", true) == 0 ||strcmp(question, "/bwsmg", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a spawn smg at ammunations in LV.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to specify the number of bullets you want with your smg.");
		SendClientMessage(playerid, COLOR_MENU,"* Possible small machine guns:");
		SendClientMessage(playerid, COLOR_MENU,"* Tec9 (id 0)         - Micro Uzi (id 1)       - MP5 (id 2)");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bwsmg [weaponid] [bullets]");
		SendClientMessage(playerid, COLOR_MENU,"* For example buying the Tec9 with 1000 bullets: /bwsmg 0 1000");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bwrifle", true) == 0 ||strcmp(question, "/bwrifle", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a spawn assault rifle at ammunations in LV.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to specify the number of bullets you want with your rifle.");
		SendClientMessage(playerid, COLOR_MENU,"* Possible assault rifles:");
		SendClientMessage(playerid, COLOR_MENU,"* AK47 (id 0)         - M5 (id 1)");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bwrifle [weaponid] [bullets]");
		SendClientMessage(playerid, COLOR_MENU,"* For example buying the M5 with 2500 bullets: /bwrifle 1 2500");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bwgift", true) == 0 ||strcmp(question, "/bwgift", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a spawn gift at the giftshop in LV.");
		SendClientMessage(playerid, COLOR_MENU,"* Possible gifts:");
		SendClientMessage(playerid, COLOR_MENU,"* Purple dildo (id 0)  -  White dildo (id 1)  -  Flowers (id 2)");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bwgift [giftid]");
		SendClientMessage(playerid, COLOR_MENU,"* For example buying flowers: /bwgift 2");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "weaplist", true) == 0 ||strcmp(question, "/weaplist", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display you the spawn weapons you can buy at the");
		SendClientMessage(playerid, COLOR_MENU,"* ammunation shops in Las Venturas. Spawn weapons are weapons that are");
		SendClientMessage(playerid, COLOR_MENU,"* stored with your account, so you will have them everytime you reconnect");
		SendClientMessage(playerid, COLOR_MENU,"* or die. Remember to login first before spawning to get the weapons after");
		SendClientMessage(playerid, COLOR_MENU,"* first spawn.");
		SendClientMessage(playerid, COLOR_MENU,"* The prices on the list are the price per bullet.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /weaplist");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "giftlist", true) == 0 ||strcmp(question, "/giftlist", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display you the spawn gifts you can buy at the");
		SendClientMessage(playerid, COLOR_MENU,"* gift shop in Las Venturas. Spawn gifts are gifts that are");
		SendClientMessage(playerid, COLOR_MENU,"* stored with your account, so you will have them everytime you reconnect");
		SendClientMessage(playerid, COLOR_MENU,"* or die. Remember to login first before spawning to get the gifts after");
		SendClientMessage(playerid, COLOR_MENU,"* first spawn.");
		SendClientMessage(playerid, COLOR_MENU,"* The prices on the list are the price per item.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /giftlist");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "buy", true) == 0 ||strcmp(question, "/buy", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a property. To do this you need to be");
		SendClientMessage(playerid, COLOR_MENU,"* standing in the checkpoint related to that property.");
		SendClientMessage(playerid, COLOR_MENU,"* You do need to have enough cash present in order to buy the property.");
		SendClientMessage(playerid, COLOR_MENU,"* If you do not have enough, check /help creditbuy .");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /buy");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "creditbuy", true) == 0 ||strcmp(question, "/creditbuy", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy a property. To do this you need to be");
		SendClientMessage(playerid, COLOR_MENU,"* standing in the checkpoint related to that property.");
		SendClientMessage(playerid, COLOR_MENU,"* When using your creditcard the propertyvalue will be taken out of your");
		SendClientMessage(playerid, COLOR_MENU,"* bank account.");
		SendClientMessage(playerid, COLOR_MENU,"* For this service the creditcard company charges you with a 30% commission");
		SendClientMessage(playerid, COLOR_MENU,"* over the total amount you have to pay.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /buy");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "sell", true) == 0 ||strcmp(question, "/sell", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can sell a property. To do this you need to be");
		SendClientMessage(playerid, COLOR_MENU,"* standing in the checkpoint related to that property.");
		SendClientMessage(playerid, COLOR_MENU,"* Selling a property will give you 100% of the current property value.");
		SendClientMessage(playerid, COLOR_MENU,"* If you cannot find the checkpoint or you do not want to travel there,");
		SendClientMessage(playerid, COLOR_MENU,"* take a look at /help flog");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /sell");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "flog", true) == 0 ||strcmp(question, "/flog", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can sell a property without having to stand in the");
		SendClientMessage(playerid, COLOR_MENU,"* checkpoint related to that property. This will save you a lot of time.");
		SendClientMessage(playerid, COLOR_MENU,"* Flogging a property will give you 50% of the current property value.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to fill in the property id, which you can look up with");
		SendClientMessage(playerid, COLOR_MENU,"* /myproperties . See also    /help myproperties.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /flog [propertyid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "properties", true) == 0 ||strcmp(question, "/properties", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display another menu with new commands, to view all the");
		SendClientMessage(playerid, COLOR_MENU,"* properties you can buy and in which area you can find them.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /properties");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "myproperties", true) == 0 ||strcmp(question, "/myproperties", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you will be prompted with a list of all the properties");
		SendClientMessage(playerid, COLOR_MENU,"* you are currently owner of.");
		SendClientMessage(playerid, COLOR_MENU,"* If you own a property, the profit of that property is also displayed.");
		SendClientMessage(playerid, COLOR_MENU,"* If you do now own a property, the server will tell you also.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /myproperties");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "property", true) == 0 ||strcmp(question, "/property", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display the current owner of a property.");
		SendClientMessage(playerid, COLOR_MENU,"* For this command you need to know the property id of the property you are");
		SendClientMessage(playerid, COLOR_MENU,"* interested in. For this, see /properties .");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /property [propertyid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "hitman", true) == 0 ||strcmp(question, "/hitman", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can set a bounty on someones head, which the killer");
		SendClientMessage(playerid, COLOR_MENU,"* of that person will be rewarded with. This bounty will be taken out of");
		SendClientMessage(playerid, COLOR_MENU,"* your wallet, so you need to carry sufficient cash to set the bounty.");
		SendClientMessage(playerid, COLOR_MENU,"* The limit is $9,000,000 .");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /hitman [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "bounty", true) == 0 ||strcmp(question, "/bounty", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can view a bounty on someones head, which the");
		SendClientMessage(playerid, COLOR_MENU,"* killer of that person will be rewarded with.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /bounty [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "playerid", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* Playerid is the number identifying a player.");
		SendClientMessage(playerid, COLOR_MENU,"* Use TAB to bring up the connected user-list. The playerid is the number");
		SendClientMessage(playerid, COLOR_MENU,"* in front of the playername.");
		SendClientMessage(playerid, COLOR_MENU,"* Your name is on top, which makes it easy to look up your playerid.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "rules", true) == 0 ||strcmp(question, "/rules", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will display the current rules for this server.");
		SendClientMessage(playerid, COLOR_MENU,"* You are also prompted with them when you enter the server, but if you");
		SendClientMessage(playerid, COLOR_MENU,"* want to reread them later on, you can use this command.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /rules");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "rulesnl", true) == 0 ||strcmp(question, "/rulesnl", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* Dit commando laat de huidige regels voor de server zien.");
		SendClientMessage(playerid, COLOR_MENU,"* Omdat er veel Nederlandse spelers zijn, zijn de regels ook in het");
		SendClientMessage(playerid, COLOR_MENU,"* Nederlands vertaald.");
		SendClientMessage(playerid, COLOR_MENU,"* Gebruik: /rulesnl");
		SendClientMessage(playerid, COLOR_MENU,"* ");
		SendClientMessage(playerid, COLOR_MENU,"* This will display the current rules for this server in Dutch.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "gamble", true) == 0 ||strcmp(question, "/gamble", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy yourself a gambling license, which you need");
		SendClientMessage(playerid, COLOR_MENU,"* to be able to gamble in casinos. If you do not have a license, you will");
		SendClientMessage(playerid, COLOR_MENU,"* be kicked out of the casino.");
		SendClientMessage(playerid, COLOR_MENU,"* The gambling license costs $1,000,000 , you need to carry that amount of");
		SendClientMessage(playerid, COLOR_MENU,"* cash in order to buy the license");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /gamble");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "kill", true) == 0 ||strcmp(question, "/kill", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This will cause yourself to die instantly.");
		SendClientMessage(playerid, COLOR_MENU,"* Please do not use this in combat, it is viewed as very cowardy and");
		SendClientMessage(playerid, COLOR_MENU,"* will give you a bad name on the server.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /kill");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "skydive", true) == 0 ||strcmp(question, "/skydive", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command enables you to start a skydive at your current location.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to supply the height you want to start on.");
		SendClientMessage(playerid, COLOR_MENU,"* When the skydive starts, you will get a parachute so you can land");
		SendClientMessage(playerid, COLOR_MENU,"* safely. Do not start a skydive when you are in the air: this will cause");
		SendClientMessage(playerid, COLOR_MENU,"* an instant suicide.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /skydive [100-1000]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "para", true) == 0 ||strcmp(question, "/para", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can buy yourself a parachute.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /para");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "taxi", true) == 0 ||strcmp(question, "/taxi", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can call a taxi to transport you to a fixed locaton.");
		SendClientMessage(playerid, COLOR_MENU,"* These locations can be viewed with /taxilocs .");
		SendClientMessage(playerid, COLOR_MENU,"* There is a waiting period of 10 seconds before the taxi arrives.");
		SendClientMessage(playerid, COLOR_MENU,"* You will be charged for using the taxi, and you need to be standing");
		SendClientMessage(playerid, COLOR_MENU,"* outside when you request the taxi and when the taxi arrives.");
		SendClientMessage(playerid, COLOR_MENU,"* The taxi rates can be viewed with /taxirates .");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /taxi [taxilocationid]");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "credittaxi", true) == 0 ||strcmp(question, "/credittaxi", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can call a taxi to transport you to a fixed locaton.");
		SendClientMessage(playerid, COLOR_MENU,"* These locations can be viewed with /taxilocs .");
		SendClientMessage(playerid, COLOR_MENU,"* There is a waiting period of 10 seconds before the taxi arrives.");
		SendClientMessage(playerid, COLOR_MENU,"* You will be charged for using the taxi, and you need to be standing");
		SendClientMessage(playerid, COLOR_MENU,"* outside when you request the taxi and when the taxi arrives.");
		SendClientMessage(playerid, COLOR_MENU,"* The charges will be payed with your creditcard - so you will have to pay 30% more.");
		SendClientMessage(playerid, COLOR_MENU,"* The taxi rates can be viewed with /taxirates .");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /credittaxi [taxilocationid]");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "taxilocs", true) == 0 ||strcmp(question, "/taxilocs", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This command will show a list of the locations you can visit with the");
		SendClientMessage(playerid, COLOR_MENU,"* taxi using /taxi [taxilocationid] or /credittaxi [taxilocationid].");
		SendClientMessage(playerid, COLOR_MENU,"* The taxilocationid is displayed in front of the description:");
		SendClientMessage(playerid, COLOR_MENU,"* The pirate ship has for example taxilocationid 5.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /taxilocs");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "taxirates", true) == 0 ||strcmp(question, "/taxirates", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you review the rate for the taxi rides.");
		SendClientMessage(playerid, COLOR_MENU,"* The prices depend on your personal wealth.");
		SendClientMessage(playerid, COLOR_MENU,"* New players with a wealth of $500 or less can ride the taxi");
		SendClientMessage(playerid, COLOR_MENU,"* three times without having to pay for it.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /taxirates");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "new", true) == 0 ||strcmp(question, "/new", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* This will display a short list of the new features and changes on this");
		SendClientMessage(playerid, COLOR_MENU,"* server.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /new");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "callmedic", true) == 0 ||strcmp(question, "/callmedic", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can call for medical support.");
		SendClientMessage(playerid, COLOR_MENU,"* If the medic is online, he or she will be notified, and you will also be");
		SendClientMessage(playerid, COLOR_MENU,"* informed of this. If the medic is not online, it will also be prompted.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /callmedic");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "medic", true) == 0 ||strcmp(question, "/medic", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can start the medical mission.");
		SendClientMessage(playerid, COLOR_MENU,"* In order to start it, you need to own at least one of the medical centers,");
		SendClientMessage(playerid, COLOR_MENU,"* and you need to be driving in an ambulance.");
		SendClientMessage(playerid, COLOR_MENU,"* The goal of the mission is to heal other players. The reward for this is");
		SendClientMessage(playerid, COLOR_MENU,"* 2500 * the number of patients you have have healed so far.");
		SendClientMessage(playerid, COLOR_MENU,"* The max reward is 100 000, after reaching this value the reward is reset to");
		SendClientMessage(playerid, COLOR_MENU,"* 2500.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /medic");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "medicoff", true) == 0 ||strcmp(question, "/medicoff", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can end a medical mission.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /medicoff");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "pcd", true) == 0 ||strcmp(question, "/pcd", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can start a countdown.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /pcd [countdownseconds]");
		SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________");
	}
	if(strcmp(question, "speedo", true) == 0 ||strcmp(question, "/speedo", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can view the commands to buy and sell");
		SendClientMessage(playerid, COLOR_MENU,"* a speedometer.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /speedo");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "flip", true) == 0 ||strcmp(question, "/flip", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can set your car back on its wheels.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /flip");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "kickpassenger", true) == 0 ||strcmp(question, "/kickpassenger", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can kick a passenger out of your vehicle.");
		SendClientMessage(playerid, COLOR_MENU,"* The passenger is identified by his playerid.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /kickpassenger [playerid]");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "payandspray", true) == 0 ||strcmp(question, "/payandspray", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can request a pay and spray of your vehicle.");
		SendClientMessage(playerid, COLOR_MENU,"* You will be teleported to a pay and spray, and will return at your current position.");
		SendClientMessage(playerid, COLOR_MENU,"* This service costs $250.000");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /payandspray");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "fillup", true) == 0 ||strcmp(question, "/fillup", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can fill up the petroltank of your vehicle.");
		SendClientMessage(playerid, COLOR_MENU,"* You need to be at a designated gasstation for your type of vehicle.");
		SendClientMessage(playerid, COLOR_MENU,"* There are 4 different types of vehicles defined:");
		SendClientMessage(playerid, COLOR_MENU,"* Bicycles which can't refuel, Land motor vehicles (bikes, cars, trucks)");
		SendClientMessage(playerid, COLOR_MENU,"* Boats and Airplanes");
		SendClientMessage(playerid, COLOR_MENU,"* Type /gaslocs for an overview of the possible refuel locations.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /fillup");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "fillstop", true) == 0 ||strcmp(question, "/fillstop", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can stop the filling up the petroltank of your vehicle.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /fillstop");
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
	}
	if(strcmp(question, "viewtank", true) == 0 ||strcmp(question, "/viewtank", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can review the content of your petrol tank.");
		SendClientMessage(playerid, COLOR_MENU,"* It will show how many liters of petrol it is holding, and what percentage of the");
		SendClientMessage(playerid, COLOR_MENU,"* of the tank is filled.");
		SendClientMessage(playerid, COLOR_MENU,"* Note: that percentage is also displayed on the right bottom corner.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /viewtank");
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
	}
	if(strcmp(question, "patrol", true) == 0 ||strcmp(question, "/patrol", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this function you can start patrolling the roads of San Andreas, looking for");
		SendClientMessage(playerid, COLOR_MENU,"* speeders. Every player over 130 kph will be fined as long as you get close enoug to");
		SendClientMessage(playerid, COLOR_MENU,"* record the speed of the player.");
		SendClientMessage(playerid, COLOR_MENU,"* In order to start this mission, you need to own the Highway Patrol Headquaters and");
		SendClientMessage(playerid, COLOR_MENU,"* you need to be driving in the police ranger parked outside of the office.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /patrol");
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
	}
	if(strcmp(question, "stoppatrol", true) == 0 ||strcmp(question, "/stoppatrol", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can stop your highway patrol mission, which you have started");
		SendClientMessage(playerid, COLOR_MENU,"* with /patrol. When you have stopped the mission, speeds will no longer be checked.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /stoppatrol");
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
	}
	if(strcmp(question, "owncolor", true) == 0 ||strcmp(question, "/owncolor", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can choose your own player color, and save it in your");
		SendClientMessage(playerid, COLOR_MENU,"* profile so you play with the same color everytime you play on this server.");
		SendClientMessage(playerid, COLOR_MENU, "* The charge to set your own color is $500.000, but it is only charged once.");
		SendClientMessage(playerid, COLOR_MENU, "* The next time you chose a color, it will be free of charge.");
		SendClientMessage(playerid, COLOR_MENU, "* See /colors for the available player colors.");
		SendClientMessage(playerid, COLOR_MENU, "* USAGE: /owncolor [colornumber].");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	if(strcmp(question, "payout", true) == 0 ||strcmp(question, "/payout", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can change the way the server handles the profit your properties");
		SendClientMessage(playerid, COLOR_MENU,"* generate from increase in value to pay out each minute.");
		SendClientMessage(playerid, COLOR_MENU,"* Issuing the command /payout results in an income every minute, as big as the common");
		SendClientMessage(playerid, COLOR_MENU,"* increase in value of your properties, but the properties will not increase in value themselves.");
		SendClientMessage(playerid, COLOR_MENU,"* To change it back to the situation where the properties increase in value, use the command /nopayout.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /payout");
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
	}
	if(strcmp(question, "nopayout", true) == 0 ||strcmp(question, "/nopayout", true) == 0){
		correct=1;
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With this command you can change the way the server handles the profit your properties");
		SendClientMessage(playerid, COLOR_MENU,"* generate from pay out each minute to increase in value.");
		SendClientMessage(playerid, COLOR_MENU,"* Issuing the command /nopayout results in a steady increase in value of your properties");
		SendClientMessage(playerid, COLOR_MENU,"* but the properties will not generate a pay out anymore.");
		SendClientMessage(playerid, COLOR_MENU,"* To change it back to the situation where the properties pay out, use the command /payout.");
		SendClientMessage(playerid, COLOR_MENU,"* Usage: /nopayout");
		SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________________________");
	}
	if(correct == 0){
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* You have either entered a wrong command or the command you entered does");
		SendClientMessage(playerid, COLOR_MENU,"* not have a help section here yet.");
		SendClientMessage(playerid, COLOR_MENU,"* With this function you can get more information about commands at your");
		SendClientMessage(playerid, COLOR_MENU,"* disposal. If you type /help without anything behind it, you will see");
		SendClientMessage(playerid, COLOR_MENU,"* the list of the commands you can use.");
		SendClientMessage(playerid, COLOR_MENU,"* Type /help [command] to see the help for those commands.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	return 1;
}

dcmd_accounthelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Account related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /register   - to create an account on this server, so you can save your progress");
	SendClientMessage(playerid, COLOR_MENU,"* /login      - to identify yourself as owner of that account with your password");
	SendClientMessage(playerid, COLOR_MENU,"* /setpass    - to change the password you use for logging in");
	SendClientMessage(playerid, COLOR_MENU,"* /sv         - to manually save your progress");
	SendClientMessage(playerid, COLOR_MENU,"* /stat       - shows a list of account related stats (kills, deaths, suicide, cash)");
	SendClientMessage(playerid, COLOR_MENU,"* /owncolor   - to choose a color to play on the server *** /removeowncolor - to set your color to the default value");
	SendClientMessage(playerid, COLOR_MENU,"* /colors /colors1-colors8 - list of available colors to choose from when using /owncolor");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_carhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Car related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /lock - to lock the doors of your car, preventing people from entering *** /unlock - to open the doors of your car");
	SendClientMessage(playerid, COLOR_MENU,"* /speedo - this command displays the commands you can use related to the speedometer");
	SendClientMessage(playerid, COLOR_MENU,"* /flip - to set the car back on its wheels when crashing");
	SendClientMessage(playerid, COLOR_MENU,"* /kickpassenger - to kick a passenger out of your car");
	SendClientMessage(playerid, COLOR_MENU,"* /payandspray - teleport to a payandspray and get back where you were for $250.000");
	SendClientMessage(playerid, COLOR_MENU,"* /fillup  - to fill up the petrol tank *** /fillstop - to stop a fill up");
	SendClientMessage(playerid, COLOR_MENU,"* /viewtank - to view the contents of the petrol tank *** /gaslocs - to review the gasstations you can use");
	SendClientMessage(playerid, COLOR_MENU,"* /fuelmeteron - to turn the fuel meter on (default) *** /fuelmeteroff - to tun the fuel meter off (doesn't work with speedo)");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ____________________________________________________________________________");
	return 1;
}

dcmd_tunerhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Car tuning related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /lowtuner      - to teleport with a car to the lowrider tuner in Los Santos for $250.000");
	SendClientMessage(playerid, COLOR_MENU,"* /streettuner   - to teleport with a car to the street racers tuner in San Fierro for $250.000");
	SendClientMessage(playerid, COLOR_MENU,"* /backtolv      - to teleport with your car to Las Venturas after you have tuned the car. For free.");
	SendClientMessage(playerid, COLOR_MENU,"* /canceltuner   - to cancel the tuning request.");
	SendClientMessage(playerid, COLOR_MENU,"* /cancelback    - to cancel the return trip to Las Venturas.");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_chathelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Chat related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /pm - to send a personal message to another player *** /ignorelist - to see the list of players you ignore the pm from");
	SendClientMessage(playerid, COLOR_MENU,"* /me         - to send an action message to all the players like /me likes beer ");
	SendClientMessage(playerid, COLOR_MENU,"* /query      - start an advanced personal message channel with another player, saves you from typing /pm id");
	SendClientMessage(playerid, COLOR_MENU,"* /grouptalk  - to start an advanced query session where you can talk in private with more than 1 player");
	SendClientMessage(playerid, COLOR_MENU,"* /grouphelp  - to view all the commands related to the grouptalk function");
	SendClientMessage(playerid, COLOR_MENU,"* /clearchat  - to clear the chatwindow");
	SendClientMessage(playerid, COLOR_MENU,"* /report     - to send a report to online admins");
	SendClientMessage(playerid, COLOR_MENU,"* /ignore - to ignore all the pm's from a particular player *** /unignore - to stop ignoring the players pm's");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_spawnhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Spawnlocation buying related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /spawnmethere - to buy a spawn location where you will spawn from now on.");
	SendClientMessage(playerid, COLOR_MENU,"* /spawnlocs    - the locations for sale");
	SendClientMessage(playerid, COLOR_MENU,"* /spawnview    - reviewing the spawn locations before buying one");
	SendClientMessage(playerid, COLOR_MENU,"* /spawnlocoff  - to disable spawning at your purchased location. To enable it again, you need to buy it again.");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_moneyhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Money related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /bank         - to put cash you are carrying on your bank account");
	SendClientMessage(playerid, COLOR_MENU,"* /bankall      - to put all the cash you are carrying on your bank account");
	SendClientMessage(playerid, COLOR_MENU,"* /withdraw - to withdraw cash from your bank account *** /transfer - to withdraw at max $500.000 without visiting a bankoffice");
	SendClientMessage(playerid, COLOR_MENU,"* /balance      - to view how much money you have on your bank account");
	SendClientMessage(playerid, COLOR_MENU,"* /givecash     - to give cash to another player");
	SendClientMessage(playerid, COLOR_MENU,"* /setpay       - to set an amount people have to pay when you are driving them around");
	SendClientMessage(playerid, COLOR_MENU,"* /getpay       - to review how much money other players have payed you for driving them around");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_stealhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Money stealing related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /hackthebank     - to hack into the SA Bank and steal at most $1.000.000 from another players bank account");
	SendClientMessage(playerid, COLOR_MENU,"* /hackthebankhelp - this displays more information about hacking into the SA Bank and the commands you");
	SendClientMessage(playerid, COLOR_MENU,"*                    need to use when doing this");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_weaponhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Weapons related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /bwmelee     - to buy a spawn melee weapon");
	SendClientMessage(playerid, COLOR_MENU,"* /bwpistol    - to buy a spawn pistol");
	SendClientMessage(playerid, COLOR_MENU,"* /bwshotgun   - to buy a spawn shotgun");
	SendClientMessage(playerid, COLOR_MENU,"* /bwsmg       - to buy a spawn small machine gun");
	SendClientMessage(playerid, COLOR_MENU,"* /bwrifle     - to buy a spawn rifle");
	SendClientMessage(playerid, COLOR_MENU,"* /weaplist    - to review the spawn weapons and the prices per bullet");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_propertyhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"________________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Property related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /buy          - to buy a property, paying cash");
	SendClientMessage(playerid, COLOR_MENU,"* /creditbuy    - to buy a property, using your creditcard, taking the amount out of your bank account");
	SendClientMessage(playerid, COLOR_MENU,"* /sell         - to sell a property, getting 25% of the retail value back");
	SendClientMessage(playerid, COLOR_MENU,"* /flog         - to sell a property without having to go to it to sell it. You get 10% of the retail value back");
	SendClientMessage(playerid, COLOR_MENU,"* /properties   - this displays a list of commands to view the properties you can buy");
	SendClientMessage(playerid, COLOR_MENU,"* /myproperties - this displays the properties you own");
	SendClientMessage(playerid, COLOR_MENU,"* /property     - this displays the current owner of a property");
	SendClientMessage(playerid, COLOR_MENU,"* /payout &/nopayout - to change the way the profit of a property is handled. /payout gives cash, /nopayout increases value");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] _______________________________________________________________");
	return 1;
}

dcmd_jobhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Job related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /pizza           - with this command you take up a job as pizza delivery boy/girl");
	SendClientMessage(playerid, COLOR_MENU,"* /pizzastop       - to resign your pizza delivery job");
	SendClientMessage(playerid, COLOR_MENU,"* /pizzaboard      - to view the five best pizza delivery boys/girls");
	SendClientMessage(playerid, COLOR_MENU,"* /taxidriver      - with this command you take up a job as taxidriver");
	SendClientMessage(playerid, COLOR_MENU,"* /taxistop        - to resign your taxidiver job");
	SendClientMessage(playerid, COLOR_MENU,"* /taxiboard       - to view the five best taxidrivers");
	SendClientMessage(playerid, COLOR_MENU,"* More jobs will be available soon");
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	return 1;
}

dcmd_funhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Fun related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /deathmatch      - this displays a list of available minigames");
	SendClientMessage(playerid, COLOR_MENU,"* /gamble          - to buy a gambling license for $1.000.000 - you need this to be able to gamble in casino's");
	SendClientMessage(playerid, COLOR_MENU,"* /skydive         - to start a skydive over your current location");
	SendClientMessage(playerid, COLOR_MENU,"* /cardive         - to start a cardive with your car");
	SendClientMessage(playerid, COLOR_MENU,"* /para            - to purchase a parachute");
	SendClientMessage(playerid, COLOR_MENU,"* /callmedic       - to give a message to the medical officer that you want to be healed");
	SendClientMessage(playerid, COLOR_MENU,"* /medic - to start a medical mission *** /medicoff - to stop a medical mission (as medical officer)");
	SendClientMessage(playerid, COLOR_MENU,"* /patrol - to start patrolling the highways *** /stoppatrol - to stop patrolling the highways");
	SendClientMessage(playerid, COLOR_MENU,"____See funhelp2 for more commands___ For extended help: type /help [commmand] ________________________________");
	return 1;
}

dcmd_funhelp2(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Fun related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /races           - this displays a list of available races");
	SendClientMessage(playerid, COLOR_MENU,"* /visit           - to visit the san fierro prison to see the inmates");
	SendClientMessage(playerid, COLOR_MENU,"* /leave           - to leave the san fierro prison when you have visited it with /visit");
	SendClientMessage(playerid, COLOR_MENU,"* /pcd             - to start a countdown");
	SendClientMessage(playerid, COLOR_MENU,"* /springbreak     - to hack into Dillmore PD computer, to set everyone free who is currently in jail");
	SendClientMessage(playerid, COLOR_MENU,"* /springbreakhelp - more information about hacking into the police computer, and all the related commands.");
	SendClientMessage(playerid, COLOR_MENU,"____See funhelp for more commands___ For extended help: type /help [commmand] _________________________________");
	return 1;
}

dcmd_bountyhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Bounty related commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /hitman    - to set a bounty on another player");
	SendClientMessage(playerid, COLOR_MENU,"* /bounty    - to view the current bounty on a player");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_otherhelp(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"_______________________________________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Other commands:");
	SendClientMessage(playerid, COLOR_MENU,"* /rules & /rulesnl - to view the rules of this server. /rules is in English, /rulesnl is in Dutch");
	SendClientMessage(playerid, COLOR_MENU,"* /kill       - to commit suicide");
	SendClientMessage(playerid, COLOR_MENU,"* /taxi       - to take a taxi to a defined location");
	SendClientMessage(playerid, COLOR_MENU,"* /credittaxi - same as /taxi, only now you pay with your creditcard");
	SendClientMessage(playerid, COLOR_MENU,"* /taxilocs   - the locations used for the taxi");
	SendClientMessage(playerid, COLOR_MENU,"* /taxirates  - to view the rates you need to pay for the taxi");
	SendClientMessage(playerid, COLOR_MENU,"* /new        - to review the latest changes");
	SendClientMessage(playerid, COLOR_MENU,"_______ For extended help: type /help [commmand] ______________________________________________________________");
	return 1;
}

dcmd_deathmatch(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* Currently you can start one of the following deathmatches:");
	SendClientMessage(playerid, COLOR_MENU,"* - Desert eagle 1 vs 1: /eaglematch  - costs $10.000");
	SendClientMessage(playerid, COLOR_MENU,"* - Chain Saw Massacre, max 4 players: /chainmatch  - costs $10.000");
	SendClientMessage(playerid, COLOR_MENU,"* - Minigun Madness, max 6 players: /minimatch  - costs $25.000");
	SendClientMessage(playerid, COLOR_MENU,"* - Crazy uzis, max 6 players: /uzimatch  - costs $10.000");
	SendClientMessage(playerid, COLOR_MENU,"* - Russian roulette 1vs 1: /rusroulette [1-3]  - costs $25.000");
	SendClientMessage(playerid, COLOR_MENU,"* Countdown timer: 30 seconds. Just one player: match cancelled.");
	SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	return 1;
}

dcmd_races(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"__________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 1,   max 2 players: /dragrace1  - costs $10 000 . Level: easy");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 2,   max 4 players: /dragrace2  - costs $10 000 . Level: easy");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 3,   max 2 players: /dragrace3  - costs $20 000 . Level: medium");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 4,   max 2 players: /dragrace4  - costs $20 000 . Level: medium");
	SendClientMessage(playerid, COLOR_MENU,"________________See /races2 or /races3 or /races4 or /races5 for more races_______");
	return 1;
}

dcmd_races2(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 5,   max 2 players: /dragrace5  - costs $10 000 . Level: easy");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 6,   max 2 players: /dragrace6  - costs $20 000 . Level: medium");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 7,   max 2 players: /dragrace7  - costs $10 000 . Level: medium");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 8,   max 4 players: /dragrace8  - costs $20 000 . Level: medium");
	SendClientMessage(playerid, COLOR_MENU,"* - Drag race type 9,   max 2 players: /dragrace9  - costs $40 000 . Level: very hard");
	SendClientMessage(playerid, COLOR_MENU,"________________See /races or /races3 or /races4 or /races5 for more races_______");
	return 1;
}

dcmd_races3(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 1, max 4 players: /sprintrace1  - costs $20 000 . Level: medium");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 2, max 4 players: /sprintrace2  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 3, max 2 players: /sprintrace3  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 4, max 2 players: /sprintrace4  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"________________See /races or /races2 or /races4 or /races5 for more races_______");
	return 1;
}

dcmd_races4(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 5, max 2 players: /sprintrace5  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 6, max 2 players: /sprintrace6  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Sprint race type 7, max 2 players: /sprintrace7  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"________________See /races or /races2 or /races3 or /races5 for more races_______");
	return 1;
}

dcmd_races5(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_MENU,"____________________________________________________________________________________");
	SendClientMessage(playerid, COLOR_MENU,"* - Motor race type 1, max 2 players: /motorrace1  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Motor race type 2, max 2 players: /motorrace2  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Motor race type 3, max 2 players: /motorrace3  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Motor race type 4, max 2 players: /motorrace4  - costs $50 000 . Level: very hard");
	SendClientMessage(playerid, COLOR_MENU,"* - Motor race type 5, max 2 players: /motorrace5  - costs $25 000 . Level: hard");
	SendClientMessage(playerid, COLOR_MENU,"________________See /races or /races2 or /races3 or /races4 for more races_______");
	return 1;
}

dcmd_rules(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_RULES,"* Please obey the following rules:");
	SendClientMessage(playerid, COLOR_RULES,"* - No shooting on, to or from the ship *** Do not kill a player indoors");
	SendClientMessage(playerid, COLOR_RULES,"* - Do not shoot at obvious pimped/tuned cars *** Do not highjack an obvious pimped/tuned car.");
	SendClientMessage(playerid, COLOR_RULES,"* - Do not cheat, cheaters will be banned without warning *** Do not swear in public or privat chat");
	SendClientMessage(playerid, COLOR_RULES,"* - Do not beg for money. Stand on the ship if you need some ** Do not interfere with an ongoing cruise");
	SendClientMessage(playerid, COLOR_RULES,"* - Do not hunt / harass other players. If they say STOP when you attack, stop your attack");
	SendClientMessage(playerid, COLOR_RULES,"* - In general: This is a game, everyone should have fun, not just you!");
    SendClientMessage(playerid, COLOR_RULES,"* - For new ideas or suggestions for this server use our forum. Check sa-mp.com for howto get your own server.");
	return 1;
}

dcmd_rulesnl(playerid,params[])  {
	#pragma unused params
	SendClientMessage(playerid, COLOR_RULES,"* Deze server kent de volgende regels:");
	SendClientMessage(playerid, COLOR_RULES,"* - Niet op, naar of vanaf het schip te schieten *** Binnen geen spelers doden");
	SendClientMessage(playerid, COLOR_RULES,"* - Niet schieten op duidelijk gepimpte / aangepaste auto's *** Steel geen duidelijk gepimpte / aangepaste auto");
	SendClientMessage(playerid, COLOR_RULES,"* - Niet cheaten, wordt je betrapt dan wordt je direct verbannen! *** Schelden is verboden op deze server");
	SendClientMessage(playerid, COLOR_RULES,"* - Niet bedelen om geld. Als je het nodig hebt, kun je op het schip gaan staan. *** Verstoor geen toertochten");
	SendClientMessage(playerid, COLOR_RULES,"* - Geen spelers opjagen of lastig vallen. Zeggen ze STOP als je ze aanvalt, stop de aanval");
	SendClientMessage(playerid, COLOR_RULES,"* - In het algemeen: Dit is een spel: iedereen behoort plezier te hebben, niet alleen jij!");
    SendClientMessage(playerid, COLOR_RULES,"* - Plaats nieuwe ideeen of suggesties voor deze server op het forum. Kijk op sa-mp.com hoe je een server kunt maken.");
	return 1;
}

dcmd_adminhelp(playerid,params[])  {
	#pragma unused params
	switch (adminlevel[playerid]) {
		case 1:{
			SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 1______________________________________________________");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* ACCOUNT: /admins /getlevel /protect /iamadmin /iamnoadmin");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* MONEY: /getmoney");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* TELEPORT: /goto /hideout /villa");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* CONTROL: /jail /unjail /jaillist /unmute /unfreeze /kick");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* TIME: /givetime *** DRAG: /resetdrag1 - /resetdrag9 /resetsprint1 /resetsprint2 /resetalldrags");
  	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* OTHER: /announce /countdown /stopcountdown /shortcuts /adminhelp /whois /20 /30 /40 /uptime");
			SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________");
		}
		case 2:{
			SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 2______________________________________________________");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* ACCOUNT: /admins /getlevel /getuser /protect /setprot");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* ACCOUNT: /getprop /adminspawn /iamadmin /iamnoadmin");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* MONEY: /getmoney /getbank");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* HEALTH: /heal /murder /admindive");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* WEAPONS: /disarm");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* TELEPORT: /goto /get /tp /cartp /cargoto /locs /hideout /villa");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* DRAG: /resetdrag1 - /resetdrag9 /resetsprint1 /resetsprint2 /resetalldrags");
			SendClientMessage(playerid, COLOR_MENU,"____________more help in /adminhelp2__________________________________");
		}
		case 3:{
			SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 3______________________________________________________");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* ACCOUNT: /admins /svall /setadmin /removeadmin /setlevel");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* ACCOUNT: /getlevel /setprot /protect /adminspawn");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* ACCOUNT: /getuser /deluser /getprop /iamadmin /iamnoadmin");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* MONEY: /givemoney /setmoney /getmoney /setbank /getbank /setbounty");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* WEAPONS: /giveweapon /disarm /giveweaplist /lvplaytime");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* TELEPORT: /goto /get /tp /cartp /cargoto /tpto /locs /hideout /villa");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* DRAG: /resetdrag1 - /resetdrag9 /resetsprint1 /resetsprint2 /resetalldrags");
			SendClientMessage(playerid, COLOR_MENU,"____________more help in /adminhelp2__________________________________");
		}
	}
	return 1;
}

dcmd_adminhelp2(playerid,params[])  {
	#pragma unused params
	if(adminlevel[playerid] == 2){
		SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 2______________________________________________________");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* CONTROL: /jail /unjail /jaillist /mute /unmute /freeze /unfreeze");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* CONTROL: /kick /ban /regular /notregular");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* SPY: /visible /invisible /iamadmin /iamnoadmin /noadinvis");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* SPY: /spyon /spyoff /spystaton /spystatoff");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* TIME: /setdawn /setnoon /setdusk /setnight /givetime");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* OTHER: /announce /countdown /stopcountdown /shortcuts");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* OTHER: /adminhelp /adminhelp2 /whois /20 /30 /40 /uptime");
		SendClientMessage(playerid, COLOR_MENU,"____________more help in /adminhelp___________________________________");
	}
	if(adminlevel[playerid] == 3){
		SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 2______________________________________________________");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* CONTROL: /jail /unjail /jaillist /mute /unmute /freeze /unfreeze");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* CONTROL: /kick /ban /unban /regular /notregular /helper /nohelper");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* HEALTH: /heal /god /murder /admindive");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* SPY: /visible /invisible /iamadmin /iamnoadmin /noadinvis");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* SPY: /spyon /spyoff /spystaton /spystatoff /pmspyon /pmspyoff /pmspyoffall");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* TIME: /settime /givetime");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* OTHER: /announce /countdown /stopcountdown /shortcuts /enablepatrol /disablepatrol");
        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* OTHER: /adminhelp /adminhelp2 /whois /20 /30 /40 /uptime /chatoff /chaton");
		SendClientMessage(playerid, COLOR_MENU,"_____________more help in /adminhelp___________________________________");
	}
	return 1;
}

dcmd_shortcuts(playerid,params[])  {
	#pragma unused params
	switch (adminlevel[playerid]) {
		case 1:{
			SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 1 SHORTCUTS____________________________________________");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /unj /unf /k / p /hid (unjail, unfreeze, kick, protect, hideout)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /noad /iad(iamnoadmin, iamadmin)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /ann /cd /ad /adhelp (announce, countdown, admins, adminhelp)");
			SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________");
		}
		case 2:{
			SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 2 SHORTCUTS____________________________________________");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /j /unj /f /unf /k /b /p (jail, freeze, kick, ban, protect)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /h /hid /noad /iad(heal, hideout, iamnoadmin, iamadmin)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /ann /cd /ad /adhelp (announce, countdown, admins, adminhelp)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /vis /invis /ssn /ssf (visible, invisible, spystaton, spystatoff)");
			SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________");
		}
		case 3:{
			SendClientMessage(playerid, COLOR_MENU,"___ADMIN LEVEL 3 SHORTCUTS____________________________________________");
			SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /j /unj /f /unf /k /b /p (jail, freeze, kick, ban, protect)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /gm /gw /h /hid /noad /iad(givemoney, giveweapon, heal, hideout, iamnoadmin, iamadmin)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /ann /cd /ad /adhelp (announce, countdown, admins, adminhelp)");
	        SendClientMessage(playerid, COLOR_ADMIN_CMD,"* /vis /invis /ssn /ssf (visible, invisible, spystaton, spystatoff)");
			SendClientMessage(playerid, COLOR_MENU,"______________________________________________________________________");
		}
	}
	return 1;
}

dcmd_sk(playerid,params[])  {
	return dcmd_shortcuts(playerid,params);
}

dcmd_giveweaplist(playerid,params[])  {
	#pragma unused params
    if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* Weapon id's for use with /giveweapon:");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 1.Brassknuckle * 2.Golfclub * 3.*Nitestick * 4.Knife * 5.Bat");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 6.Shovel * 7.Poolstick * 8.Katana * 9.Chainsaw * 10.Dildo * 11.Dildo2");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 12.Vibrator * 13.Vibrator2 * 14.Flower * 15.Cane * 16.Granade * 17.Teargas");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 18.Moltov * 22. Colt45 * 23.Silenced * 24.DEagle * 25. Shotgun");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 26.Sawn-off * 27.CombatShotgun * 28.Uzi * 29.MP5 * 30.AK47 * 31.M4");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 32.Tec9 * 33.Rifle * 34.Sniper * 35.Rocketlauncher * 36.Heatseeker");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 37.Flamethrower * 38.Minigun * 39.Satchel * 40.Bomb * 41.Spraycan");
		SendClientMessage(playerid, COLOR_ADMIN_CMD,"* 42.FireExtin * 43.Camera * 46. Parachute");
	}
	return 1;
}

dcmd_goto(playerid,params[])  {
	new index=0;
	tmps1 = strtok(params, index);
	if(!strlen(tmps1) || !IsNumeric(tmps1)) {
		SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /goto [playerid]. This will teleport you to [playerid].");
		return 1;
	}

	giveplayerid = strval(tmps1);

	if(IsPlayerConnected(giveplayerid)) {
		if(Z250[giveplayerid] > 800){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* The player you are teleporting to, is most likely inside a building. Operation is aborted.");
	  	    return 1;
		}
        GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
		GetPlayerName(playerid, playername, sizeof(sendername));
		SetPlayerInterior(playerid, 0);
		SetPlayerPos(playerid, X250[giveplayerid], Y250[giveplayerid], Z250[giveplayerid] + 5);
		SetCameraBehindPlayer(playerid);
		format(strings, sizeof(strings), "--- %s (id: %d) teleported himself to %s (id: %d)", playername,playerid,giveplayer,giveplayerid);
		printf(strings);
		format(strings, sizeof(strings), "* You teleported yourself to %s (id: %d).", giveplayer,giveplayerid);
		SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
	} else {
		format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
		SendClientMessage(playerid, COLOR_ADMIN_PW, strings);
	}

	return 1;
}

dcmd_get(playerid,params[])  {
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {

		new index = 0;
 		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /get [playerid]. This will teleport [playerid] to you (Don't use inside an interior). ");
			return 1;
		}

		giveplayerid = strval(tmps1);

		if(IsPlayerConnected(giveplayerid)) {
            GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, playername, sizeof(sendername));

			SetPlayerInterior(giveplayerid, 0);
			SetPlayerPos(giveplayerid, X250[playerid], Y250[playerid], Z250[playerid] + 5);
			SetCameraBehindPlayer(giveplayerid);

			format(strings, sizeof(strings), "--- %s (id: %d) teleported %s (id: %d) to himself", playername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* You teleported %s (id: %d) to yourself.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW, strings);
		}
	}
	return 1;
}

dcmd_jaillist(playerid,params[])  {
	#pragma unused params
    new jailinmates;
    for(new i=0;i<MAX_PLAYERS;i++) {
		if(jailed[i] == 1) {
		    if(jailinmates == 0) {
       			SendClientMessage(playerid, COLOR_ADMIN_PW, "* List of players currently in jail:");
				jailinmates = 1;
			}
			GetPlayerName(i, playername, sizeof(playername));
			format(strings, sizeof(strings), "* %s (id: %d) still doing %d minutes.", playername,i,jailtime[i]);
			SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
		}
	}
	if(jailinmates == 0){
	    SendClientMessage(playerid, COLOR_ADMIN_PW, "* The jail is empty apart from some rats.");
	}
	return 1;
}

dcmd_announce(playerid,params[])  {
	new GameTextForPlayer1[36];
	new GameTextForPlayer2[36];
	new index = 0;
	new text[256];
	new gametextindex = 1;
	new temp;
	tmps1 = strtok(params, index);
	if(strlen(tmps1) > 1) {
	    strmid(text, params, strlen(cmd), strlen(params));
		index=0;
        format(GameTextForPlayer1, sizeof(GameTextForPlayer1), "");
        format(GameTextForPlayer2, sizeof(GameTextForPlayer2), "");
		for(new i=0; i<32; i++){
			tmps1 = strtok(text, index);
			if(strlen(tmps1) > 0 && strlen(tmps1) < 32){
			    if(gametextindex == 1){
					temp=strlen(GameTextForPlayer1) + strlen(tmps1) + 1;
					if(temp < 32){
				        format(GameTextForPlayer1, sizeof(GameTextForPlayer1), "%s %s", GameTextForPlayer1, tmps1);
				    } else {
				        gametextindex = 2;
				        format(GameTextForPlayer2, sizeof(GameTextForPlayer2), "%s", tmps1);
					}
				} else {
				    if(gametextindex == 2){
						temp=strlen(GameTextForPlayer2) + strlen(tmps1) + 1;
						if(temp < 32){
					        format(GameTextForPlayer2, sizeof(GameTextForPlayer2), "%s %s", GameTextForPlayer2, tmps1);
					    } else {
					        gametextindex = 3;
						}
					}
				}
			} else {
			    if(strlen(tmps1) > 31) gametextindex = 3;
			}
		}
        format(GameTextForPlayer1, sizeof(GameTextForPlayer1), "~w~%s", GameTextForPlayer1);
		for(new i=0; i<MAX_PLAYERS; i++){
		    if(IsPlayerConnected(i)){
		        format(GameTextForPlayers1[i], 36, "%s", GameTextForPlayer1);
		        format(GameTextForPlayers2[i], 36, "%s", GameTextForPlayer2);
				GameTextForPlayersCounter[i]=10;
			}
		}
//		format(strings,sizeof(strings),"~w~%s",text);
//		GameTextForAll(strings,ANNOUNCE_SECONDS*1000,3);
        GetPlayerName(playerid, playername, sizeof(giveplayer));
		format(strings, sizeof(strings), "%s --- Announcement from %s (id: %d): %s", SystemTime,playername,playerid,text);
		printf(strings);
		format(strings, sizeof(strings), "* Admin %s says: %s", playername, text);
		SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
	} else {
		SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /announce [text]. This will show the [text] to everyone in the center of the screen.");
		return 1;
	}

	return 1;
}

dcmd_ann(playerid,params[])  {
	return dcmd_announce(playerid,params);
}

dcmd_slap(playerid,params[])  {
	new Float:health;
	new index = 0;

	tmps1 = strtok(params, index);

	if(!strlen(tmps1) || !IsNumeric(tmps1)) {
		SendClientMessage(playerid, COLOR_CMD , "* USAGE: /slap [playerid]. You can slap [playerid]. Admins who slap, will take some health.");
		return 1;
	}
    giveplayerid = strval(tmps1);
	if(IsPlayerConnected(giveplayerid)) {
	    GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
		GetPlayerName(playerid, playername, sizeof(sendername));
		format(strings, sizeof(strings), "--- %s slaps %s around a bit with a large trout.", playername,giveplayer);
		printf(strings);
	    format(strings,sizeof(strings),"%s slaps %s around a bit with a large trout.", playername, giveplayer);
	    SendClientMessageToAll(COLOR_IRC,strings);
    	if(IsAdmin(playerid)) {
			GetPlayerHealth(giveplayerid,health);
			health = floatsub(health, float(SLAP_HEALTH));
			if(health < float(5)) health = float(5);
	  		SetPlayerHealth(giveplayerid,health);
        }
	} else {
		format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
		SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
	}
    return 1;
}


dcmd_countdown(playerid,params[])  {
	new index = 0;
	tmps1 = strtok(params, index);
	if(countdownseconds >0) {
		SendClientMessage(playerid, COLOR_ADMIN_PW, "Countdown allready in progress.");
		return 1;
	}
	if(!strlen(tmps1) || !IsNumeric(tmps1)) {
		SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /countdown [seconds]. This will show a counter in the middle of the screen.");
		return 1;
	}
    countdownseconds = strval(tmps1) + 1;
	if(countdownseconds > MAX_COUNTDOWN_SEC) {
		format(strings, sizeof(strings), "Maximum seconds for countdown is %d",MAX_COUNTDOWN_SEC);
		countdownseconds = 0;
		return 1;
	}
	GetPlayerName(playerid, playername, sizeof(sendername));
	format(strings, sizeof(strings), "--- %s Started a countdown of %d seconds.", playername,countdownseconds);
	printf(strings);
	return 1;
}

dcmd_cd(playerid,params[])  {
	return dcmd_countdown(playerid,params);
}

dcmd_stopcountdown(playerid,params[])  {
	#pragma unused params
	if(countdownseconds > 0) {
		countdownseconds = 0;
		SendClientMessage(playerid, COLOR_ADMIN_PM, "* Countdown stopped.");
		return 1;
	} else SendClientMessage(playerid, COLOR_ADMIN_PW, "* There is no countdown in progress.");
	return 1;
}

dcmd_stopcd(playerid,params[])  {
	#pragma unused params
	return dcmd_stopcountdown(playerid,params);
}
dcmd_register(playerid,params[])  {
	new index = 0;
    tmps1 = strtok(params, index);
	GetPlayerName(playerid, playername, sizeof(playername));
	if(!strlen(tmps1)) {
		SendClientMessage(playerid, COLOR_CMD, "* USAGE: /register [password]. This will register your nick. Don't forget your password.");
		return 1;
	}
    if(20 < strlen(tmps1) || strlen(tmps1) < 5) {
		SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Password length must be 5-20 symbols.");
		return 1;
	} else {
		if (!dini_Exists(udb_encode(playername))) {
			dini_Create(udb_encode(playername));
			dini_IntSet(udb_encode(playername), "password", udb_hash(tmps1));
			dini_IntSet(udb_encode(playername), "newplayer", 1);
			format(strings, sizeof(strings), "%s --- %s (id: %d) created account. Passwordhash: %s.", SystemTime,playername, playerid,udb_hash(tmps1));
			printf(strings);
			format(strings, sizeof(strings), "* Account named %s created! You can login with password %s.", playername, tmps1);
			SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			if(spawned[playerid]){
				GameTextForPlayer(playerid, "~w~ You are not logged in! type /login", 120000, 3);
				LoginTimeout[playerid]=60;
			}
		} else {
			format(strings, sizeof(strings), "* %s is already registered.", playername,tmps1);
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
		}
	}
	return 1;
}

dcmd_setpass(playerid,params[])  {
	new index = 0;
    tmps1 = strtok(params, index);
	GetPlayerName(playerid, playername, sizeof(playername));
	if(20 < strlen(tmps1) || strlen(tmps1) < 5) {
		SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Password length must be 5-20 symbols.");
		return 1;
	}
	if(!strlen(tmps1))
		SendClientMessage(playerid, COLOR_CMD, "* USAGE: /setpass [password]. This can change your password.");
	else {
		if (dini_Exists(udb_encode(playername))) {
		    if (logged[playerid] == 1) {
				dini_IntSet(udb_encode(playername), "password", udb_hash(tmps1));
				format(strings, sizeof(strings), "--- %s (id: %d) changed his pass to password with hash %s.", playername, playerid,udb_hash(tmps1));
				printf(strings);
				format(strings, sizeof(strings), "* Password changed to %s, remember it.", tmps1);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			} else SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be logged in to change your password.");
		} else {
		    format(strings, sizeof(strings), "* %s no such account.", playername);
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
		}
	}
	return 1;
}

dcmd_login(playerid,params[])  {
    new index=0;
	tmps1=strtok(params,index);
    new balance, CurVal, temp;
    new m, giveback, propertyID;
	GetPlayerName(playerid, playername, sizeof(playername));
    if(!strlen(tmps1)) {
		SendClientMessage(playerid, COLOR_CMD, "* USAGE: /login [password]. This will log you into the server and restore your data.");
	} else {
		if (dini_Exists(udb_encode(playername))) {
	    	if (logged[playerid] == 1) {
	    	    format(strings, sizeof(strings), "--- %s is already logged in.", playername);
				printf(strings);
				SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You are already logged in.");
			}
			else {
				tmps2 = dini_Get(udb_encode(playername), "password");
		  		if (udb_hash(tmps1) != strval(tmps2)) {
	  			    format(strings, sizeof(strings), "--- %s (id: %d) typed wrong password, Password with hash: %s.", playername, playerid, udb_hash(tmps1));
					printf(strings);
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Wrong password.");
				}
				else {

					tmps3 = dini_Get(udb_encode(playername), "banned");
					if (strlen(tmps3)){
						if (strval(tmps3) == 1) {
						    SendClientMessage(playerid, COLOR_SYSTEM_GW, "* Your name is banned from this server.");
							format(strings, sizeof(strings),"User has been banned from the server.");
					        BanMsg(playerid, -1, strings);
							return 1;
						}
					}
					logged[playerid] = 1;
					SpawnTimeout[playerid] = 0;
					muted[playerid] = 0;
					format(strings, sizeof(strings), "%s --- %s (id: %d) logged in. Passwordhash: %s.", SystemTime,playername, playerid, udb_hash(tmps1));
					printf(strings);
					format(strings, sizeof(strings), "~n~~w~Welcome back, %s.~n~You are logged in!", playername);
					GameTextForPlayer(playerid, strings, 3000, 3);
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You are logged in! Please type /help to get started.");
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Don't kill anyone on or from the ship, or you will be jailed.");
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Killing someone indoors will also be punished by sending you to jail.");
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Read the rules with the command /rules or /rulesnl.");
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Small list of updated items: check /new.");
					if(spawned[playerid] == 1) {
						SetPlayerInterior(playerid,0);
						SetPlayerRandomSpawn(playerid);
					}

					tmps1 = dini_Get(udb_encode(playername), "money");
					balance = strval(tmps1);
					if(balance <= 0) balance = PocketMoney;
					tmps1 = dini_Get(FILE_SETTINGS, "maxmoney");
					if(balance > strval(tmps1)) balance = strval(tmps1);
					currentmoney[playerid] = balance;
					// TO-DO moneyscanner update
					format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d connected and restored his money or got pocketmoney", balance, GetPlayerMoney(playerid), playerid);
					StatGivePlayerMoney(playerid, balance, moneyreason);
					tmps1 = dini_Get(udb_encode(playername), "bank");
					bank[playerid] = strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "bounty");
					bounty[playerid] = strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "jailed");
					if (strval(tmps1) == 1) jailed[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "jailtime");
					if (strval(tmps1) != 0) jailtime[playerid] = strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "muted");
					if (strval(tmps1) == 1) muted[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "admin");
					if (strval(tmps1) > 0) adminlevel[playerid] = strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "gamblelicence");
					if (strval(tmps1) == 1) gamblelicence[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "speedometer");
					if (strval(tmps1) == 1) speedometer[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "fuelmeteroff");
					if (strval(tmps1) == 1) FuelmeterOff[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "speedoon");
					if (strval(tmps1) == 1) speedometeron[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "autolock");
					if (strval(tmps1) == 1) autolock[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "protected");
					if (strval(tmps1) == 1) isprotected[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "fuelcan");
					if (strval(tmps1) == 1){
						Fuelcan[playerid] = 1;
						FuelcanContent[playerid] = 1;
					}
					tmps1 = dini_Get(udb_encode(playername), "payout");
					if (strval(tmps1) == 1) Payout[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "owncolorchosen");
					if (strval(tmps1) == 1){
					    OwnPlayerColorChosen[playerid] = 1;
						tmps1 = dini_Get(udb_encode(playername), "owncolor");
						if (strlen(tmps1)){
							if (strval(tmps1) < 999) OwnPlayerColor[playerid] = strval(tmps1);
						}
					}
					tmps1 = dini_Get(udb_encode(playername), "ownspawn");
					if (strval(tmps1) == 1) OwnSpawner[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "hudcolor");
					if (strval(tmps1) > 0) {
						HUDColor[playerid] = strval(tmps1);
					} else {
						HUDColor[playerid] = 0;
					}
					tmps1 = dini_Get(udb_encode(playername), "forbiddentuning");
					if(strval(tmps1) != 0 ) ForbiddenTuningTimes[playerid]=strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "drivebywarning");
					if(strval(tmps1) != 0 ) DrivebyWarning[playerid]=strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "weaponcheatwarning");
					if(strval(tmps1) != 0 ) WeaponCheatWarning[playerid]=strval(tmps1);
					tmps1 = dini_Get(udb_encode(playername), "regularplayer");
					if (strval(tmps1) == 1) RegularPlayer[playerid] = 1;
					tmps1 = dini_Get(udb_encode(playername), "helper");
					if (strval(tmps1) == 1){
						Helper[playerid] = 1;
						SendClientMessage(playerid, COLOR_BLUE , "* You are marked as helper. Type /helpermenu for available commands.");
						SendClientMessage(playerid, COLOR_BLUE , "* Note: you will NOT see this message again, it is only displayed upon loggin in.");
					}
					tmps1 = dini_Get(udb_encode(playername), "newplayer");
					if (strval(tmps1) == 1) NewPlayer[playerid] = 1;
					for(new i=0; i<8; i++){
					    m=i+1;
					    format(strings, sizeof(strings), "property%d", m);
					    tmps1 = dini_Get(udb_encode(playername), strings);
					    propertyID = strval(tmps1);
					    if(propertyID != 0) {
							if((propertyID == P_ANGELMED)  || (propertyID == P_ELQMED)){
								MedicalOfficer[playerid]=1;
							}
						    format(strings, sizeof(strings), "value%d", m);
						    tmps2 = dini_Get(udb_encode(playername), strings);
							if (strval(tmps2) != 0) {
       							CurVal = strval(tmps2);
								if(propertyOwner[propertyID] == 999){
									propertyArray[playerid][i] = propertyID;
									propertyOwner[propertyID] = playerid;
									ownedtime[propertyID] = 15;
									propertyCurrentValue[propertyID] = CurVal;
								} else {
									giveback=CurVal;
									format(strings, sizeof(strings),"* You are no longer the owner of %s, you have received $%d on your bank account.", propertyNames[propertyID], CurVal);
									SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
									bank[playerid]=bank[playerid]+giveback;
								}
							} else {
						        giveback = propertyOldValues[propertyID];
								SendClientMessage(playerid,COLOR_SYSTEM_PW,"* The property system on this server has changed. You reveice a full refund of the original propery values on your bank.");
								if(giveback < propertyOldValues[propertyID]){
									format(strings, sizeof(strings),"* You received for %s $%d on your bank account. This is not the full 100 percent, due to a full bank account.", propertyNames[propertyID], giveback);
								} else {
									format(strings, sizeof(strings),"* You received for %s $%d on your bank account.", propertyNames[propertyID], giveback);
								}
								SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
								bank[playerid]=bank[playerid]+giveback;
							}
						}
					}
					SaveProperties(playerid);
					for(new i=0; i<8; i++){
						m=i+1;
						format(strings, sizeof(strings), "property%d", m);
						dini_IntSet(udb_encode(playername), strings, propertyArray[playerid][i]);
						format(strings, sizeof(strings), "value%d", m);
						if(propertyArray[playerid][i] != 0){
							propertyID = propertyArray[playerid][i];
							dini_IntSet(udb_encode(playername), strings, propertyCurrentValue[propertyID]);
						} else {
							dini_IntSet(udb_encode(playername), strings, 0);
						}
					}
				    if(OwnPlayerColor[playerid] == 999){
					    SetPlayerColor(playerid, playerColors[playerid]);
					} else {
						temp=PlayerColorsChoice[OwnPlayerColor[playerid]];
					    SetPlayerColor(playerid, temp);
					}
					SendDeathMessage(INVALID_PLAYER_ID, playerid, 201);
					if(spawned[playerid] == 1 && jailed[playerid] == 1){
						SetPlayerInterior(playerid,10);
						SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
						if(jailcelcounter < 3) {
						    jailcelcounter++;
						} else {
						    jailcelcounter=0;
						}
					}
				}
			}
		}
		else {
		    format(strings, sizeof(strings), "* %s no such account.", playername);
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
		}
	}
	return 1;
}

dcmd_gamble(playerid,params[])  {
	#pragma unused params
	if (logged[playerid] == 1){
		tmps1 = dini_Get(FILE_SETTINGS, "casinos");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Casino's are not enabled on this server!");
		    return 1;
		}
        GetPlayerName(playerid, playername, sizeof(playername));
        if (gamblelicence[playerid] == 1) {
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You allready have a gambling licence!");
		    return 1;
		}
		if (logged[playerid] == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must to be logged in to buy a gambling licence!");
		    return 1;
		}
		if (GetPlayerMoney(playerid) >= GAMBLE_LICENCE){
			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a gamble licence",GAMBLE_LICENCE, GetPlayerMoney(playerid), playerid);
			StatGivePlayerMoney(playerid, -GAMBLE_LICENCE, moneyreason);
			dini_IntSet(udb_encode(playername), "gamblelicence", 1);
			gamblelicence[playerid] = 1;
			format(strings, sizeof(strings), "--- %s (id: %d) bought a gamble licence for %d.", playername,playerid,GAMBLE_LICENCE);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) bought a gamble licence for %d.", playername,playerid,GAMBLE_LICENCE);
			SendClientMessageToAll(COLOR_SYSTEM_GM, strings);
		} else {
		    format(strings, sizeof(strings), "* You don't have enough money to buy a gamble licence. It costs $%d.", GAMBLE_LICENCE);
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
			return 1;
		}
	}
	return 1;
}

dcmd_lock(playerid,params[])  {
	#pragma unused params
	new VehicleID;
	tmps1 = dini_Get(FILE_SETTINGS, "locking");
	if (strval(tmps1) == 0) {
	    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Locking vehicles is not allowed on this server!");
	    return 1;
	}
	if(IsPlayerInAnyVehicle(playerid)) {
		if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Only the driver can lock the car!");
			return 1;
		}
		VehicleID=GetPlayerVehicleID(playerid);
		for(new i=0;i<MAX_PLAYERS;i++) if(i != playerid) SetVehicleParamsForPlayer(VehicleID, i, 0, 1);
		manuallock[VehicleID]=1;
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Your vehicle is now locked.");
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
	} else SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be in a vehicle to lock it.");
	return 1;
}

dcmd_close(playerid,params[])  {
	return dcmd_lock(playerid,params);
}

dcmd_unlock(playerid,params[])  {
	#pragma unused params
	new VehicleID;
    tmps1 = dini_Get(FILE_SETTINGS, "locking");
	if (strval(tmps1) == 0) {
	    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Locking vehicles is not allowed on this server!");
	    return 1;
	}
	if(IsPlayerInAnyVehicle(playerid)) {
		if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Only the driver can unlock the car!");
			return 1;
		}
		VehicleID=GetPlayerVehicleID(playerid);
		for(new i=0;i<MAX_PLAYERS;i++) if(i != playerid) SetVehicleParamsForPlayer(VehicleID, i, 0, 0);
		manuallock[VehicleID]=0;
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Your vehicle is now opened.");
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	}
	else SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be in a vehicle to unlock it.");
	return 1;
}

dcmd_open(playerid,params[])  {
	return dcmd_unlock(playerid,params);
}

dcmd_bank(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
		new checking;
        tmps1 = dini_Get(FILE_SETTINGS, "bank");

		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Banks are not allowed on this server!");
		    return 1;
		}

	    if(IsPlayerInCheckpoint(playerid) == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at a bank area to use this. ATMs are located in convenience stores.");
			return 1;
		} else {
			if(getCheckpointType(playerid) == CP_BANK){
				checking=1;
			}
			if(getCheckpointType(playerid) == CP_SFBANK){
				checking=1;
			}
			if(checking==0){
		        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at a bank area to use this. ATMs are located in convenience stores.");
				return 1;
			}
		}

	    tmps1 = strtok(params, index);

	    if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD, "* USAGE: /bank [amount]. This will permanently store your [amount] on the bank.");
			return 1;
	    }
	    moneys = strval(tmps1);

	    if(moneys < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Hey what are you trying to pull here?");
			return 1;
		}

		if(GetPlayerMoney(playerid) < moneys) {
			moneys = GetPlayerMoney(playerid);
		}
		
		
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d banked some cash.", moneys,

		GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, 0-moneys, moneyreason);
		bank[playerid]+=moneys;
		GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);
		format(strings, sizeof(strings), "--- %s (id: %d) deposited $%d, balance is $%d.", giveplayer,playerid,moneys,bank[playerid]);
		printf(strings);
		format(strings, sizeof(strings), "* You have deposited $%d, your current balance is $%d.", moneys, bank[playerid]);
		SendClientMessage(playerid, COLOR_MONEY_DEC, strings);
		SaveFile(playerid);

	}
	return 1;
}

dcmd_bankall(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new checking;
        tmps1 = dini_Get(FILE_SETTINGS, "bank");

		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Banks are not allowed on this server!");
		    return 1;
		}

	    if(IsPlayerInCheckpoint(playerid) == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at a bank area to use this. ATMs are located in convenience stores.");
			return 1;
		} else {
			if(getCheckpointType(playerid) == CP_BANK){
				checking=1;
			}
			if(getCheckpointType(playerid) == CP_SFBANK){
				checking=1;
			}
			if(checking==0){
		        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at a bank area to use this. ATMs are located in convenience stores.");
				return 1;
			}
		}

		moneys = GetPlayerMoney(playerid);

	    if(moneys < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Sorry sir, we cannot accept your generous gift.");
			return 1;
		}

		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d banked some cash.", moneys,

		GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, 0-moneys, moneyreason);
		bank[playerid]+=moneys;
		GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);
		format(strings, sizeof(strings), "--- %s (id: %d) deposited $%d, balance is $%d.", giveplayer,playerid,moneys,bank[playerid]);
		printf(strings);
		format(strings, sizeof(strings), "* You have deposited $%d, your current balance is $%d.", moneys, bank[playerid]);
		SendClientMessage(playerid, COLOR_MONEY_DEC, strings);
		SaveFile(playerid);

	}
	return 1;
}

dcmd_withdraw(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "bank");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Banks are not allowed on this server!");
		    return 1;
		}

	    if(IsPlayerInCheckpoint(playerid) == 0 || getCheckpointType(playerid) != CP_BANK) {
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at a bank area to use this. ATMs are located in convenience stores.");
			return 1;
		}

	    tmps1 = strtok(params, index);

	    if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD, "* USAGE: /withdraw [amount]. With this you can withdraw [amount] from your bankaccount.");
			return 1;
	    }
	    moneys = strval(tmps1);

	    if(moneys < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Hey what are you trying to pull here?");
			return 1;
		}

	    if(moneys > bank[playerid])
	        moneys = bank[playerid];
	    if(moneys+GetPlayerMoney(playerid)>100000000){
	        format(strings,sizeof(strings),"* If you would withdraw $%d, combined with your current cash $%d, you would exceed $100000000.",moneys,

			GetPlayerMoney(playerid));
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
	        format(strings,sizeof(strings),"* You can withdraw max $%d. Withdraw aborded: request denied.",100000000-GetPlayerMoney(playerid));
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
			return 1;
		}

		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d withdraws some cash.", moneys,GetPlayerMoney(playerid), playerid);
		if(StatGivePlayerMoney(playerid, moneys, moneyreason)) {
			bank[playerid] -= moneys;
			GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);
			format(strings, sizeof(strings), "--- %s (id: %d) withdrawn $%d, balance is $%d.", giveplayer,playerid,moneys,bank[playerid]);
			printf(strings);
			format(strings, sizeof(strings), "* You have withdrawn $%d, your current balance is $%d.", moneys, bank[playerid]);
			SendClientMessage(playerid, COLOR_MONEY_INC , strings);
			SaveFile(playerid);
		}
   	}
	return 1;
}

dcmd_transfer(playerid,params[])  {
	new index = 0;
	new moneys2;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "bank");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Banks are not allowed on this server!");
		    return 1;
		}

		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, we cannot deliver in prison.");
		    return 1;
		}

		if(Transfered[playerid] > 0){
			format(strings, sizeof(strings), "* You can only use this function once every 5 minutes. You will have to wait %d minutes.", Transfered[playerid]);
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
			return 1;
		}

	    tmps1 = strtok(params, index);

	    if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD, "* USAGE: /transfer [amount]. With this you can withdraw [amount] from your bankaccount without actually visiting a bank.");
			SendClientMessage(playerid, COLOR_CMD, "* This operation can only be done once every 5 minutes, it has a maximum of $ 500.000 each time,");
			SendClientMessage(playerid, COLOR_CMD, "* and it costs 100% extra of the amount you want to withdraw. So to transfer $100.000, $200.000 is written off your bankaccount.");
			return 1;
	    }
	    moneys = strval(tmps1);

	    if(moneys < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Hey what are you trying to pull here?");
			return 1;
		}

	    if(moneys > 500000) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You can only transfer $500000 at max. Please restate your request.");
			return 1;
		}

		moneys2=2*moneys;
	    if(moneys2 > bank[playerid]){
			format(strings, sizeof(strings), "* You can only transfer $%d using this method from your bankaccount.", floatround(floatdiv(bank[playerid],2),floatround_tozero));
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
			return 1;
		}

	    if(moneys+GetPlayerMoney(playerid)>100000000){
	        format(strings,sizeof(strings),"* If you would transfer $%d, combined with your current cash $%d, you would exceed $100000000.",moneys, GetPlayerMoney(playerid));
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
	        format(strings,sizeof(strings),"* You can transfer max $%d. Action aborded: request denied.",100000000-GetPlayerMoney(playerid));
			SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
			return 1;
		}

		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d withdraws some cash.", moneys,GetPlayerMoney(playerid), playerid);
		if(StatGivePlayerMoney(playerid, moneys, moneyreason)) {
			bank[playerid] -= moneys2;
			GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);
			format(strings, sizeof(strings), "--- %s (id: %d) transfered $%d, balance is $%d.", giveplayer,playerid,moneys,bank[playerid]);
			printf(strings);
			format(strings, sizeof(strings), "* You have transfered $%d, your current balance is $%d.", moneys, bank[playerid]);
			SendClientMessage(playerid, COLOR_MONEY_INC , strings);
			Transfered[playerid] = 5;
			SaveFile(playerid);
		}
   	}
	return 1;
}

dcmd_balance(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "bank");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Banks are not allowed on this server!");
		    return 1;
		}
		format(strings, sizeof(strings), "* You have $%d in the bank.", bank[playerid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
	}
	return 1;
}

dcmd_givecash(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "send");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Givecash is not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		GetPlayerName(playerid, sendername, sizeof(sendername));

  		if (dini_Exists(udb_encode(sendername)) && logged[playerid] == 0) {
  		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be logged in to use this.");
			return 1;
		}

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD, "* USAGE: /givecash [playerid] [amount]. This will send [amount] from you to [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD, "* USAGE: /givecash [playerid] [amount]. This will send [amount] from you to [playerid].");
			return 1;
		}
 		moneys = strval(tmps1);

 		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

		if(IsPlayerInCasino(playerid) == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while in a casino!");
		    return 1;
		}

		if (IsPlayerConnected(giveplayerid)) {
			tmps1 = dini_Get(FILE_SETTINGS, "maxmoney");
			playermoney = GetPlayerMoney(playerid);
			if (moneys > 0 && playermoney >= moneys && (GetPlayerMoney(giveplayerid)+moneys < strval(tmps1))) {
				// TO-DO moneyscanner update
				format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d received some cash.",moneys, GetPlayerMoney(giveplayerid), giveplayerid);
				if(StatGivePlayerMoney(giveplayerid, moneys, moneyreason)) {
					// TO-DO money scanner update
					format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d gave away some cash.", moneys, GetPlayerMoney(playerid), playerid);
					StatGivePlayerMoney(playerid, (0 - moneys), moneyreason);

					format(strings, sizeof(strings), "--- %s (id: %d) sent $%d to %s (id: %d).", sendername,playerid,moneys,giveplayer,giveplayerid);
					printf(strings);
					format(strings, sizeof(strings), "* You have sent %s (id: %d), $%d.", giveplayer,giveplayerid, moneys);
					SendClientMessage(playerid, COLOR_MONEY_DEC, strings);
					format(strings, sizeof(strings), "* You have recieved $%d from %s (id: %d).", moneys, sendername, playerid);
					SendClientMessage(giveplayerid, COLOR_MONEY_INC , strings);
				}
			}
			else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid transaction amount.");
			}
		}
		else {
				format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
		}
		return 1;
	}
	return 1;
}

dcmd_hitman(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "bounty");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Bounties are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		GetPlayerName(playerid, sendername, sizeof(sendername));

		if (dini_Exists(udb_encode(sendername)) && logged[playerid] == 0) {
  		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You must be logged in to use this.");
			return 1;
		}

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /hitman [playerid] [amount]. This will put a bounty of [amount] on the head of[playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /hitman [playerid] [amount]. This will put a bounty of [amount] on the head of[playerid].");
			return 1;
		}
 		moneys = strval(tmps1);

		if(IsPlayerInCasino(playerid) == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while in a casino!");
		    return 1;
		}

	    if (moneys > GetPlayerMoney(playerid)) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
	    }

	    if (bounty[giveplayerid] + moneys > MAX_MONEY) {
	        format(strings, sizeof(strings), "* You can't set the bounty higher than $%d! Maximum amount to add: $%d", MAX_MONEY,MAX_MONEY-bounty[giveplayerid]);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
	    }

	    if (moneys < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey what are you trying to pull here?");
			return 1;
		}
		if (!IsPlayerConnected(giveplayerid)) {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}

		bounty[giveplayerid]+=moneys;
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d set a bounty.", moneys,GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, 0-moneys, moneyreason);

		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

		format(strings, sizeof(strings), "--- %s (id: %d) put $%d on %s (id: %d) head (total: $%d).",sendername,playerid,moneys,giveplayer,giveplayerid, bounty[giveplayerid]);
		printf(strings);

		format(strings, sizeof(strings), "* %s has a $%d bounty put on his head from %s (total: $%d).", giveplayer, moneys, sendername,bounty[giveplayerid]);
		SendClientMessageToAll(COLOR_SYSTEM_GM , strings);

	}
	return 1;
}

dcmd_bounty(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "bounty");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Bounties are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bounty [playerid]. This will show the total bounty of [playerid]");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			format(strings, sizeof(strings), "* Player %s (id: %d) has a $%d bounty on his head.",giveplayer,giveplayerid,bounty[giveplayerid]);
			SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
		}
	}
	return 1;
}

dcmd_buy(playerid,params[])  {
	#pragma unused params
	new property=999;
	new amount, m, propertyID, buyoutamount;
	new oldowner=999;
	new buyername[256], oldownername[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not enabled on this server!");
		    return 1;
		}

		if(IsPlayerInCheckpoint(playerid)) {
			property=PropertyCheckpointSelection(playerCheckpoint[playerid]);
			if (property == 999) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in a property checkpoint to /buy it.");
				return 1;
			}

			if (propertyOwner[property] < 999) {
				amount = propertyCurrentValue[property] + floatround(propertyCurrentValue[property]*(BUYOUT_PERC/100));
				if (GetPlayerMoney(playerid) < amount) {
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
					return 1;
				}
			} else {
				if (GetPlayerMoney(playerid) < propertyCurrentValue[property]) {
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
					return 1;
				}
			}

			if (propertyOwner[property] == playerid) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You already own this property.");
				return 1;
			}

            if(GetNumberOfProperties(playerid) >= MAX_OWNED_PROPERTIES) {
				format(strings, sizeof(strings), "* You cannot own more than %d properties.", MAX_OWNED_PROPERTIES);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
				return 1;
			}
			if (property == P_LSTOWN || property == P_SFTOWN || property == P_LVTOWN) {
				if(propertyOwner[P_SAGOVERN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already San Andreas Governor, you can't be mayor as well!");
					return 1;
				}
			}
			if (property == P_SAGOVERN){
				if(propertyOwner[P_LSTOWN] == playerid || propertyOwner[P_SFTOWN] == playerid || propertyOwner[P_LVTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be San Andreas Governor when you are already the mayor of a town!");
					return 1;
				}
			}
			if (property == P_LSTOWN) {
				if(propertyOwner[P_SFTOWN] == playerid || propertyOwner[P_LVTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be a mayor of two citys!");
					return 1;
				}
			}
			if (property == P_SFTOWN) {
				if(propertyOwner[P_LSTOWN] == playerid || propertyOwner[P_LVTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be a mayor of two citys!");
					return 1;
				}
			}
			if (property == P_LVTOWN) {
				if(propertyOwner[P_SFTOWN] == playerid || propertyOwner[P_LSTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be a mayor of two citys!");
					return 1;
				}
			}

			GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
			amount = propertyCurrentValue[property];

			if (propertyOwner[property] < 999) {
				amount = amount + floatround(floatmul(amount,floatdiv(BUYOUT_PERC,100)));
				if (ownedtime[property] > 0) {
					format(strings, sizeof(strings), "* You have to wait %d minutes before the %s becomes available.", ownedtime[property], propertyNames[property]);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
					return 1;
				} else {
				    buyoutamount=propertyCurrentValue[property];
					// TO-DO money scanner update
					if((GetPlayerMoney(propertyOwner[property]) + buyoutamount) > MAX_MONEY){
					    buyoutamount = MAX_MONEY - GetPlayerMoney(propertyOwner[property]);
					}
					format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d 's property was bought out.", amount, GetPlayerMoney(propertyOwner[property]), propertyOwner[property]);
					if(StatGivePlayerMoney(propertyOwner[property], buyoutamount, moneyreason)) {
						format (strings, sizeof(strings), "* Your property, the %s, has been bought out by %s (id: %d) for $%d. You received $%d.",propertyNames[property],giveplayer,playerid, amount, buyoutamount);
						SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
					}
					if(property == P_ANGELMED){
						if(propertyOwner[P_ELQMED] != propertyOwner[property]){
							SendClientMessage(propertyOwner[property], COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
							MedicalOfficer[propertyOwner[property]]=0;
						}
					}
					if(property == P_ELQMED){
						if(propertyOwner[P_ANGELMED] != propertyOwner[property]){
							SendClientMessage(propertyOwner[property], COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
							MedicalOfficer[propertyOwner[property]]=0;
						}
					}
					if(property == P_FORTCARSONPD){
						GetPlayerName(propertyOwner[property], oldownername, sizeof(oldownername));
						SendClientMessage(propertyOwner[property], COLOR_SYSTEM_GM , "* You can no longer perform highway patrols and give speeders a ticket.");
					    HighwayOnMission[propertyOwner[property]] = 0;
						format(strings, sizeof(strings),"* Player %s can no longer patrol the highways, you can roam freely over the highways without getting a ticket.",oldownername);
						SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
						OutOfRanger[propertyOwner[property]]=0;
						HighwayMission = 0;
						SetPlayerColor(propertyOwner[property],playerColors[propertyOwner[property]]);
					}
					oldowner = propertyOwner[property];
				}
			}

			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a property", amount, GetPlayerMoney(playerid), playerid);
			StatGivePlayerMoney(playerid, -amount, moneyreason);

			PlayerPlaySound(playerid,1058,X250[playerid],Y250[playerid],Z250[playerid]);

			propertyOwner[property] = playerid;
			ownedtime[property] = MAX_OWNED_TIME;
			SaveProperties(playerid);
			if(oldowner < 999) SaveProperties(oldowner);

			format(strings, sizeof(strings), "--- %s (id: %d) bought %s for $%d.", giveplayer,playerid,propertyNames[property],propertyCurrentValue[property]);
			printf(strings);

			format(strings, sizeof(strings), "* You have purchased the %s!. You now own %d Properties.", propertyNames[property], GetNumberOfProperties(playerid));
			SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
			if(Payout[playerid] == 0){
				SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Currently your properties increase in value each minute, but do not generate a pay out.");
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Currently your properties pay out their profit each minute, but they do not increase in value.");
			}
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You can change the way the increase in value is handled by the commands /payout and /nopayout.");
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Type /help payout for more information.");

		    GetPlayerName(playerid, buyername, sizeof(buyername));

			if(amount > propertyCurrentValue[property]){
				format(strings, sizeof(strings), "* %s has bought the %s for $%d (actual value: $%d).", buyername,propertyNames[property],amount,propertyCurrentValue[property]);
			} else {
				format(strings, sizeof(strings), "* %s has bought the %s for $%d.", buyername,propertyNames[property],amount);
			}
			SendClientMessageToAll(COLOR_SYSTEM_GM , strings);

			for(new i=0; i<8; i++){
				m=i+1;
				format(strings, sizeof(strings), "property%d", m);
				dini_IntSet(udb_encode(playername), strings, propertyArray[playerid][i]);
				format(strings, sizeof(strings), "value%d", m);
				if(propertyArray[playerid][i] != 0){
					propertyID = propertyArray[playerid][i];
					dini_IntSet(udb_encode(playername), strings, propertyCurrentValue[propertyID]);
				} else {
					dini_IntSet(udb_encode(playername), strings, 0);
				}
			}

			if(oldowner != 999){
				GetPlayerName(oldowner, oldownername, sizeof(oldownername));
				for(new i=0; i<8; i++){
					m=i+1;
					format(strings, sizeof(strings), "property%d", m);
					dini_IntSet(udb_encode(oldownername), strings, propertyArray[oldowner][i]);
					format(strings, sizeof(strings), "value%d", m);
					if(propertyArray[playerid][i] != 0){
						propertyID = propertyArray[oldowner][i];
						dini_IntSet(udb_encode(oldownername), strings, propertyCurrentValue[propertyID]);
					} else {
						dini_IntSet(udb_encode(oldownername), strings, 0);
					}
				}
			}
			if (property == P_LSTOWN) {
				format(strings, sizeof(strings), "~y~Los Santos welcomes~n~their new mayor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_SFTOWN) {
				format(strings, sizeof(strings), "~y~San Fierro welcomes~n~their new mayor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_LVTOWN) {
				format(strings, sizeof(strings), "~y~Las Venturas welcomes~n~their new mayor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_SAGOVERN) {
				format(strings, sizeof(strings), "~y~San Andreas welcomes~n~their new governor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if((property == P_ANGELMED)  || (property == P_ELQMED)){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can now heal other players in your ambulance. Your own health will also increase automatically.");
				MedicalOfficer[playerid]=1;
				return 1;
			}
			if(property == P_FORTCARSONPD){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can now perform highway patrols and give speeders a ticket.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Use the police ranger parked at the head quaters for this, it is specially equiped for this task.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can start a highway patrol by issuing the command /patrol.");
				return 1;
			}

		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in a property checkpoint to /buy it.");
			return 1;
		}
	}
	return 1;
}

dcmd_creditbuy(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new property=999;
		new amount, m, propertyID, buyoutamount;
		new oldowner, oldownername[MAX_PLAYER_NAME];
		new buyername[256];
		new CashForBank;

		tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not enabled on this server!");
		    return 1;
		}

		if(IsPlayerInCheckpoint(playerid)) {
			property=PropertyCheckpointSelection(playerCheckpoint[playerid]);

			if (property == 999) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in a property checkpoint to /buy it.");
				return 1;
			}

			GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
			oldowner = 999;
			amount = propertyCurrentValue[property];
			if (propertyOwner[property] < 999) {
				amount = amount + floatround(floatmul(amount,floatdiv(BUYOUT_PERC,100)));
				amount = amount + floatround(floatmul(amount,floatdiv(CREDITCOST,100)));
				if (bank[playerid] < amount) {
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money on your bankaccount!");
					return 1;
				}
			} else {
				amount = amount + floatround(floatmul(amount,floatdiv(CREDITCOST,100)));
				if (bank[playerid] < amount) {
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money on your bankaccount!");
					return 1;
				}
			}

			if (propertyOwner[property] == playerid) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You already own this property.");
				return 1;
			}

            if(GetNumberOfProperties(playerid) >= MAX_OWNED_PROPERTIES) {
				format(strings, sizeof(strings), "* You cannot own more than %d properties.", MAX_OWNED_PROPERTIES);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
				return 1;
			}
			if (property == P_LSTOWN || property == P_SFTOWN || property == P_LVTOWN) {
				if(propertyOwner[P_SAGOVERN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already San Andreas Governor, you can't be mayor as well!");
					return 1;
				}
			}
			if (property == P_SAGOVERN){
				if(propertyOwner[P_LSTOWN] == playerid || propertyOwner[P_SFTOWN] == playerid || propertyOwner[P_LVTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be San Andreas Governor when you are already the mayor of a town!");
					return 1;
				}
			}
			if (property == P_LSTOWN) {
				if(propertyOwner[P_SFTOWN] == playerid || propertyOwner[P_LVTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be a mayor of two citys!");
					return 1;
				}
			}
			if (property == P_SFTOWN) {
				if(propertyOwner[P_LSTOWN] == playerid || propertyOwner[P_LVTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be a mayor of two citys!");
					return 1;
				}
			}
			if (property == P_LVTOWN) {
				if(propertyOwner[P_SFTOWN] == playerid || propertyOwner[P_LSTOWN] == playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't be a mayor of two citys!");
					return 1;
				}
			}

			if (propertyOwner[property] < 999) {
				if (ownedtime[property] > 0) {
					format(strings, sizeof(strings), "* You have to wait %d minutes before the %s becomes available.",ownedtime[property], propertyNames[property]);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
					return 1;
				} else {
				    buyoutamount=propertyCurrentValue[property];
					// TO-DO money scanner update
					if((GetPlayerMoney(propertyOwner[property]) + buyoutamount) > MAX_MONEY){
					    buyoutamount = MAX_MONEY - GetPlayerMoney(propertyOwner[property]);
					}
					format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d 's property was bought out.", amount, GetPlayerMoney(propertyOwner[property]), propertyOwner[property]);
					if(StatGivePlayerMoney(propertyOwner[property], buyoutamount, moneyreason)) {
						format (strings, sizeof(strings), "* Your property, the %s, has been bought out by %s (id: %d) for $%d. You received $%d.",propertyNames[property],giveplayer,playerid, amount, buyoutamount);
						SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
					}
					if(property == P_ANGELMED){
						if(propertyOwner[P_ELQMED] != propertyOwner[property]){
							SendClientMessage(propertyOwner[property], COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
							MedicalOfficer[propertyOwner[property]]=0;
						}
					}
					if(property == P_ELQMED){
						if(propertyOwner[P_ANGELMED] != propertyOwner[property]){
							SendClientMessage(propertyOwner[property], COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
							MedicalOfficer[propertyOwner[property]]=0;
						}
					}
					if(property == P_FORTCARSONPD){
						GetPlayerName(propertyOwner[property], oldownername, sizeof(oldownername));
						SendClientMessage(propertyOwner[property], COLOR_SYSTEM_GM , "* You can no longer perform highway patrols and give speeders a ticket.");
					    HighwayOnMission[propertyOwner[property]] = 0;
						format(strings, sizeof(strings),"* Player %s can no longer patrol the highways, you can roam freely over the highways without getting a ticket.",oldownername);
						SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
						OutOfRanger[propertyOwner[property]]=0;
						HighwayMission = 0;
						SetPlayerColor(propertyOwner[property],playerColors[propertyOwner[property]]);
					}
					oldowner = propertyOwner[property];
				}
			}

			propertyOwner[property] = playerid;
			ownedtime[property] = MAX_OWNED_TIME;
			SaveProperties(playerid);
			if(oldowner < 999) SaveProperties(oldowner);

			PlayerPlaySound(playerid,1058,X250[playerid],Y250[playerid],Z250[playerid]);

			GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);
			format(moneyreason, sizeof(moneyreason), "* Banked value decreased by $%d (old: $%d), because player-id %d bought a property", amount, bank[playerid], playerid);
			printf(strings);
			bank[playerid] -= amount;
			format(strings, sizeof(strings), "* You have purchased the %s using your credit card!. You now own %d Properties.", propertyNames[property], GetNumberOfProperties(playerid));
			SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
			format(strings, sizeof(strings), "* Your bankaccount decreased with $%d to $%d", amount, bank[playerid]);
			SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
			if(Payout[playerid] == 0){
				SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Currently your properties increase in value each minute, but do not generate a pay out.");
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Currently your properties pay out their profit each minute, but they do not increase in value.");
			}
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You can change the way the increase in value is handled by the commands /payout and /nopayout.");
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Type /help payout for more information.");

		    GetPlayerName(playerid, buyername, sizeof(buyername));

			format(strings, sizeof(strings), "* %s has used his creditcard to buy the %s for $%d (actual value: $%d).", buyername,propertyNames[property],amount,propertyCurrentValue[property]);
			SendClientMessageToAll(COLOR_SYSTEM_GM , strings);

			for(new i=0; i<8; i++){
				m=i+1;
				format(strings, sizeof(strings), "property%d", m);
				dini_IntSet(udb_encode(playername), strings, propertyArray[playerid][i]);
				format(strings, sizeof(strings), "value%d", m);
				if(propertyArray[playerid][i] != 0){
					propertyID = propertyArray[playerid][i];
					dini_IntSet(udb_encode(playername), strings, propertyCurrentValue[propertyID]);
				} else {
					dini_IntSet(udb_encode(playername), strings, 0);
				}
			}

			if(oldowner != 999){
				GetPlayerName(oldowner, oldownername, sizeof(oldownername));
				for(new i=0; i<8; i++){
					m=i+1;
					format(strings, sizeof(strings), "property%d", m);
					dini_IntSet(udb_encode(oldownername), strings, propertyArray[oldowner][i]);
					format(strings, sizeof(strings), "value%d", m);
					if(propertyArray[playerid][i] != 0){
						propertyID = propertyArray[oldowner][i];
						dini_IntSet(udb_encode(oldownername), strings, propertyCurrentValue[propertyID]);
					} else {
						dini_IntSet(udb_encode(oldownername), strings, 0);
					}
				}
			}

			if (property == P_LSTOWN) {
				format(strings, sizeof(strings), "~y~Los Santos welcomes~n~their new mayor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_SFTOWN) {
				format(strings, sizeof(strings), "~y~San Fierro welcomes~n~their new mayor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_LVTOWN) {
				format(strings, sizeof(strings), "~y~Las Venturas welcomes~n~their new mayor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_SAGOVERN) {
				format(strings, sizeof(strings), "~y~San Andreas welcomes~n~their new governor ~n~~r~%s!", buyername);
		        GameTextForAll(strings,5000,3);
			}

			if (propertyOwner[P_BANKADMIN] < 999) {
			    amount = amount - propertyCurrentValue[property];
    	        CashForBank = floatround(amount / 6);
		        format(moneyreason, sizeof(moneyreason), "* Money increased for %d by $%d because the player received creditcard commissions.", propertyOwner[P_BANKADMIN], CashForBank);
    		    StatGivePlayerMoney(propertyOwner[P_BANKADMIN], CashForBank, moneyreason);
  	    		format(strings, sizeof(strings), "* You received out of credit card commissions $%d.", CashForBank);
				SendClientMessage(propertyOwner[P_BANKADMIN], COLOR_SYSTEM_PM, strings);
			}

			if((property == P_ANGELMED)  || (property == P_ELQMED)){
				ownedtime[property] = 60;
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can now heal other players in your ambulance. Your own health will also increase automatically.");
				MedicalOfficer[playerid]=1;
				return 1;
			}
			if(property == P_FORTCARSONPD){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can now perform highway patrols and give speeders a ticket.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Use the police ranger parked at the head quaters for this, it is specially equiped for this task.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can start a highway patrol by issuing the command /patrol.");
				return 1;
			}

		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in a property checkpoint to /creditbuy it.");
			return 1;
		}
	}
	return 1;
}

dcmd_sell(playerid,params[])  {
	#pragma unused params
	new property=999;
	new giveback, m, propertyID;
	new sellername[256];
	if(logged[playerid] == 1){
		tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not enabled on this server!");
		    return 1;
		}

		if(IsPlayerInCheckpoint(playerid)) {
			property=PropertyCheckpointSelection(playerCheckpoint[playerid]);

			if (property == 999) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in a property checkpoint to /sell it.");
				return 1;
			}

            if(propertyOwner[property] == 999) {
				giveplayer = "";
			} else GetPlayerName(propertyOwner[property], giveplayer, sizeof(giveplayer));

            if (propertyOwner[property] != playerid) {
                format(strings, sizeof(strings), "* You don't own this property. Current owner is: %s", giveplayer);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
				return 1;
			}

            GetPlayerName(playerid, playername, sizeof(playername));

            giveback = propertyCurrentValue[property];

			PlayerPlaySound(playerid,1053,X250[playerid],Y250[playerid],Z250[playerid]);

			//Moved few lines forward (was after the next IF-statement - to give the correct number of owned properties in strings
			propertyOwner[property] = 999;
			ownedtime[property] = 0;
			SaveProperties(playerid);

			for(new i=0; i<8; i++){
				m=i+1;
				format(strings, sizeof(strings), "property%d", m);
				dini_IntSet(udb_encode(playername), strings, propertyArray[playerid][i]);
				format(strings, sizeof(strings), "value%d", m);
				if(propertyArray[playerid][i] != 0){
					propertyID = propertyArray[playerid][i];
					dini_IntSet(udb_encode(playername), strings, propertyCurrentValue[propertyID]);
				} else {
					dini_IntSet(udb_encode(playername), strings, 0);
				}
			}

			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d sold a property", giveback,GetPlayerMoney(playerid), playerid);
			if(StatGivePlayerMoney(playerid, giveback, moneyreason)) {

				format(strings, sizeof(strings), "--- %s (id: %d) sold %s for $%d.", giveplayer,playerid,propertyNames[property],giveback);
				printf(strings);

				format(strings, sizeof(strings), "* You have sold the %s for $%d!. You now own %d properties",propertyNames[property], giveback, GetNumberOfProperties(playerid));
				SendClientMessage(playerid, COLOR_MONEY_INC , strings);

				//New function when selling a property: message to all.
			    GetPlayerName(playerid, sellername, sizeof(sellername));

				format(strings, sizeof(strings), "* %s has sold the %s and received $%d.", sellername,propertyNames[property],giveback);
				SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
				SaveFile(playerid);
			}

			if (property == P_LSTOWN || property == P_SFTOWN || property == P_LVTOWN) {
				format(strings, sizeof(strings), "~b~%s has stepped down as mayor.", sellername);
		        GameTextForAll(strings,5000,3);
			}
			if (property == P_SAGOVERN) {
				format(strings, sizeof(strings), "~b~%s has stepped down as governor.", sellername);
		        GameTextForAll(strings,5000,3);
			}

			if(property == P_ANGELMED){
				if(propertyOwner[P_ELQMED] != playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
					MedicalOfficer[playerid]=0;
					return 1;
				}
			}
			if(property == P_ELQMED){
				if(propertyOwner[P_ANGELMED] != playerid){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
					MedicalOfficer[playerid]=0;
					return 1;
				}
			}
			if(property == P_FORTCARSONPD){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can no longer perform highway patrols and give speeders a ticket.");
			    HighwayOnMission[playerid] = 0;
				format(strings, sizeof(strings),"* Player %s can no longer patrol the highways, you can roam freely over the highways without getting a ticket.",playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
				OutOfRanger[playerid]=0;
				HighwayMission = 0;
				SetPlayerColor(playerid,playerColors[playerid]);
				return 1;
			}
		}
		else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in a property checkpoint to /sell it.");
			return 1;
		}
	}
	return 1;
}

dcmd_flog(playerid,params[])  {
	new index = 0;
	new giveback;
	new sellername[256];
	new propertyid, m, propertyID2;

	if(logged[playerid] == 1){
		tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not enabled on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

	    if (!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /flog [propertyid]. This will sell your property identified by [propertyid]");
			SendClientMessage(playerid, COLOR_CMD , "* for 10% of the retail value. You do not have to be in the corresponding checkpoint for this.");
			SendClientMessage(playerid, COLOR_CMD , "* When you sell the property using /sell in the checkpoint, you will get 25% of the retail value.");
			return 1;
		}
 		propertyid = strval(tmps1);

		if(propertyid >= MAX_PROPERTIES || propertyid <= 0) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid property id. You can check the id's of your properties with /myproperties.");
			return 1;
		}

        if(propertyOwner[propertyid] == 999) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* That property is not owned, so it can not be flogged.");
			return 1;
		} else {
			GetPlayerName(propertyOwner[propertyid], giveplayer, sizeof(giveplayer));
		}

        if (propertyOwner[propertyid] != playerid) {
            format(strings, sizeof(strings), "* You don't own this property. Current owner is: %s", giveplayer);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}

        GetPlayerName(playerid, playername, sizeof(playername));

        giveback = floatround(float(propertyCurrentValue[propertyid])*(float(FLOG_PROP_PERC)/100));

		PlayerPlaySound(playerid,1085,X250[playerid],Y250[playerid],Z250[playerid]);


		//Moved few lines forward (was after the next IF-statement - to give the correct number of owned properties in strings
		propertyOwner[propertyid] = 999;
		ownedtime[propertyid] = 0;
		SaveProperties(playerid);

		for(new i=0; i<8; i++){
			m=i+1;
			format(strings, sizeof(strings), "property%d", m);
			dini_IntSet(udb_encode(playername), strings, propertyArray[playerid][i]);
			format(strings, sizeof(strings), "value%d", m);
			if(propertyArray[playerid][i] != 0){
				propertyID2 = propertyArray[playerid][i];
				dini_IntSet(udb_encode(playername), strings, propertyCurrentValue[propertyID2]);
			} else {
				dini_IntSet(udb_encode(playername), strings, 0);
			}
		}

		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d sold a property", giveback, GetPlayerMoney(playerid), playerid);
		if(StatGivePlayerMoney(playerid, giveback, moneyreason)) {

			format(strings, sizeof(strings), "--- %s (id: %d) flogged %s for $%d.", giveplayer,playerid,propertyNames[propertyid],giveback);
			printf(strings);

			format(strings, sizeof(strings), "* You have flogged the %s for $%d! (%d percent of it's value). You now own %d properties", propertyNames[propertyid], giveback, FLOG_PROP_PERC, GetNumberOfProperties(playerid));
			SendClientMessage(playerid, COLOR_MONEY_INC , strings);

			//New function when selling a property: message to all.
		    GetPlayerName(playerid, sellername, sizeof(sellername));
			format(strings, sizeof(strings), "* %s has flogged the %s and received $%d.", sellername,propertyNames[propertyid],giveback);
			SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
			SaveFile(playerid);
		}

		if (propertyid == P_LSTOWN || propertyid == P_SFTOWN || propertyid == P_LVTOWN) {
			format(strings, sizeof(strings), "~b~%s has stepped down as mayor.", sellername);
	        GameTextForAll(strings,5000,3);
		}
		if (propertyid == P_SAGOVERN) {
			format(strings, sizeof(strings), "~b~%s has stepped down as governor.", sellername);
	        GameTextForAll(strings,5000,3);
		}

		if(propertyid == P_ANGELMED){
			if(propertyOwner[P_ELQMED] != playerid){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
				MedicalOfficer[playerid]=0;
				return 1;
			}
		}
		if(propertyid == P_ELQMED){
			if(propertyOwner[P_ANGELMED] != playerid){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can no longer heal other players in an ambulance, and your health will no longer increase.");
				MedicalOfficer[playerid]=0;
				return 1;
			}
		}
		if(propertyid == P_FORTCARSONPD){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can no longer perform highway patrols and give speeders a ticket.");
		    HighwayOnMission[playerid] = 0;
			format(strings, sizeof(strings),"* Player %s can no longer patrol the highways, you can roam freely over the highways without getting a ticket.",playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			OutOfRanger[playerid]=0;
			HighwayMission = 0;
			SetPlayerColor(playerid,playerColors[playerid]);
			return 1;
		}
	}
	return 1;
}


dcmd_property(playerid,params[])  {
	new index = 0;
    new propertyid;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		tmps1 = strtok(params, index);
	    if (!strlen(tmps1) && !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /property [propertyid]. This will show all information about this property.");
			return 1;
		}
 		propertyid = strval(tmps1);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Property info:");
		if(propertyid >= MAX_PROPERTIES || propertyid <= 0) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid property id.");
			return 1;
		}
		if (propertyOwner[propertyid] < 999) {
			GetPlayerName(propertyOwner[propertyid], giveplayer, sizeof(giveplayer));
			format(strings, sizeof(strings), "* %s (id: %d). Owner: %s.", propertyNames[propertyid], propertyid, giveplayer);
		}
		else format(strings, sizeof(strings), "* %s (id: %d). Owner: None.", propertyNames[propertyid], propertyid);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
	}
	return 1;
}

dcmd_properties(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* Use the following commands to view the properties, devided by location:");
		SendClientMessage(playerid, COLOR_MENU , "* For Los Santos: /lsprop1 /lsprop2 /lsprop3");
		SendClientMessage(playerid, COLOR_MENU , "* For The Badlands: /blprop1 /blprop2");
		SendClientMessage(playerid, COLOR_MENU , "* For San Fierro: /sfprop1 /sfprop2");
		SendClientMessage(playerid, COLOR_MENU , "* For The Desert: /deprop1 /deprop2 /deprop3");
		SendClientMessage(playerid, COLOR_MENU , "* For Las Venturas: /lvprop1 /lvprop2 /lvprop3");
		SendClientMessage(playerid, COLOR_MENU , "* For Roaming properties: /roprop1");
        SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________");
	}
	return 1;
}

dcmd_lsprop1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "______________ Los Santos Properties 1 __________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 21. Didier Sachs *** 23. Madd Dogg's Mansion");
		SendClientMessage(playerid, COLOR_MENU , "* 36. Los Santos Police Station *** 38. San Andreas Bank");
		SendClientMessage(playerid, COLOR_MENU , "* 39. Los Santos Motel *** 43. Administrative Bank Office");
		SendClientMessage(playerid, COLOR_MENU , "* 44. Internet Service Provider *** 45. Insurance Office");
		SendClientMessage(playerid, COLOR_MENU , "* 46. Foreign Affairs Office *** 47. LS Cargo Transportation Station");
		SendClientMessage(playerid, COLOR_MENU , "* 48. Adv_Rifle's Transport Company *** 49. LS Cargo Docks");
		SendClientMessage(playerid, COLOR_MENU , "* 50. LS Container Terminal *** 51. Market place *** 52. Thijs Donut Shop");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Los Santos properties in /lsprop2 __________________");
	}
	return 1;
}

dcmd_lsprop2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "______________ Los Santos Properties 2 __________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 53. Le Regalle Theatre *** 54. Sex Cinema *** 55. The Royal Theatre");
		SendClientMessage(playerid, COLOR_MENU , "* 56. Movie Studio *** 57. Television Studio");
		SendClientMessage(playerid, COLOR_MENU , "* 58. Sandra's Pleasure Dome *** 59. Tom Cross Residence");
		SendClientMessage(playerid, COLOR_MENU , "* 60. El Pacman Residence *** 61. George Truly Residence");
		SendClientMessage(playerid, COLOR_MENU , "* 62. Mel Tripson Residence *** 63. Arnold Whitenagger Residence");
		SendClientMessage(playerid, COLOR_MENU , "* 64. Russel Flow Residence *** 65. Sylvester Drylone Residence");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Los Santos properties in /lsprop3 __________________");
	}
	return 1;
}

dcmd_lsprop3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "______________ Los Santos Properties 3 __________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 66. Frank Ditrina Residence *** 67. Bill Fence Residence");
		SendClientMessage(playerid, COLOR_MENU , "* 68. Oprah Lintrey Residence *** 69. Rob the Gardener Residence");
		SendClientMessage(playerid, COLOR_MENU , "* 70. Bill Glitton Residence *** 173. SA Taxi Company");
		SendClientMessage(playerid, COLOR_MENU , "* 180. War Memorial museum *** 181. LS Sex shop");
		SendClientMessage(playerid, COLOR_MENU , "* 182. The Bahamas Apartments *** 195. Gasstation idlewood");
		SendClientMessage(playerid, COLOR_MENU , "* 197. Los Santos Town Hall");
		SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________");
	}
	return 1;
}

dcmd_blprop1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}


		SendClientMessage(playerid, COLOR_MENU , "______________ Badlands Properties 1 ____________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 35. P Hat Liquor *** 37. Betting Place *** 42. San Andreas Beer Brewery");
		SendClientMessage(playerid, COLOR_MENU , "* 71. Pig Farm *** 72. Solarin Industries HQ *** 73. Dillmore Gas Station");
		SendClientMessage(playerid, COLOR_MENU , "* 74. The Welcome Pump *** 75. Palomino Creek Dick's Sounds");
		SendClientMessage(playerid, COLOR_MENU , "* 76. Palomino Creek Library *** 77. Bio Enginering");
		SendClientMessage(playerid, COLOR_MENU , "* 78. Montgomery Gas Station *** 79. Sprunk Factory");
		SendClientMessage(playerid, COLOR_MENU , "* 80. Admins Hideout *** 81. Blueberry Truck Terminal *** 82. Cottin Farm");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Badlands properties in /blprop2 ____________________");

	}
	return 1;
}

dcmd_blprop2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "______________ Badlands Properties 2 ____________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 83. Logging Camp *** 84. Flint Wheat Ranch *** 85. RS Haul");
		SendClientMessage(playerid, COLOR_MENU , "* 86. Fallen Tree Industrial Complex *** 87. Center Parks Hunting Cabines");
		SendClientMessage(playerid, COLOR_MENU , "* 88. Spacy Grass Farm *** 89. San Andreas Junkyard");
		SendClientMessage(playerid, COLOR_MENU , "* 90. Angel Pine Motel *** 91. Sawmill *** 92. Whetstone Gas Sation");
		SendClientMessage(playerid, COLOR_MENU , "* 93. Flint County Motel *** 94. Angel Pine Gas Station");
		SendClientMessage(playerid, COLOR_MENU , "* 95. Nitro Chemicals *** 96. Tobacco Farm *** 97. Diary Farm");
		SendClientMessage(playerid, COLOR_MENU , "* 183. Angel Pine Medical Center *** 196. Gasstation flint county");
		SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________");
	}
	return 1;
}

dcmd_sfprop1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ San Fierro Properties 1 __________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 9. Jizzy's Club *** 13. Wang Cars *** 22. Zombotech Corp.");
		SendClientMessage(playerid, COLOR_MENU , "* 25. San Fierro Hotel *** 32. Zero RC *** 33. Easter Basin");
		SendClientMessage(playerid, COLOR_MENU , "* 34. Otto's Auto's *** 98. SA Radio Broadcast Company");
		SendClientMessage(playerid, COLOR_MENU , "* 99. Retirement Home *** 100. SA FBI Office");
		SendClientMessage(playerid, COLOR_MENU , "* 101. SA Dirtring Arena Corporation *** 102. Avispa Country Club");
		SendClientMessage(playerid, COLOR_MENU , "* 103. Hippy Shopper *** 104. SA Art Museum *** 105. San Fierro Town Hall");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More San Fierro properties in /sfprop2 __________________");

	}
	return 1;
}

dcmd_sfprop2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "______________ San Fierro Properties 2 __________________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 106. SA County Hospital *** 107. Federal Mint *** 108. SF City Tours");
		SendClientMessage(playerid, COLOR_MENU , "* 109. Queens Hotel *** 110. The Biffin Bridge Hotel *** 111. Corba Dojo");
		SendClientMessage(playerid, COLOR_MENU , "* 112. Drugs Laboratory *** 113. Public Transportation");
		SendClientMessage(playerid, COLOR_MENU , "* 113. Public Transportation *** 114. SA DEA Office");
		SendClientMessage(playerid, COLOR_MENU , "* 115. SF Container Terminal *** 116. Vehicle In and Export");
		SendClientMessage(playerid, COLOR_MENU , "* 117. Solarin Industries Factory *** 118. San Fierro Gas Station");
		SendClientMessage(playerid, COLOR_MENU , "* 119. Insanity Food Services *** 120. SA CIA Office *** 194. Gasstation Juniper Hallow");
		SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________________");

	}
	return 1;
}

dcmd_deprop1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ Desert Properties 1 ______________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 26.Pole Dancing Experience *** 31. The Sherman Dam ");
		SendClientMessage(playerid, COLOR_MENU , "* 41. UFO Restaurant *** 121. Bayside Yacht Club *** 122. Jay's Diner");
		SendClientMessage(playerid, COLOR_MENU , "* 123. CIA Safe House *** 124. Fort Carson Hotel *** 125. HI K69 Radiostation");
		SendClientMessage(playerid, COLOR_MENU , "* 126. Drive Inn Cinema *** 127. The Bowled Spot *** 128. The King Ring");
		SendClientMessage(playerid, COLOR_MENU , "* 129. Lookout Point *** 130. Astronomy Center *** 131. Regular Tom");
		SendClientMessage(playerid, COLOR_MENU , "* 132. Las Barrancas Gift Shop *** 133. Las Barrancas Tee Pee Motel");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Desert properties in /deprop2 ______________________");
	}
	return 1;
}

dcmd_deprop2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ Desert Properties 2 ______________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 134. Nitro's Crib *** 135. Bait Shop *** 136. El Quebrados Hotel");
		SendClientMessage(playerid, COLOR_MENU , "* 137. El Quebrados Gas Station *** 138. The Lost Pueblo Museum");
		SendClientMessage(playerid, COLOR_MENU , "* 139. Valle Ocultado Tee Pee Motel *** 140. Air Transportation Museum");
		SendClientMessage(playerid, COLOR_MENU , "* 141. Las Payasadas Chicken Restaurant *** 142. Bone County Gas Station");
		SendClientMessage(playerid, COLOR_MENU , "* 143. SA Oil Refinnery *** 144. Hunter Quarry *** 145. Shooting Range");
		SendClientMessage(playerid, COLOR_MENU , "* 176. Jos's DJ Control Room *** 177. Admin weapons storeroom");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Desert properties in /deprop3 ______________________");
	}
	return 1;
}

dcmd_deprop3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}

		SendClientMessage(playerid, COLOR_MENU , "______________ Desert Properties 3 ______________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 184. El Quebrados Medical Center *** 185. Old Gold Mine");
		SendClientMessage(playerid, COLOR_MENU , "* 186. Killerfist Vortex Rentals *** 193. Gasstation Tierra Nobada");
		SendClientMessage(playerid, COLOR_MENU , "* 198. San Andreas Governor Office *** 200. Highway Patrol Head Quaters");
		SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________");

	}
	return 1;
}

dcmd_lvprop1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ Las Venturas Properties 1 ________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 1. Four Dragons Casino *** 2. Sex Shop *** 3. Bar");
		SendClientMessage(playerid, COLOR_MENU , "* 4. Caligula Casino *** 12. Strip Club *** 14. Emerald Isle");
		SendClientMessage(playerid, COLOR_MENU , "* 14. Emerald Isle *** 15. The Visage *** 20. Club");
		SendClientMessage(playerid, COLOR_MENU , "* 24. Las Venturas Airport *** 27. City Planning Department");
		SendClientMessage(playerid, COLOR_MENU , "* 28. Rock Hotel *** 29. Clowns Pocket Hotel *** 30. Las Venturas Stadium");
		SendClientMessage(playerid, COLOR_MENU , "* 40. Caxoperro Bodybuilding *** 146. Anthony v Leeuwenhoek College");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Las Venturas properties in /lvprop2 ________________");
	}
	return 1;
}

dcmd_lvprop2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ Las Venturas Properties 2 ________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 147. SA Motorbike Driving School *** 148. SA Customs Department");
		SendClientMessage(playerid, COLOR_MENU , "* 149. Meatfactory *** 150. LV Cargo Terminal");
		SendClientMessage(playerid, COLOR_MENU , "* 151. Aircraft Control Center *** 152. Jos's Waterhoses");
		SendClientMessage(playerid, COLOR_MENU , "* 153. Rim and Shine *** 154. LV Gas Station *** 155. Starbucks Casino");
		SendClientMessage(playerid, COLOR_MENU , "* 156. Behind The Strip Motel *** 157. LV Souvenir Shop");
		SendClientMessage(playerid, COLOR_MENU , "* 158. Center Parks Gambling Cottages *** 159. Yellow Bell Golf Club");
		SendClientMessage(playerid, COLOR_MENU , "* 160. Public Transport Maintenance *** 161. Aztec Motel");
		SendClientMessage(playerid, COLOR_MENU , "_______________ More Las Venturas properties in /lvprop3 ________________");
	}
	return 1;
}

dcmd_lvprop3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ Las Venturas Properties 3 __________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 162. La Conca Motel *** 163. Mideval Casino Hotel *** 164. The Old Cowboy");
		SendClientMessage(playerid, COLOR_MENU , "* 165. The Kicking Heels *** 166. The Royal Casino *** 167. Come-a-lot Casino");
		SendClientMessage(playerid, COLOR_MENU , "* 168. Cargo Harbour Depot *** 169. Dr. Pheeley Confession Center");
		SendClientMessage(playerid, COLOR_MENU , "* 170. Chuckup Office *** 171. Final Build Construction");
		SendClientMessage(playerid, COLOR_MENU , "* 172. San Andreas Used Car *** 189. Gasstation emerald isle");
		SendClientMessage(playerid, COLOR_MENU , "* 190. Gasstation behind camel toe *** 191. Gasstation besides camel toe");
		SendClientMessage(playerid, COLOR_MENU , "* 192. Gasstation Spinybed *** 199. Las Venturas Town Hall");
		SendClientMessage(playerid, COLOR_MENU , "___________________________________________________________________________");
	}
	return 1;
}

dcmd_roprop1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "properties");
		if (strval(tmps1) == 0) {
		    		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Properties are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________ Roaming Properties 1 _____________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 5. Zip Shop *** 6. Binco Shop *** 7. Tatoo Parlor");
		SendClientMessage(playerid, COLOR_MENU , "* 8. Botique *** 10. The Well Stacked Pizza *** 11. Victim Shop");
		SendClientMessage(playerid, COLOR_MENU , "* 16. Sub Urban *** 17. Pro Laps *** 18. Burger Shot");
		SendClientMessage(playerid, COLOR_MENU , "* 19. Cluckin' Bell");
		SendClientMessage(playerid, COLOR_MENU , "_________________________________________________________________________");
	}
	return 1;
}

dcmd_bwmelee(playerid,params[])  {
    new MoneyReceived;
	new property=999;
	new index=0;
	new weaponid;
	if(logged[playerid] == 1){
 		property = P_SHOOTING;
	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}
		tmps1 = strtok(params, index);
		if (!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwmelee [weaponid]. This will buy you a melee weapon.");
			return 1;
		}
		weaponid = strval(tmps1);
		if (IsPlayerInCheckpoint(playerid) == 0 || playerCheckpoint[playerid] != CP_AMMU) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in an Ammunation shop to purchase weapons.");
			return 1;
		}
		if (GetPlayerMoney(playerid) < weaponCostMelee[weaponid]) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
		}
		if (weaponid < 0 || weaponid > 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid weapon number.");
			return 1;
		}

		GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
		format(strings, sizeof(strings), "--- %s (id: %d) purchased %s for $%d.",giveplayer,playerid,weaponNamesMelee[weaponid],weaponCostMelee[weaponid]);
		printf(strings);
		format (strings, sizeof(strings), "* You purchased %s on your spawn for $%d.", weaponNamesMelee[weaponid],weaponCostMelee[weaponid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);

		GivePlayerWeapon(playerid, weaponIDsMelee[weaponid], 1);

		dini_IntSet(udb_encode(giveplayer), "weapon1", weaponIDsMelee[weaponid]);
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a weapon.",weaponCostMelee[weaponid], GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, -weaponCostMelee[weaponid], moneyreason);
		melee[playerid] = weaponIDsMelee[weaponid];

    	// Do we have a weapons dealer? If so, then he should get 25% of purchases.
    	if (propertyOwner[property] != 999) {
		    GetPlayerName(propertyOwner[property], playername, sizeof(playername));
		    MoneyReceived = floatround(weaponCostMelee[weaponid] / 4);
		    format(moneyreason, sizeof(moneyreason), "* Money increased by $%d for player-id %d, because player-id %d bought a spawnweapon.",MoneyReceived, propertyOwner[property], playerid);
			StatGivePlayerMoney(propertyOwner[property], MoneyReceived, moneyreason);
			format (strings, sizeof(strings), "* You received $%d because a weapon purchase was made.",MoneyReceived, playername);
			SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
		}
	}
	return 1;
}

dcmd_bwpistol(playerid,params[])  {
	new index = 0;
    new ammo;
    new MoneyReceived;
	new property=999;
	new weaponid;

	if(logged[playerid] == 1){
 		property = P_SHOOTING;

	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwpistol [weaponid] [ammo]. This will buy you pistol [weaponid] with [ammo] at spawn.");
			return 1;
		}
		weaponid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwpistol [weaponid] [ammo]. This will buy you pistol [weaponid] with [ammo] at spawn.");
			return 1;
		}
		ammo = strval(tmps1);

		if(IsPlayerInCheckpoint(playerid)==0 || playerCheckpoint[playerid]!=CP_AMMU) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in an Ammunation shop to purchase weapons.");
			return 1;
		}
		if(GetPlayerMoney(playerid) < weaponCostPistols[weaponid]*ammo) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
		}
		if(weaponid < 0 || weaponid > 2){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid weapon number.");
			return 1;
		}

		if(ammo > MAX_AMMO){
			format (strings, sizeof(strings), "* You cannot buy more than %d ammo.", MAX_AMMO);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}

		if(ammo < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey what are you trying to pull here?");
			return 1;
		}

		GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
		format(strings, sizeof(strings), "--- %s (id: %d) purchased %s (ammo: %d) for $%d.",giveplayer,playerid,weaponNamesPistols[weaponid],ammo,weaponCostPistols[weaponid]*ammo);
		printf(strings);
		format (strings, sizeof(strings), "* You purchased %s (ammo: %d) on your spawn for $%d.",weaponNamesPistols[weaponid],ammo,weaponCostPistols[weaponid]*ammo);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);

		GivePlayerWeapon(playerid, weaponIDsPistols[weaponid], ammo);
		pistol[playerid] = weaponIDsPistols[weaponid];
		pistolammo[playerid] = ammo;

		dini_IntSet(udb_encode(giveplayer), "weapon2", weaponIDsPistols[weaponid]);
		tmps1 = dini_Get(udb_encode(giveplayer), "ammo2");
		dini_IntSet(udb_encode(giveplayer), "ammo2", strval(tmps1)+ammo);
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a weapon.",weaponCostPistols[weaponid]*ammo, GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, -weaponCostPistols[weaponid]*ammo, moneyreason);

    	// Do we have a weapons dealer? If so, then he should get 25% of purchases.
    	if (propertyOwner[property] != 999) {
		    GetPlayerName(propertyOwner[property], playername, sizeof(playername));
		    MoneyReceived = floatround(weaponCostMelee[weaponid] / 4);
		    format(moneyreason, sizeof(moneyreason), "* Money increased by $%d for player-id %d, because player-id %d bought a spawnweapon.",MoneyReceived, propertyOwner[property], playerid);
			StatGivePlayerMoney(propertyOwner[property], MoneyReceived, moneyreason);
			format (strings, sizeof(strings), "* You received $%d because a weapon purchase was made.",MoneyReceived, playername);
			SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
		}
	}
	return 1;
}

dcmd_bwshotgun(playerid,params[])  {
	new index = 0;
    new ammo;
    new MoneyReceived;
	new property=999;
	new weaponid;
	if(logged[playerid] == 1){
 		property = P_SHOOTING;

	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwshotgun [weaponid] [ammo]. This will buy you shotgun [weaponid] with [ammo] at spawn.");
			return 1;
		}
		weaponid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwshotgun [weaponid] [ammo]. This will buy you shotgun [weaponid] with [ammo] at spawn.");
			return 1;
		}
		ammo = strval(tmps1);

		if(IsPlayerInCheckpoint(playerid)==0 || playerCheckpoint[playerid]!=CP_AMMU) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in an Ammunation shop to purchase weapons.");
			return 1;
		}
		if(GetPlayerMoney(playerid) < weaponCostShotguns[weaponid]*ammo) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
		}
		if(weaponid < 0 || weaponid > 2){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid weapon number.");
			return 1;
		}
		if(ammo > MAX_AMMO){
			format (strings, sizeof(strings), "* You cannot buy more than %d ammo.", MAX_AMMO);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}
		if(ammo < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey what are you trying to pull here?");
			return 1;
		}

		GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
		format(strings, sizeof(strings), "--- %s (id: %d) purchased %s (ammo: %d) for $%d.", giveplayer,playerid,weaponNamesShotguns[weaponid],ammo,weaponCostShotguns[weaponid]*ammo);
		printf(strings);
		format (strings, sizeof(strings), "* You purchased %s (ammo: %d) on your spawn for $%d.",weaponNamesShotguns[weaponid],ammo,weaponCostShotguns[weaponid]*ammo);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);

		GivePlayerWeapon(playerid, weaponIDsShotguns[weaponid], ammo);
		shotgun[playerid] = weaponIDsShotguns[weaponid];
		shotgunammo[playerid] = ammo;

		dini_IntSet(udb_encode(giveplayer), "weapon3", weaponIDsShotguns[weaponid]);
		tmps1 = dini_Get(udb_encode(giveplayer), "ammo3");
		dini_IntSet(udb_encode(giveplayer), "ammo3", strval(tmps1)+ammo);
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a weapon.", weaponCostShotguns[weaponid]*ammo, GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, -weaponCostShotguns[weaponid]*ammo, moneyreason);

    	// Do we have a weapons dealer? If so, then he should get 25% of purchases.
    	if (propertyOwner[property] != 999) {
		    GetPlayerName(propertyOwner[property], playername, sizeof(playername));
		    MoneyReceived = floatround(weaponCostMelee[weaponid] / 4);
		    format(moneyreason, sizeof(moneyreason), "* Money increased by $%d for player-id %d, because player-id %d bought a spawnweapon.", MoneyReceived, propertyOwner[property], playerid);
			StatGivePlayerMoney(propertyOwner[property], MoneyReceived, moneyreason);
			format (strings, sizeof(strings), "* You received $%d because a weapon purchase was made.",MoneyReceived, playername);
			SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
		}
	}
	return 1;
}

dcmd_bwsmg(playerid,params[])  {
	new index = 0;
    new ammo;
    new MoneyReceived;
	new property=999;
	new weaponid;
	if(logged[playerid] == 1){
 		property = P_SHOOTING;

	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwsmg [weaponid] [ammo]. This will buy you sub-mg [weaponid] with [ammo] at spawn.");
			return 1;
		}
		weaponid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwsmg [weaponid] [ammo]. This will buy you sub-mg [weaponid] with [ammo] at spawn.");
			return 1;
		}
		ammo = strval(tmps1);

		if(IsPlayerInCheckpoint(playerid)==0 || playerCheckpoint[playerid]!=CP_AMMU) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in an Ammunation shop to purchase weapons.");
			return 1;
		}
		if(GetPlayerMoney(playerid) < weaponCostSMGs[weaponid]*ammo) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
		}
		if(weaponid < 0 || weaponid > 2){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid weapon number.");
			return 1;
		}
		if(ammo > MAX_AMMO){
			format (strings, sizeof(strings), "* You cannot buy more than %d ammo.", MAX_AMMO);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}
		if(ammo < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey what are you trying to pull here?");
			return 1;
		}

		GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
		format(strings, sizeof(strings), "--- %s (id: %d) purchased %s (ammo: %d) for $%d.", giveplayer,playerid,weaponNamesSMGs[weaponid],ammo,weaponCostSMGs[weaponid]*ammo);
		printf(strings);
		format (strings, sizeof(strings), "* You purchased %s (ammo: %d) on your spawn for $%d.",weaponNamesSMGs[weaponid],ammo,weaponCostSMGs[weaponid]*ammo);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);

		GivePlayerWeapon(playerid, weaponIDsSMGs[weaponid], ammo);
		smg[playerid] = weaponIDsSMGs[weaponid];
		smgammo[playerid] = ammo;

		dini_IntSet(udb_encode(giveplayer), "weapon4", weaponIDsSMGs[weaponid]);
		tmps1 = dini_Get(udb_encode(giveplayer), "ammo4");
		dini_IntSet(udb_encode(giveplayer), "ammo4", strval(tmps1)+ammo);
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a weapon.", weaponCostSMGs[weaponid]*ammo, GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, -weaponCostSMGs[weaponid]*ammo, moneyreason);

    	// Do we have a weapons dealer? If so, then he should get 25% of purchases.
    	if (propertyOwner[property] != 999) {
		    GetPlayerName(propertyOwner[property], playername, sizeof(playername));
		    MoneyReceived = floatround(weaponCostMelee[weaponid] / 4);
		    format(moneyreason, sizeof(moneyreason), "* Money increased by $%d for player-id %d, because player-id %d bought a spawnweapon.", MoneyReceived, propertyOwner[property], playerid);
			StatGivePlayerMoney(propertyOwner[property], MoneyReceived, moneyreason);
			format (strings, sizeof(strings), "* You received $%d because a weapon purchase was made.",MoneyReceived, playername);
			SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
		}

	}
	return 1;
}

dcmd_bwrifle(playerid,params[])  {
	new index= 0;
    new ammo;
    new MoneyReceived;
	new property=999;
	new weaponid;
	if(logged[playerid] == 1){
 		property = P_SHOOTING;

	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwrifle [weaponid] [ammo]. This will buy you rifle [weaponid] with [ammo] at spawn.");
			return 1;
		}
		weaponid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwrifle [weaponid] [ammo]. This will buy you rifle [weaponid] with [ammo] at spawn.");
			return 1;
		}
		ammo = strval(tmps1);

		if(IsPlayerInCheckpoint(playerid)==0 || playerCheckpoint[playerid]!=CP_AMMU) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be in an Ammunation shop to purchase weapons.");
			return 1;
		}
		if(GetPlayerMoney(playerid) < weaponCostRifles[weaponid]*ammo) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
		}
		if(weaponid < 0 || weaponid > 2){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid weapon number.");
			return 1;
		}
		if(ammo > MAX_AMMO){
			format (strings, sizeof(strings), "* You cannot buy more than %d ammo.", MAX_AMMO);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}
		if(ammo < 1) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey what are you trying to pull here?");
			return 1;
		}

		GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
		format(strings, sizeof(strings), "--- %s (id: %d) purchased %s (ammo: %d) for $%d.", giveplayer,playerid,weaponNamesRifles[weaponid],ammo,weaponCostRifles[weaponid]*ammo);
		printf(strings);
		format (strings, sizeof(strings), "* You purchased %s (ammo: %d) on your spawn for $%d.",weaponNamesRifles[weaponid],ammo,weaponCostRifles[weaponid]*ammo);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);

		GivePlayerWeapon(playerid, weaponIDsRifles[weaponid], ammo);
		rifle[playerid] = weaponIDsRifles[weaponid];
		rifleammo[playerid] = ammo;

		dini_IntSet(udb_encode(giveplayer), "weapon5", weaponIDsRifles[weaponid]);
		tmps1 = dini_Get(udb_encode(giveplayer), "ammo5");
		dini_IntSet(udb_encode(giveplayer), "ammo5", strval(tmps1)+ammo);
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a weapon.", weaponCostRifles[weaponid]*ammo, GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, -weaponCostRifles[weaponid]*ammo, moneyreason);

    	// Do we have a weapons dealer? If so, then he should get 25% of purchases.
    	if (propertyOwner[property] != 999) {
		    GetPlayerName(propertyOwner[property], playername, sizeof(playername));
		    MoneyReceived = floatround(weaponCostMelee[weaponid] / 4);
		    format(moneyreason, sizeof(moneyreason), "* Money increased by $%d for player-id %d, because player-id %d bought a spawnweapon.", MoneyReceived, propertyOwner[property], playerid);
			StatGivePlayerMoney(propertyOwner[property], MoneyReceived, moneyreason);
			format (strings, sizeof(strings), "* You received $%d because a weapon purchase was made.",MoneyReceived, playername);
			SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PM , strings);
		}
	}
	return 1;
}

dcmd_bwgift(playerid,params[])  {
	new index=0;
	new weaponid;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}
		tmps1 = strtok(params, index);
		if (!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /bwgift [giftid]. This will buy you a gift - see /giftlist for the gifts for sale.");
			return 1;
		}
		weaponid = strval(tmps1);
		if (IsPlayerInCheckpoint(playerid) == 0 || playerCheckpoint[playerid] != CP_LVSOURV) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be at the LV Giftshop shop to purchase a gift.");
			return 1;
		}
		if (GetPlayerMoney(playerid) < weaponCostGift[weaponid]) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
			return 1;
		}
		if (weaponid < 0 || weaponid > 2){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid gift number.");
			return 1;
		}

		GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
		format(strings, sizeof(strings), "--- %s (id: %d) purchased %s for $%d.",giveplayer,playerid,weaponNamesGift[weaponid],weaponCostGift[weaponid]);
		printf(strings);
		format (strings, sizeof(strings), "* You purchased %s on your spawn for $%d.", weaponNamesGift[weaponid],weaponCostGift[weaponid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);

		GivePlayerWeapon(playerid, weaponIDsGift[weaponid], 1);

		dini_IntSet(udb_encode(giveplayer), "weapon6", weaponIDsGift[weaponid]);
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d bought a weapon.",weaponCostGift[weaponid], GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, -weaponCostGift[weaponid], moneyreason);
		gift[playerid] = weaponIDsGift[weaponid];
	}
	return 1;
}

dcmd_weaplist(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* /bwmelee: 0. Knife - 1500$ *** 1. Bat - 2000$");
		SendClientMessage(playerid, COLOR_MENU , "* /bwpistol: 0. Pistol - 20$ *** 1. Silenced Pistol - 30$ *** 2. Desert Eagle - 60$");
		SendClientMessage(playerid, COLOR_MENU , "* /bwshotgun: 0. Shotgun - 70$ *** 1. Sawn-off - 120$ *** 2. Combat Shotgun - 150$");
		SendClientMessage(playerid, COLOR_MENU , "* /bwsmg: 0. Tec9 - 50$ *** 1. Micro Uzi - 80$ *** 2. MP5 - 150$");
		SendClientMessage(playerid, COLOR_MENU , "* /bwrifle: 0. AK47 - 250$ *** 1. M4 - 300$");
		SendClientMessage(playerid, COLOR_MENU , "______________________________________________________________________________________________");
	}
	return 1;
}

dcmd_giftlist(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Spawn weapons are not allowed on this server!");
		    return 1;
		}
		SendClientMessage(playerid, COLOR_MENU , "______________________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* /bwgift: 0. Purple dildo - 5000$ *** 1. White dildo - 4500$ *** 2. Flowers - 10000$");
		SendClientMessage(playerid, COLOR_MENU , "______________________________________________________________________________________________");
	}
	return 1;
}

dcmd_skydive(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    new high;
	    new Float:temp;

	    tmps1 = dini_Get(FILE_SETTINGS, "skydive");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Skydive is not allowed on this server!");
		    return 1;
		}

		if(IsPlayerInCasino(playerid) == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while in a casino!");
		    return 1;
		}

		if(DMplayer[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot enter a skydive when you are waiting for a death match to start");
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* or when you are participating in one.");
		    return 1;
		}

		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}

		if(admindived[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already skydiving. Enjoy the ride.");
		    return 1;
		}

		if(Z250[playerid] > 900.00000){
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey, watch out for the ceiling! You can go outside if you want to skydive.");
		    return 1;
		}

	    GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);

     	if (GetPlayerState(playerid) == PLAYER_STATE_NONE || GetPlayerState(playerid) == PLAYER_STATE_WASTED) return 1;

		tmps1 = strtok(params, index);
		if (!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /skydive [100-1000]. This let's you skydive at a hight of [100-1000] meters.");
			return 1;
		}
 		high = strval(tmps1);

	    if(100 > high || high > 1000)
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /skydive [100-1000]. This let's you skydive at a hight of [100-1000] meters.");
		else {
			if (GetPlayerMoney(playerid) > 499+high){
				// TO-DO money scanner update
				format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d skydived.", 500+high, GetPlayerMoney(playerid), playerid);
				StatGivePlayerMoney(playerid, -500-high, moneyreason);
				GivePlayerWeapon(playerid, 46, 1);
				if(X250[playerid] >= LVBoundaries[0] && X250[playerid] <= LVBoundaries[2] && Y250[playerid] >= LVBoundaries[1] && Y250[playerid] <= LVBoundaries[3]){
					temp=Z250[playerid] + high;
				    if( temp > 899.9){
				        high=floatround(floatsub(899.0,Z250[playerid]));
					}
				}
				SetPlayerPos(playerid, X250[playerid], Y250[playerid], Z250[playerid]+high);
				SendClientMessage(playerid, COLOR_SYSTEM_PM , "* SKYDIVE!");
				format(strings, sizeof(strings), "--- %s (id: %d) skydived by %d.", giveplayer,playerid,high);
				printf(strings);
			}
			else
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
		}
	}
	return 1;
}

dcmd_admindive(playerid,params[])  {
	new index = 0;
	new cash;

	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /admindive [playerid]. This will send [playerid] into a skydive without parachute.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			if(IsAdmin(giveplayerid)) {
			    if(adminlevel[giveplayerid] > adminlevel[playerid]){
					format(strings, sizeof(strings), "* You can't send %s (id: %d) into a deathdive, since your admin level is lower than your victims.", giveplayer,giveplayerid);
					SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
					SendClientMessage(playerid, COLOR_ADMIN_PM , "* Instead you will be diving in your victims place. Have a nice trip.");
			        giveplayerid = playerid;
				}
			}
			//Reset weapons in case the player has a parachute present. Spawn weapons will be regenerated after the death
			ResetPlayerWeapons(giveplayerid);
			//Flush the money to zero
			cash=GetPlayerMoney(giveplayerid);
			format(strings, sizeof(strings), "--- Money reset for %s (id: %d) because %s (id: %d) issued deathdive.", giveplayer, giveplayerid, sendername,playerid);
			printf(strings);
			StatGivePlayerMoney(giveplayerid, -cash, moneyreason);
			SetPlayerPos(giveplayerid, 928.9201, 1614.7795, 600.0000);
			admindived[giveplayerid] = 1;
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* SKYDIVE!");
			format(strings, sizeof(strings), "--- %s (id: %d) send %s (id: %d) into deathdive.", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* You skydived %s (id: %d).", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s (id: %d) has send you into this skydive.", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_getprop(playerid,params[])  {
	new index = 0;
	new TotalValue;
	if(logged[playerid] == 1 && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /getprop [playerid]. This will show you the poperties [playerid] owes.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

	    new propertycounter = 0;
        for(new i=0; i<MAX_PROPERTIES; i++) {
			if (propertyOwner[i] == giveplayerid) {
		    	if (propertycounter == 0) {
    	    		format(strings, sizeof(strings), "* Player %s (id: %d) owes the following properties:", giveplayer,giveplayerid);
					SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				}
        	    propertycounter++;
				format(strings, sizeof(strings), "* %d. %s with current value $%d.", i,propertyNames[i],propertyCurrentValue[i]);
				TotalValue+=propertyCurrentValue[i];
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			}
		}
		if (propertycounter == 0 ) {
    	 	format(strings, sizeof(strings), "* Player %s (id: %d) does not owe a property.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
		} else {
    	 	format(strings, sizeof(strings), "* Total amount of properties: %d with the total value of $ %d.", propertycounter, TotalValue);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
		}
	}
	return 1;
}

dcmd_giveloc(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1 && adminlevel[playerid] > 1) {
	    SendClientMessage(playerid, COLOR_ADMIN_PM , "* Huidige coordinaten:");
		format(strings, sizeof(strings), "X: %f", X250[playerid]);
		SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
		format(strings, sizeof(strings), "Y: %f", Y250[playerid]);
		SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
		format(strings, sizeof(strings), "Z: %f", Z250[playerid]);
		SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
	}
	return 1;
}

dcmd_para(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "parachute");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Parachute's are not allowed on this server!");
		    return 1;
		}

		if(admindived[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, no easy way out.");
		    return 1;
		}

		GetPlayerName(playerid, giveplayer, MAX_PLAYER_NAME);

	    if (GetPlayerState(playerid) == PLAYER_STATE_NONE || GetPlayerState(playerid) == PLAYER_STATE_WASTED) return 1;

	    if (GetPlayerMoney(playerid) > 499) {
//			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d bought a parachute.", 500, GetPlayerMoney(playerid), playerid);
			StatGivePlayerMoney(playerid, -500, moneyreason);
			GivePlayerWeapon(playerid, 46, 1);
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Parachute purchased.");
			format(strings, sizeof(strings), "--- %s (id: %d) purchased parachute.", giveplayer,playerid);
			printf(strings);
		}
		else
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You don't have enough money!");
	}
	return 1;
}

dcmd_me(playerid,params[])  {
	new character[256], newcharacter[256], replaced, temp;
	if(logged[playerid] == 1 && IsPlayerConnected(playerid)){
		if(MuteAll > 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* The admins have closed the public chat for now. Use PM or groupchat to communicate.");
			return 1;
		}
		strmid(tmps1, params, 0, strlen(params));
 		GetPlayerName(playerid, playername, sizeof(playername));
	    if(!strlen(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /me [action]. Sends a message of your [action] to all.");
		}
		else {
		    if(muted[playerid] == 0){
				format(strings, sizeof(strings), "");
				for(new i=0; i<(strlen(tmps1)); i++) {
					//next character
					strmid(character, tmps1, i, i+1, 2);
				    replaced = 0;
				    for(new x=0;x<27;x++){
				        if(strcmp(character,alphabet[x],true)==0){
							format(newcharacter, sizeof(newcharacter), "%s",calphabet[x]);
							replaced = 1;
						}
					}
					if(replaced == 0){
					    format(newcharacter, sizeof(newcharacter), "%s", character);
					}
				    format(strings, sizeof(strings),"%s%s", strings, newcharacter);
				}
				format(strings, sizeof(strings), "%s %s", playername, strings);
				printf(strings);
				if(IsAdmin(playerid) && AdminPlayer[playerid] == 1){
					SendClientMessageToAll(COLOR_ADMIN , strings);
				} else {
					if(OwnPlayerColorChosen[playerid] == 0){
						SendClientMessageToAll(playerColors[playerid] , strings);
					} else {
						temp=PlayerColorsChoice[OwnPlayerColor[playerid]];
						SendClientMessageToAll(temp , strings);
					}

				}
			}
		}
	}
	return 1;
}

dcmd_query(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /query [playerid]. Starts a private conversation with [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (giveplayerid == 255) {
		    query[playerid] = 255;
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Your query is turned off.");
		    return 1;
		}

		if (IsPlayerConnected(giveplayerid)) {
			query[playerid] = giveplayerid;

			GetPlayerName(playerid, sendername, sizeof(sendername));
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

			format(strings, sizeof(strings), "--- %s (id: %d) sets query to %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);

			format(strings, sizeof(strings), "* Now you can send !messages to %s (id: %d).", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_IRC , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
		}
	}
	return 1;
}

dcmd_setpay(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "driverservice");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Driver service is not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /setpay [amount]. Sets your taxi-fee for driving people around.");
			return 1;
		}
		moneys = strval(tmps1);

		if(moneys < 0) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Hey what are you trying to pull here?");
			return 1;
		}

		if(moneys > MAX_TAXI_FEE) {
			format(strings, sizeof(strings),"* You cannot set your taxi fee higher than $%d", MAX_TAXI_FEE);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			return 1;
		}

		payment[playerid] = moneys;

		GetPlayerName(playerid, sendername, sizeof(sendername));

		format(strings, sizeof(strings), "--- %s (id: %d) sets payment for his driver services to $%d.", sendername,playerid,moneys);
		printf(strings);

		format(strings, sizeof(strings), "* You set your fee for your driver services to $%d.", moneys);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
	}
	return 1;
}


dcmd_getpay(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "driverservice");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Driver service is not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /getpay [playerid]. Shows the money you earned from [playerid] since his last payout.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

		format(strings, sizeof(strings), "* Payment for %s (id: %d) driver services is $%d.", giveplayer,giveplayerid,payment[giveplayerid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
	}
	return 1;
}

dcmd_jail(playerid,params[])  {
	new index = 0;
    new minutes;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /jail [playerid] [minutes]. This will jail [playerid] for [minutes] minutes.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /jail [playerid] [minutes]. This will jail [playerid] for [minutes] minutes.");
			return 1;
		}
		minutes = strval(tmps1);
		if (minutes > 10) {
		    format(strings, sizeof(strings), "* You can only jail for %d minutes", MAX_JAILTIME);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
			minutes = MAX_JAILTIME;
		}

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));

			jailed[giveplayerid] = 1;
			jailtime[giveplayerid] = minutes;
			dini_IntSet(udb_encode(giveplayer), "jailed", 1);
			dini_IntSet(udb_encode(giveplayer), "jailtime", minutes);

			SetPlayerInterior(giveplayerid,10);
			SetPlayerPos(giveplayerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
			if(jailcelcounter < 3) {
			    jailcelcounter++;
			} else {
			    jailcelcounter=0;
			}
			format(strings, sizeof(strings), "--- %s (id: %d) jailed by %s (id: %d) for %d minutes.",sendername,playerid,giveplayer,giveplayerid, minutes);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) is jailed for %d minutes.", giveplayer,giveplayerid, minutes);
			SendClientMessageToAll(COLOR_ADMIN_GM , strings);
			format(strings, sizeof(strings), "* You are jailed by %s (id: %d) for %d minutes.", sendername,playerid, minutes);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_j(playerid,params[])  {
	return dcmd_jail(playerid,params);
}

dcmd_unjail(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /unjail [playerid]. This will release [playerid] from prison and reset his jailtime.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
  			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));

			jailed[giveplayerid] = 0;
			jailtime[giveplayerid] = 0;
			dini_IntSet(udb_encode(giveplayer), "jailed", 0);
			dini_IntSet(udb_encode(giveplayer), "jailtime", 0);

			SetPlayerInterior(giveplayerid,0);
			SetPlayerPos(giveplayerid,-1619.7941,692.6453,7.1875);

			format(strings, sizeof(strings), "--- %s (id: %d) released by %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) is released.", giveplayer,giveplayerid);
			SendClientMessageToAll(COLOR_ADMIN_GM , strings);
			format(strings, sizeof(strings), "* You were released by %s (id: %d).", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_unj(playerid,params[])  {
	return dcmd_unjail(playerid,params);
}

dcmd_mute(playerid,params[])  {
	new index = 0;
	new minutes;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD  , "* USAGE: /mute [playerid] [minutes]. This will mute player [playerid]. He won't be able to speak.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD  , "* USAGE: /mute [playerid] [minutes]. This will mute player [playerid]. He won't be able to speak.");
			return 1;
		}
		minutes = strval(tmps1);

		if (minutes > 10) {
			SendClientMessage(playerid, COLOR_ADMIN_PW , "* You can only mute for 10 minutes");
			minutes = 10;
		}

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			dini_IntSet(udb_encode(giveplayer), "muted", 1);
			muted[giveplayerid] = 1;
			mutetime[giveplayerid] = minutes;
			format(strings, sizeof(strings), "--- %s (id: %d) is muted %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) is muted.", giveplayer,giveplayerid);
			SendClientMessageToAll(COLOR_ADMIN_GM , strings);
			format(strings, sizeof(strings), "* You are muted by %s (id: %d) for %d minutes.", sendername,playerid,minutes);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_unmute(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /unmute [playerid]. This will unmute [playerid]. He will be able to speak again.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
  			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			dini_IntSet(udb_encode(giveplayer), "muted", 0);
			muted[giveplayerid] = 0;
			mutetime[giveplayerid]=0;
			format(strings, sizeof(strings), "--- %s (id: %d) unmuted %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) is unmuted.", giveplayer,giveplayerid);
			SendClientMessageToAll(COLOR_ADMIN_GM , strings);
			format(strings, sizeof(strings), "* You are unmuted by %s (id: %d).", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}

	}
	return 1;
}

dcmd_heal(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /heal [playerid]. This will heal [playerid] completely.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			SetPlayerHealth(giveplayerid, 100.0);
			god[playerid] = 0;
			format(strings, sizeof(strings), "--- %s (id: %d) healed %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) was healed.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* You were healed by %s (id: %d).", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_h(playerid,params[])  {
	return dcmd_heal(playerid,params);
}

dcmd_god(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /god [playerid]. This will make [playerid] invincable.");
			return 1;
		}
/*		if(enablegod == 0) {
		    SendClientMessage(playerid, COLOR_ADMIN_PW , "* God mode is disabled.");
			return 1;
		}*/
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			god[giveplayerid] = 1;
			SetPlayerHealth(giveplayerid, 99999);
			format(strings, sizeof(strings), "--- %s (id: %d) invincibled %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) is now invincible.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s (id: %d) made you invincible.", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_murder(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /murder [playerid]. This will kill [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			SetPlayerHealth(giveplayerid, 0.0);
			god[giveplayerid] = 0;
			format(strings, sizeof(strings), "--- %s (id: %d) murdered %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) is now dead.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s (id: %d) killed you.", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}

	}
	return 1;
}

dcmd_freeze(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /freeze [playerid]. This will freeze [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			TogglePlayerControllable(giveplayerid, 0);
			format(strings, sizeof(strings), "--- %s (id: %d) freezes %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) was frozen.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* You were frozen by %s (id: %d).", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_f(playerid,params[])  {
	return dcmd_freeze(playerid,params);
}

dcmd_unfreeze(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /unfreeze [playerid]. This will unfreeze [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			TogglePlayerControllable(giveplayerid, 1);
			format(strings, sizeof(strings), "--- %s (id: %d) unfreezes %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* %s (id: %d) was unfrozen.", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* You were unfrozen by %s (id: %d).", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_unf(playerid,params[])  {
	return dcmd_unfreeze(playerid,params);
}

dcmd_givemoney(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /givemoney [playerid] [amount]. Makes money [amount] and gives it to [playerid]");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /givemoney [playerid] [amount]. Makes money [amount] and gives it to [playerid]");
			return 1;
		}
 		moneys = strval(tmps1);

 		if(moneys < 0) {
			SendClientMessage(playerid, COLOR_ADMIN_PW , "* You cannot give a negative amount of money");
			return 1;
		}

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			playermoney = GetPlayerMoney(playerid);
			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d received admin money.", moneys, GetPlayerMoney(giveplayerid), giveplayerid);
			if(StatGivePlayerMoney(giveplayerid, moneys, moneyreason)) {
				format(strings, sizeof(strings), "--- %s (id: %d) made $%d for %s (id: %d).", sendername,playerid,moneys,giveplayer,giveplayerid);
				printf(strings);
				format(strings, sizeof(strings), "* You have made money for %s (id: %d), $%d.", giveplayer,giveplayerid, moneys);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* You are granted $%d from %s (id: %d).", moneys, sendername, playerid);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				tmps1 = dini_Get(FILE_SETTINGS, "maxmoney");
				format(strings, sizeof(strings), "* You cannot give $%d to %s (id: %d). Maximum money reached. Maximum amount to give: $%d.", moneys,giveplayer,giveplayerid, strval(tmps1)-GetPlayerMoney(giveplayerid));
				SendClientMessage(playerid, COLOR_ADMIN_PW, strings);
			}
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_gm(playerid,params[])  {
	return dcmd_givemoney(playerid,params);
}

dcmd_giveweapon(playerid,params[])  {
	new index = 0;
	new idx = 0;
    new ammo;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /give [playerid] [weaponid] [ammo]. This will give weapon [weaponid] to [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /giveweapon [playerid] [weaponid] [ammo]. This will give weapon [weaponid] to [playerid].");
			return 1;
		}
 		moneys = strval(tmps1);

 		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /giveweapon [playerid] [weaponid] [ammo]. This will give weapon [weaponid] to [playerid].");
			return 1;
		}
 		ammo = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			GivePlayerWeapon(giveplayerid, moneys, ammo);
			format(strings, sizeof(strings), "--- %s (id: %d) gave weapon (id: %d) (ammo: %d) to %s (id: %d).", sendername,playerid,moneys,ammo,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* You have weapon (id: %d) (ammo: %d) to %s (id: %d).", moneys,ammo,giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* You were granted weapon (id: %d) (ammo: %d) from %s (id: %d).", moneys,ammo,sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			if( X250[giveplayerid] >= LVBoundaries[0] &&
				X250[giveplayerid] <= LVBoundaries[2] &&
				Y250[giveplayerid] >= LVBoundaries[1] &&
				Y250[giveplayerid] <= LVBoundaries[3] &&
				!IsAdmin(giveplayerid) && LVPartytime == 0){
		        tmps3 = dini_Get(FILE_SETTINGS, "lvweaponcheat");
				for (new i=0;i<47;i++) {
				    if (moneys == strval(strtok(tmps3, idx, ','))) {
						format(strings, sizeof(strings), "* Player %s is currently within LV city limits and you have given him/her a forbidden weapon within LV limits.", giveplayer);
						SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
						SendClientMessage(playerid, COLOR_ADMIN_PW , "* Either remove that weapon or issue /lvplaytime to lift the forbidden weapon-embargo for 5 minutes.");
						SendClientMessage(giveplayerid, COLOR_ADMIN_PW , "* Do not use that weapon within LV city limits unless the admin issue lv party time.");
						break;
					}
				}
			}
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_gw(playerid,params[])  {
	return dcmd_giveweapon(playerid,params);
}

dcmd_disarm(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /disarm [playerid]. This removes all weapons from [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			ResetPlayerWeapons(giveplayerid);
			format(strings, sizeof(strings), "--- %s (id: %d) removed weapons from %s (id: %d).", sendername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* You removed all weapons from %s (id: %d).", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s (id: %d) removed all your weapons.", sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_locs(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		SendClientMessage(playerid, COLOR_MENU ,"_______________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU ,"* LS: 1. Groove St. *** 2. Airport *** 3. Highest Building *** 4. Lighthouse");
		SendClientMessage(playerid, COLOR_MENU ,"* SF: 5. Doherty *** 6. Airport *** 7. Highest Building *** 8. Golden Gate");
		SendClientMessage(playerid, COLOR_MENU ,"* LV: 9. Four Dragons *** 10. Airport *** 11. Highest Building");
		SendClientMessage(playerid, COLOR_MENU ,"* OTHER: 12. Chilliad *** 13. Abandoned Airport *** 14. Area 69");
        SendClientMessage(playerid, COLOR_MENU ,"_______________________________________________________________________________");
	}
	return 1;
}

dcmd_saveloc(playerid,params[])  {
	new index = 0;
	new location[256];
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /saveloc [name]");
			return 1;
		}

		if(strlen(params) > 1) {
		    strmid(location, params, strlen(params)-strlen(tmps1), strlen(params));
			format(strings,sizeof(strings),"{%f,%f,%f}, //%s", X250[playerid], Y250[playerid], Z250[playerid], location);

		    if (!dini_Exists(FILE_LOCATIONS)) {
				dini_Create(FILE_LOCATIONS);
			}
			dini_Set(FILE_LOCATIONS, location, strings);
			format(strings,sizeof(strings),"Location %s saved to %s", location, FILE_LOCATIONS);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
		}
	}
	return 1;
}

dcmd_tp(playerid,params[])  {
	new index = 0;
	new locname[256];
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /tp [playerid] [locid]. This teleports [playerid] to [locid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /tp [playerid] [locid]. This teleports [playerid] to [locid].");
			return 1;
		}
 		moneys = strval(tmps1);

 		if (moneys < 1 || moneys > 14) {
 			SendClientMessage(playerid, COLOR_ADMIN_PW , "* Invalid location id.");
			return 1;
		}

		if (IsPlayerConnected(giveplayerid)) {
		    SetPlayerInterior(giveplayerid, 0);
		    if (moneys == 1) {
				format(locname, sizeof(locname), "LS Groove St");
                SetPlayerPos(giveplayerid, 2492.9375,-1670.4402,13.3359);
			}
			if (moneys == 2) {
				format(locname, sizeof(locname), "LS Airport");
                SetPlayerPos(giveplayerid, 1925.1957,-2426.8733,13.5391);
			}
			if (moneys == 3) {
				format(locname, sizeof(locname), "LS Highest Building");
                SetPlayerPos(giveplayerid, 1546.1326,-1354.6786,329.4790);
			}
			if (moneys == 4) {
				format(locname, sizeof(locname), "LS Lighthouse");
                SetPlayerPos(giveplayerid, 154.0820,-1938.4050,3.7734);
			}
			if (moneys == 5) {
				format(locname, sizeof(locname), "SF Doherty");
                SetPlayerPos(giveplayerid, -2026.0696,175.2042,28.8359);
			}
			if (moneys == 6) {
				format(locname, sizeof(locname), "SF Airport");
                SetPlayerPos(giveplayerid, -1281.1655,-166.1917,14.1484);
			}
			if (moneys == 7) {
				format(locname, sizeof(locname), "SF Highest Building");
                SetPlayerPos(giveplayerid, -1753.8291,885.4835,295.8750);
			}
			if (moneys == 8) {
				format(locname, sizeof(locname), "SF Golden Gate");
                SetPlayerPos(giveplayerid, -2678.8230,1595.1827,217.2739);
			}
			if (moneys == 9) {
				format(locname, sizeof(locname), "LV Four Dragons");
                SetPlayerPos(giveplayerid, 2030.2551,1007.9247,10.8203);
			}
			if (moneys == 10) {
				format(locname, sizeof(locname), "LV Airport");
                SetPlayerPos(giveplayerid, 1525.6610,1594.5865,10.8203);
			}
			if (moneys == 11) {
				format(locname, sizeof(locname), "LV Highest Building");
                SetPlayerPos(giveplayerid, 2057.1145,2435.5623,165.6172);
			}
			if (moneys == 12) {
				format(locname, sizeof(locname), "Chilliad");
                SetPlayerPos(giveplayerid, -2321.2866,-1637.9414,483.7031);
			}
			if (moneys == 13) {
				format(locname, sizeof(locname), "Abandoned Airport");
                SetPlayerPos(giveplayerid, 324.9738,2520.6030,16.6942);
			}
			if (moneys == 14) {
				format(locname, sizeof(locname), "Area 69");
                SetPlayerPos(giveplayerid, 213.6413,1904.4032,17.6406);
			}
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			format(strings, sizeof(strings), "--- %s (id: %d) teleported %s (id: %d) to location id %d.", sendername,playerid,giveplayer,giveplayerid, moneys);
			printf(strings);
			format(strings, sizeof(strings), "* You teleported %s (id: %d) to %s (id: %d).", giveplayer,giveplayerid,locname,moneys);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* You are teleported to %s by %s (id: %d).", locname,sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		if (!IsPlayerConnected(giveplayerid)) {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_cartp(playerid,params[])  {
	new index = 0;
	new locname[256];
	new VehicleID,GroupID;
	new Float:Xloc,Float:Yloc,Float:Zloc;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {

		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can only teleport in a vehicle to a different location when you are in a vehicle.");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a vehicle can request a car teleport.");
			return 1;
		}
		VehicleID=GetPlayerVehicleID(playerid);
		if(VehicleID >= 219 && VehicleID < 254){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* This function can only be used when in a car or truck or on a bike.");
	  	    return 1;
		}
		GroupID=WhichVehicleGroup(VehicleID);
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /cartp [locid]. This teleports playerid to [locid].");
			return 1;
		}
 		moneys = strval(tmps1);
 		if (moneys < 1 || moneys > 14) {
 			SendClientMessage(playerid, COLOR_ADMIN_PW , "* Invalid location id.");
			return 1;
		}
	    if (moneys == 1) {
			format(locname, sizeof(locname), "LS Groove St");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 2492.9375,-1670.4402,13.3359);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 2) {
			format(locname, sizeof(locname), "LS Airport");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 1925.1957,-2426.8733,13.5391);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 3) {
			format(locname, sizeof(locname), "LS Highest Building");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 1546.1326,-1354.6786,329.4790);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 4) {
			format(locname, sizeof(locname), "LS Lighthouse");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 154.0820,-1938.4050,3.7734);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 5) {
			format(locname, sizeof(locname), "SF Doherty");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, -2026.0696,175.2042,28.8359);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 6) {
			format(locname, sizeof(locname), "SF Airport");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, -1281.1655,-166.1917,14.1484);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 7) {
			format(locname, sizeof(locname), "SF Highest Building");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, -1753.8291,885.4835,295.8750);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 8) {
			format(locname, sizeof(locname), "SF Golden Gate");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, -2678.8230,1595.1827,217.2739);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 9) {
			format(locname, sizeof(locname), "LV Four Dragons");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 2030.2551,1007.9247,10.8203);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 10) {
			format(locname, sizeof(locname), "LV Airport");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 1525.6610,1594.5865,10.8203);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 11) {
			format(locname, sizeof(locname), "LV Highest Building");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 2057.1145,2435.5623,165.6172);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 12) {
			format(locname, sizeof(locname), "Chilliad");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, -2321.2866,-1637.9414,483.7031);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 13) {
			format(locname, sizeof(locname), "Abandoned Airport");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
		    SetVehiclePos(VehicleID, 324.9738,2520.6030,16.6942);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		if (moneys == 14) {
			format(locname, sizeof(locname), "Area 69");
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
            SetVehiclePos(VehicleID, 213.6413,1904.4032,17.6406);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
		}
		GetPlayerPos(playerid,Xloc,Yloc,Zloc);
		CarXPos[playerid] = Xloc;
		CarYPos[playerid] = Yloc;
		CarZPos[playerid] = Zloc;
		Xsec[playerid] = Xloc;
		Ysec[playerid] = Yloc;
		Zsec[playerid] = Zloc;

		GetPlayerName(playerid, sendername, sizeof(sendername));
		format(strings, sizeof(strings), "--- %s (id: %d) teleported himself in vehicle to location id %d.", sendername,playerid, moneys);
		printf(strings);
		format(strings, sizeof(strings), "* You teleported in your vehicle to %s.", locname);
		SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
	}
	return 1;
}

dcmd_tpto(playerid,params[])  {
	new index = 0;
	new telename[MAX_PLAYER_NAME];
	new teleid;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /tpto [playerid] [to playerid]. This teleports [playerid] to [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /tpto [playerid] [to playerid]. This teleports [playerid] to [playerid].");
			return 1;
		}
 		teleid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid) && IsPlayerConnected(teleid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			GetPlayerName(teleid, telename, sizeof(telename));
			SetPlayerPos(giveplayerid, X250[teleid],Y250[teleid],Z250[teleid]+2.0);
			format(strings, sizeof(strings), "--- %s (id: %d) teleported %s (id: %d) to %s (id: %d)", sendername,playerid,giveplayer,giveplayerid,telename,teleid);
			printf(strings);
			format(strings, sizeof(strings), "* You teleported %s (id: %d) to %s (id: %d).", giveplayer,giveplayerid,telename,teleid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* You are teleported to %s (id: %d) by %s (id: %d).", telename,teleid,sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		if (!IsPlayerConnected(giveplayerid)) {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
		if (!IsPlayerConnected(teleid)) {
			format(strings, sizeof(strings), "* %d is not an active player.", teleid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}


dcmd_cargoto(playerid,params[])  {
	new index = 0;
	new VehicleID,GroupID;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can only teleport in a vehicle to a different location when you are in a vehicle.");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a vehicle can request a car teleport.");
			return 1;
		}
		VehicleID=GetPlayerVehicleID(playerid);
		if(VehicleID >= 219 && VehicleID < 254){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* This function can only be used when in a car or truck or on a bike.");
	  	    return 1;
		}
		GroupID=WhichVehicleGroup(VehicleID);
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /cargoto [playerid]. This will teleport you in a vehicle to [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);
		if(IsPlayerConnected(giveplayerid)) {
			if(Z250[giveplayerid] > 800){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* The player you are teleporting to, is most likely inside a building.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Since it is not possible to teleport in a vehicle inside a building, the operation is halted.");
		  	    return 1;
			}
	        GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, playername, sizeof(sendername));
			if(GroupID == 0)SetPlayerWorldBounds(playerid,324.9738,324.9738,2520.6030,2520.6030);
			SetVehiclePos(VehicleID, X250[giveplayerid]+5, Y250[giveplayerid]+5, Z250[giveplayerid] + 5);
			SetCameraBehindPlayer(playerid);
		    if(GroupID == 0){
				Teleporting[playerid]=1;
		    	SetTimer("ResetPlayerBounds",400,0);
		    }
			format(strings, sizeof(strings), "--- %s (id: %d) teleported himself to %s (id: %d)", playername,playerid,giveplayer,giveplayerid);
			printf(strings);
			format(strings, sizeof(strings), "* You teleported yourself to %s (id: %d).", giveplayer,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM, strings);
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW, strings);
		}
	}
	return 1;
}

dcmd_deluser(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
	    tmps1 = strtok(params, index);

 		GetPlayerName(playerid, playername, sizeof(playername));
	    if(!strlen(tmps1))
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /deluser [playername]. This will delete [playername] userfile.");

		else {
			if (dini_Exists(udb_encode(tmps1))) {
				dini_Remove(udb_encode(tmps1));
    				format(strings, sizeof(strings), "--- %s (id: %d) deleted user %s from db.", playername,playerid,tmps1);
				printf(strings);
				format(strings, sizeof(strings), "* User %s deleted from db.", tmps1);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			}
			else {
				format(strings, sizeof(strings), "* %s no such account.", tmps1);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
			}
		}
	}
	return 1;
}

dcmd_setmoney(playerid,params[])  {
	new index = 0;
    new oldmoneys;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setmoney [playerid] [amount]. This sets the money of [playerid] to [amount].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setmoney [playerid] [amount]. This sets the money of [playerid] to [amount].");
			return 1;
		}
 		moneys = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			oldmoneys = GetPlayerMoney(giveplayerid);
			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money changed with $%d (old: $%d), because player-id %d 's money was set by an admin.", -oldmoneys+moneys, GetPlayerMoney(giveplayerid), giveplayerid);
			if(StatGivePlayerMoney(giveplayerid, -oldmoneys+moneys, moneyreason)) {
				format(strings, sizeof(strings), "--- %s (id: %d) sets %s (id: %d) money to $%d.", sendername,playerid,giveplayer,giveplayerid,moneys);
				printf(strings);
				format(strings, sizeof(strings), "* You set amount of money from %s (id: %d) to $%d.", giveplayer,giveplayerid,moneys);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* You now have $%d, set by %s (id: %d).", moneys,sendername,playerid);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				tmps1 = dini_Get(FILE_SETTINGS, "maxmoney");
				format(strings, sizeof(strings), "* You cannot set money higher than $%d.", strval(tmps1));
				SendClientMessage(playerid, COLOR_ADMIN_PW, strings);
			}
		}
		else {
		    format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_setbank(playerid,params[])  {
	new index = 0;
 	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setbank [playerid] [amount]. This sets the money on the bank of [playerid] to [amount].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setbank [playerid] [amount]. This sets the money on the bank of [playerid] to [amount].");
			return 1;
		}
 		moneys = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			bank[giveplayerid] = moneys;
			format(strings, sizeof(strings), "--- %s (id: %d) sets %s (id: %d) bank balance to $%d.", sendername,playerid,giveplayer,giveplayerid,moneys);
			printf(strings);
			format(strings, sizeof(strings), "* You set the balance of %s (id: %d) to $%d in bank.", giveplayer,giveplayerid,moneys);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* Your bank balance is now $%d, set by %s (id: %d).", moneys,sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		}
		else {
		    format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_setbounty(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {

		tmps1 = dini_Get(FILE_SETTINGS, "bounty");

		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_ADMIN_PW , "* Bounties are not allowed on this server!");
		    return 1;
		}

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setbounty [playerid] [amount]. Sets the bounty on player [playerid] to [amount].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setbounty [playerid] [amount]. Sets the bounty on player [playerid] to [amount].");
			return 1;
		}
 		moneys = strval(tmps1);

		if (moneys < 1) {
			SendClientMessage(playerid, COLOR_ADMIN_PW , "* Hey what are you trying to pull here?");
			return 1;
		}

		if (IsPlayerConnected(giveplayerid)) {
			GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			GetPlayerName(playerid, sendername, sizeof(sendername));
			bounty[giveplayerid] = moneys;
			format(strings, sizeof(strings), "--- %s (id: %d) sets %s (id: %d) bounty to $%d.", sendername,playerid,giveplayer,giveplayerid,moneys);
			printf(strings);
			format(strings, sizeof(strings), "* You set a bounty on %s (id: %d) of $%d.", giveplayer,giveplayerid,moneys);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* Your bounty is now to $%d, set by %s (id: %d).", moneys,sendername,playerid);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s has a $%d bounty put on his head from %s (total: $%d).", giveplayer, moneys, sendername, bounty[giveplayerid]);
			SendClientMessageToAll(COLOR_ADMIN_GM , strings);
		}
		else {
		    format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_removeadmin(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /removeadmin [playerid]. This removes active player [playerid] from admins.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
		GetPlayerName(playerid, playername, sizeof(playername));

		if (IsPlayerConnected(giveplayerid)) {
			if (IsAdmin(giveplayerid) && !IsPlayerAdmin(giveplayerid)) {
				if (dini_Exists(udb_encode(giveplayer))) {
					dini_IntSet(udb_encode(giveplayer), "admin", 0);
					adminlevel[giveplayerid] = 0;
				} else {
					format(strings, sizeof(strings), "* %s no such account.", giveplayer);
					SendClientMessage(playerid, COLOR_ADMIN_PW , strings);

					return 1;
				}
				format(strings, sizeof(strings), "--- %s (id: %d) removes player %s (id: %d) from admins.", playername,playerid,giveplayer,giveplayerid);
				printf(strings);
				format(strings, sizeof(strings), "* You removed %s (id: %d) from admins.", giveplayer, giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* You were removed from admins by %s (id: %d).", playername, playerid);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				format(strings, sizeof(strings), "* Player %s (id: %d) is not an admin.", playername, playerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
			}

		} else {
				format(strings, sizeof(strings), "* %d is not an active player. For offline removal, use /setuserint [playername] admin 0.", giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
  		}
	}
	return 1;
}

dcmd_radmin(playerid,params[])  {
	return dcmd_removeadmin(playerid,params);
}

dcmd_setadmin(playerid,params[])  {
	new index = 0;
	new level = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setadmin [playerid] [level(1-3)]. This makes normal player [playerid] into [level] admin.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)){
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setadmin [playerid] [level(1-3)]. This makes normal player [playerid] into [level] admin.");
			return 1;
		}
		level = strval(tmps1);
		if (level <= 0 && level > MAX_ADMIN_LEVEL) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setadmin [playerid] [level(1-3)]. This makes normal player [playerid] into [level] admin.");
			return 1;
		}

		level = strval(tmps1);

		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

		if (IsPlayerConnected(giveplayerid)) {
		    if (dini_Exists(udb_encode(giveplayer))) {
				if (logged[giveplayerid] == 0) {
					format(strings, sizeof(strings), "* You can't make %s admin now. He/she has to login first!", giveplayer);
					SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
				} else {
				    tmps1 = dini_Get(udb_encode(giveplayer), "admin");
					if (strval(tmps1) > 0) {
						format(strings, sizeof(strings), "* %s is allready an admin.", giveplayer);
						SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
						return 1;
					} else {
					    adminlevel[giveplayerid] = level;
						dini_IntSet(udb_encode(giveplayer), "admin", level);
						format(strings, sizeof(strings), "* %s has just become an admin. Congratulations %s!", giveplayer, giveplayer);
						SendClientMessageToAll(COLOR_ADMIN_GM , strings);
					}
				}
			} else {
			    format(strings, sizeof(strings), "* %s has no account yet. Let him/her register one first!", giveplayer);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
			}
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
  		}
	}
	return 1;
}

dcmd_sadmin(playerid,params[])  {
	return dcmd_setadmin(playerid,params);
}

dcmd_setlevel(playerid,params[])  {
	new index = 0;
	new level = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setlevel [playerid] [level(1-3)]. This sets an admin [playerid] to a different level [level] admin.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)){
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setlevel [playerid] [level(1-3)]. This sets an admin [playerid] to a different level [level] admin.");
			return 1;
		}
		level = strval(tmps1);
		if (level <= 0 && level > MAX_ADMIN_LEVEL) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setlevel [playerid] [level(1-3)]. This sets an admin [playerid] to a different level [level] admin.");
			return 1;
		}


		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
		GetPlayerName(playerid, playername, sizeof(playername));

		if (IsPlayerConnected(giveplayerid)) {
			if (IsAdmin(giveplayerid)) {
				if (dini_Exists(udb_encode(giveplayer))) {
				    if (IsPlayerAdmin(giveplayerid) && !IsPlayerAdmin(playerid)) {
						format(strings, sizeof(strings), "* You cannot change the level of %s he/she is a RCON admin.", giveplayer);
						SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
					} else {
						dini_IntSet(udb_encode(giveplayer), "admin", level);
						adminlevel[giveplayerid] = level;
					}
	    		} else {
					format(strings, sizeof(strings), "* %s no such account.", giveplayer);
					SendClientMessage(playerid, COLOR_ADMIN_PW , strings);

					return 1;
				}
				format(strings, sizeof(strings), "--- %s (id: %d) sets adminlevel of player %s (id: %d) to level %d.", playername,playerid,giveplayer,giveplayerid,level);
				printf(strings);
				format(strings, sizeof(strings), "* You have set adminlevel of player %s (id: %d) to level %d.", giveplayer, giveplayerid, level);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* Your adminlevel is changed to level %d by %s (id: %d).", level, playername, playerid);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				format(strings, sizeof(strings), "* Player %s (id: %d) is not an admin.", giveplayer, giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
			}

		} else {
				format(strings, sizeof(strings), "* %d is not an active player. For offline removal, use /setuserint [playername] admin 0.", giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
  		}
	}
	return 1;
}

dcmd_getlevel(playerid,params[])  {
	new index = 0;
	new level = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /getlevel [playerid]. This shows you the adminlevel of admin [playerid].");
			return 1;
		}
		giveplayerid = strval(tmps1);

		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));

		if (IsPlayerConnected(giveplayerid)) {
			if (IsAdmin(giveplayerid)) {
				level = adminlevel[giveplayerid];
				format(strings, sizeof(strings), "* Player %s (id: %d) has an adminlevel of: %d", giveplayer, giveplayerid, level);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);

			} else {
				format(strings, sizeof(strings), "* Player %s (id: %d) is not an admin.", giveplayer, giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
			}

		} else {
				format(strings, sizeof(strings), "* %d is not an active player. For offline users, use /getuser [playername] admin.", giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
  		}
	}
	return 1;
}

dcmd_admins(playerid,params[])  {
	#pragma unused params
    new admins_online = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {

        SendClientMessage(playerid, COLOR_ADMIN_PM ,"Admins currently online: ");

		for(new i=0; i<MAX_PLAYERS; i++) {
			if (IsAdmin(i) && !IsPlayerAdmin(i)) {
		    	GetPlayerName(i, playername, sizeof(playername));
	            format(strings, sizeof(strings), "%s (id: %d) with level %d, ", playername, i, adminlevel[i]);
             	SendClientMessage(playerid, COLOR_ADMIN_PM ,strings);
	        	admins_online++;
			} else {
			    if(IsPlayerAdmin(i)) {
			    	GetPlayerName(i, playername, sizeof(playername));
		            format(strings, sizeof(strings), "%s (id: %d) logged in with rcon, ", playername, i);
		         	SendClientMessage(playerid, COLOR_ADMIN_PM ,strings);
		        	admins_online++;
		        }
		    }

	 	}
	 	if(admins_online == 0) SendClientMessage(playerid, COLOR_ADMIN_PM ,"There are no admins online.");
	}
	return 1;
}

dcmd_ad(playerid,params[])  {
	return dcmd_admins(playerid,params);
}

dcmd_hideout(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SetPlayerInterior(playerid, 0);
		SetPlayerPos(playerid, 212.4342,1909.7079,17.6406 + 5);
		SetCameraBehindPlayer(playerid);
		return 1;
	}
	return 1;
}

dcmd_hid(playerid,params[])  {
	return dcmd_hideout(playerid,params);
}

dcmd_stadium(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SetPlayerInterior(playerid, 14);
		SetPlayerPos(playerid, -1486.8618,1642.1459,1060.6718 + 5);
		SetCameraBehindPlayer(playerid);
		return 1;
	}
	return 1;
}

dcmd_sex(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SetPlayerInterior(playerid, 3);
		SetPlayerFacingAngle(playerid, 90);
		SetPlayerPos(playerid, 964.1069,-53.2054,1001.1799);
		SetCameraBehindPlayer(playerid);
		return 1;
	}
	return 1;
}

dcmd_villa(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SetPlayerInterior(playerid, 12);
		SetPlayerFacingAngle(playerid, 90);
		SetPlayerPos(playerid, 2324.4199,-1147.1016,1050.7101);
		SetCameraBehindPlayer(playerid);
		return 1;
	}
	return 1;
}


dcmd_kick(playerid,params[])  {
	new index = 0;
	new reason[256];
	new idlenght;
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {

		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /kick [playerid] (reason).This kicks [playerid], with reason (reason).");
			return 1;
		}
		giveplayerid = strval(tmps1);
		idlenght = strlen(tmps1);

		tmps1 = strtok(params, index);

		if(!strlen(tmps1)) {
			reason = "No reason given.";
		} else strmid(reason, params, strlen(cmd) + idlenght + 1, strlen(params));


		if (IsPlayerConnected(giveplayerid)) {
		    if(IsAdmin(giveplayerid) && !IsPlayerAdmin(playerid)) {
				SendClientMessage(playerid, COLOR_ADMIN_CMD , "* Only rcon admins can kick an admin.");
				return 1;
			} else {
				GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
				GetPlayerName(playerid, sendername, sizeof(sendername));
				KickMsg(giveplayerid, playerid, reason);
			}
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_k(playerid,params[])  {
	return dcmd_kick(playerid,params);
}

dcmd_ban(playerid,params[])  {
	new index = 0;
    new reason[256];
	new idlenght;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /ban [playerid] (reason). This bans [playerid] on name, with reason (reason).");
			return 1;
		}
		giveplayerid = strval(tmps1);
		idlenght = strlen(tmps1);

		tmps1 = strtok(params, index);

        if(!strlen(tmps1)) {
			reason = "No reason given.";
		} else strmid(reason, params, strlen(cmd) + idlenght + 1, strlen(params));

		if (IsPlayerConnected(giveplayerid)) {
			if(IsAdmin(giveplayerid) && !IsPlayerAdmin(playerid)) {
				SendClientMessage(playerid, COLOR_ADMIN_CMD , "* Only rcon admins can ban an admin.");
				return 1;
			} else {
				BanMsg(giveplayerid, playerid, reason);
			}
		}
		else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_b(playerid,params[])  {
	return dcmd_ban(playerid,params);
}

dcmd_pmspyon(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /pmspyon [playerid]. With this you can evesdrop upon the private messages [playerid] sends and receives.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			PMSpyOn[giveplayerid]=1;
			PMListen[playerid]=1;
			GetPlayerName(giveplayerid, sendername, sizeof(sendername));
			format(strings, sizeof(strings), "* Started private message spy upon %s (id %d).",sendername, giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_pmspyoff(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /pmspyoff [playerid]. This turns of the evesdrop on [playerid] private messages.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
			PMSpyOn[giveplayerid]=0;
			GetPlayerName(giveplayerid, sendername, sizeof(sendername));
			format(strings, sizeof(strings), "* Stopped private message spy upon %s (id %d).",sendername, giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
		} else {
			format(strings, sizeof(strings), "* %d is not an active player.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_pmspyoffall(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		for (new i=0; i<MAX_PLAYERS; i++){
			PMSpyOn[i]=0;
			PMListen[i]=0;
		}
		format(strings, sizeof(strings), "* You will no longer see any pm messages send that are not for you.");
		SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
	}
	return 1;
}


dcmd_setdawn(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		worldTime=6;
		GameHours=worldTime;
		SetWorldTime(worldTime);
		return 1;
	}
	return 1;
}

dcmd_setnoon(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		worldTime=12;
		GameHours=worldTime;
		SetWorldTime(worldTime);
		return 1;
	}
	return 1;
}

dcmd_setdusk(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		worldTime=18;
		GameHours=worldTime;
		SetWorldTime(worldTime);
		return 1;
	}
	return 1;
}

dcmd_setnight(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		worldTime=0;
		GameHours=worldTime;
		SetWorldTime(worldTime);
		return 1;
	}
	return 1;
}

dcmd_settime(playerid,params[]) {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /settime [hour]. This sets the gametime to [hour].");
			return 1;
		}
		worldTime=strval(tmps1);
		GameHours=worldTime;
		SetWorldTime(worldTime);
		return 1;
	}
	return 1;
}

dcmd_stat(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

        GetPlayerName(playerid, sendername, MAX_PLAYER_NAME);
		if(!strlen(tmps1)) {
		    if (dini_Exists(udb_encode(sendername))) {
				SendClientMessage(playerid, COLOR_MENU ,"____________________________");
				format(strings, sizeof(strings), "* Statistic for %s:", sendername);
				SendClientMessage(playerid, COLOR_STATS , strings);
				tmps2 = dini_Get(udb_encode(sendername), "kills");
				format(strings, sizeof(strings), "* Kills: %d.", strval(tmps2));
				SendClientMessage(playerid, COLOR_STATS , strings);
				tmps2 = dini_Get(udb_encode(sendername), "deaths");
				format(strings, sizeof(strings), "* Deaths: %d.", strval(tmps2));
				SendClientMessage(playerid, COLOR_STATS , strings);
				tmps2 = dini_Get(udb_encode(sendername), "suicides");
				format(strings, sizeof(strings), "* Suicides: %d.", strval(tmps2));
				SendClientMessage(playerid, COLOR_STATS , strings);
				SendClientMessage(playerid, COLOR_MENU ,"____________________________");
				format(strings, sizeof(strings), "* Total money: %d.", GetPlayerMoney(playerid)+bank[playerid]);
				SendClientMessage(playerid, COLOR_STATS , strings);
				SendClientMessage(playerid, COLOR_MENU ,"____________________________");
			}
			else {
			    format(strings, sizeof(strings), "* %s no such account.", sendername);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			}
		}
		else {
		    if (dini_Exists(udb_encode(tmps1))) {
       			SendClientMessage(playerid, COLOR_MENU ,"____________________________");
				format(strings, sizeof(strings), "* Statistic for %s:", tmps1);
				SendClientMessage(playerid, COLOR_STATS , strings);
    			tmps2 = dini_Get(udb_encode(tmps1), "kills");
				format(strings, sizeof(strings), "* Kills: %d.", strval(tmps2));
				SendClientMessage(playerid, COLOR_STATS , strings);
				tmps2 = dini_Get(udb_encode(tmps1), "deaths");
				format(strings, sizeof(strings), "* Deaths: %d.", strval(tmps2));
				SendClientMessage(playerid, COLOR_STATS , strings);
				tmps2 = dini_Get(udb_encode(tmps1), "suicides");
				format(strings, sizeof(strings), "* Suicides: %d.", strval(tmps2));
				SendClientMessage(playerid, COLOR_STATS , strings);
				SendClientMessage(playerid, COLOR_MENU ,"____________________________");
			}
			else {
			    format(strings, sizeof(strings), "* %s no such account.", tmps1);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			}
		}
	}
	return 1;
}

dcmd_protect(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {

		for(new i=0; i<MAX_PLAYERS; i++) {
			if(IsPlayerConnected(i) == 1 && logged[i] == 1) {
				isprotected[i] = 1;
			}
		}
		format(strings, sizeof(strings), "--- %s (id: %d) protecs all players.", playername,playerid);
		printf(strings);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* You protected everybody online and now logged in.");
	}
	return 1;
}

dcmd_p(playerid,params[])  {
	return dcmd_protect(playerid,params);
}

dcmd_setprot(playerid,params[])  {
	new index = 0;
	new level;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setprot [playerid] [0-1]. This disables[0] or enables[1] ban protection for this id.");
			return 1;
		}
		giveplayerid = strval(tmps1);

		tmps1 = strtok(params, index);
		level = strval(tmps1);

		if(!strlen(tmps1) || !IsNumeric(tmps1) && (level == 0 || level == 1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /setprot [playerid] [0-1]. This disables[0] or enables[1] ban protection for this id.");
			return 1;
		}

		GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
		GetPlayerName(playerid, playername, sizeof(playername));

		if ((IsPlayerConnected(giveplayerid) == 1) && (logged[giveplayerid] == 1)) {
		    if (dini_Exists(udb_encode(giveplayer))) {
		        if (IsPlayerAdmin(giveplayerid) && !IsPlayerAdmin(playerid)) {
					format(strings, sizeof(strings), "* You cannot change ban protection of %s. He/she is a RCON admin.", giveplayer);
					SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
					return 1;
				} else {
				    dini_IntSet(udb_encode(giveplayer), "protection", level);
					isprotected[giveplayerid] = level;
				}
		    } else {
				format(strings, sizeof(strings), "* %s no such account.", giveplayer);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
				return 1;
			}
		    format(strings, sizeof(strings), "--- %s (id: %d) sets ban protection of player %s (id: %d) to %d.", playername,playerid,giveplayer,giveplayerid,level);
				printf(strings);
				format(strings, sizeof(strings), "* You have set ban protection of player %s (id: %d) to %d.", giveplayer, giveplayerid, level);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* Your banprotection is changed to %d by %s (id: %d).", level, playername, playerid);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);

		} else {
				format(strings, sizeof(strings), "* %d is not an active player. For offline removal, use /setuserint [playername] protection 1.", giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
  		}
	}
	return 1;
}

dcmd_sv(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    tmps1 = dini_Get(FILE_SETTINGS, "manualsaving");
		if (strval(tmps1) == 0) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Manual saving is not allowed on this server!");
		    return 1;
		}

		GetPlayerName(playerid, playername, MAX_PLAYER_NAME);

		if(SaveFile(playerid)) {
		    format(strings, sizeof(strings), "--- %s (id: %d) saved his progress. Money: $%d *** Bank: $%d *** Bounty: $%d.", playername,playerid,GetPlayerMoney(playerid),bank[playerid],bounty[playerid]);
			printf(strings);
    		SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Your progress is now saved.");
		} else {
			format(strings, sizeof(strings), "* %s no such account.", playername);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
		}
	}
	return 1;
}

dcmd_svall(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
	    GetPlayerName(playerid, playername, MAX_PLAYER_NAME);
  		format(strings, sizeof(strings), "--- %s (id: %d) requested global save.", playername,playerid);
		printf(strings);
		SaveAllData();
   		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Global save done.");
	}
	return 1;
}

dcmd_getuser(playerid,params[])  {
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {

		tmps1 = strtok(params, index);
		if(!strlen(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /getuser [playername] [key]. Gets a specific keyvalue from [player]'s file.");
			return 1;
		}

		tmps2 = strtok(params, index);
		if(!strlen(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /getuser [playername] [key]. Gets a specific keyvalue from [player]'s file.");
			return 1;
		}

		if (dini_Exists(udb_encode(tmps1))) {
		    tmps3 = dini_Get(udb_encode(tmps1), tmps2);

			format(strings, sizeof(strings), "* You parameters of %s: %s=%s.", tmps1,tmps2,tmps3);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
		}
		else {
		    format(strings, sizeof(strings), "* %s no such account.", tmps1);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_myproperties(playerid,params[])  {
	#pragma unused params
    new propertycounter = 0;
    new TotalValue;
	if(logged[playerid] == 1){
        for(new i=0; i<MAX_PROPERTIES; i++) {
			if (propertyOwner[i] == playerid) {
		    	if (propertycounter == 0) {
		    	    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You own the following properties:");
				}
        	    propertycounter++;
				format(strings, sizeof(strings), "* %d. %s with current value $%d.", i,propertyNames[i],propertyCurrentValue[i]);
				TotalValue+=propertyCurrentValue[i];
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			}
		}
		if (propertycounter == 0 ) {
		   	SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not own a property.");
		} else {
    	 	format(strings, sizeof(strings), "* Total amount of properties: %d with the total value of $%d.", propertycounter,TotalValue);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
		}
	}
	return 1;
}

dcmd_taxi(playerid,params[]) {
	new index = 0;
	new locationid;
	new CurrentTaxiRate;
	new taxinumber;
	new taxidone;
	new PlayerMoney;
	if(logged[playerid] == 1){
        GetPlayerName(playerid, playername, sizeof(playername));
		format(strings, sizeof(strings), "--- Player %s (id: %d) wants to take the taxi.", playername,playerid);
		printf(strings);

		PF[playerid]=0.0000;
		QF[playerid]=0.0000;
		RF[playerid]=0.0000;

		tmps1 = strtok(params, index);

		if (!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /taxi [locationid]. This will transport you to [locationid]");
			SendClientMessage(playerid, COLOR_CMD , "* You can view the taxilocations with the command /taxilocs");
			return 1;
		}

		locationid = strval(tmps1);

		if(IsPlayerInAnyVehicle(playerid)){
			format(strings, sizeof(strings), "* You are already in a vehicle, you can only request a taxi while on foot.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
			return 1;
		}

		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* No easy way out, sorry. You'll have to do your time.");
		    return 1;
		}

		if(admindived[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* No easy way out, sorry. Enjoy the ride.");
		    return 1;
		}

		if (locationid < 1 || locationid > 17) {
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid location id, check /taxilocs for the correct ones.");
			return 1;
		}

		if (IsPlayerConnected(playerid) && Z250[playerid] > 900) {
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, we cannot pick you up indoors. Please stand outside to order the taxi.");
			return 1;
		}

		if (IsPlayerConnected(playerid)) {
			InteriorID[playerid] = 0;
		    if (locationid == 1) {
 				TaxiLocname[playerid]="LS Skate Park.";
				PF[playerid]=1868.3408;
				QF[playerid]=-1380.3097;
				RF[playerid]=13.5117;
			}
            if (locationid == 2) {
				TaxiLocname[playerid]="Wang Cars.";
				PF[playerid]=-2047.6205;
				QF[playerid]=251.5972;
				RF[playerid]=35.7182;
			}
		    if (locationid == 3) {
				TaxiLocname[playerid]="Mount Chilliad base.";
				PF[playerid]=-2405.1335;
				QF[playerid]=-2184.5051;
				RF[playerid]=33.2891;
			}
		    if (locationid == 4) {
				TaxiLocname[playerid]="Abandoned Airport.";
				PF[playerid]=401.5054;
				QF[playerid]=2500.1238;
				RF[playerid]=16.4844;
			}
		    if (locationid == 5) {
				TaxiLocname[playerid]="Pirate Ship.";
				PF[playerid]=2033.2911;
				QF[playerid]=1544.2891;
				RF[playerid]=10.8203;
			}
		    if (locationid == 6) {
				TaxiLocname[playerid]="Top of Mount Chilliad.";
				PF[playerid]=-2315.4053;
				QF[playerid]=-1635.9091;
				RF[playerid]=483.7031;
			}
			if (locationid == 7) {
				TaxiLocname[playerid]="Palomino Creek";
				PF[playerid]=2335.6091;
				QF[playerid]=84.6496;
				RF[playerid]=26.4844;
			}
		    if (locationid == 8) {
				TaxiLocname[playerid]="Montgomery";
				PF[playerid]=1358.6831;
				QF[playerid]=250.8536;
				RF[playerid]=19.5669;
			}
		    if (locationid == 9) {
				TaxiLocname[playerid]="Dillmore";
				PF[playerid]=695.2390;
				QF[playerid]=-498.7034;
				RF[playerid]=16.3359;
			}
		    if (locationid == 10) {
				TaxiLocname[playerid]="Blueberry";
				PF[playerid]=223.1478;
				QF[playerid]=-81.5003;
				RF[playerid]=1.5781;
			}
		    if (locationid == 11) {
				TaxiLocname[playerid]="Angel Pine";
				PF[playerid]=-2180.3259;
				QF[playerid]=-2396.1731;
				RF[playerid]=30.6250;
			}
		    if (locationid == 12) {
				TaxiLocname[playerid]="El Quebradas";
				PF[playerid]=-1436.8586;
				QF[playerid]=2663.7063;
				RF[playerid]=55.4082;
			}
		    if (locationid == 13) {
				TaxiLocname[playerid]="Las Barrancas";
				PF[playerid]=-879.6643;
				QF[playerid]=1499.6860;
				RF[playerid]=24.1947;
			}
		    if (locationid == 14) {
				TaxiLocname[playerid]="Ghost Town";
				PF[playerid]=-400.4375;
				QF[playerid]=2260.4839;
				RF[playerid]=41.7421;
			}
		    if (locationid == 15) {
				TaxiLocname[playerid]="Fort Carson";
				PF[playerid]=42.7667;
				QF[playerid]=1206.6785;
				RF[playerid]=18.5784;
			}
		    if (locationid == 16) {
				TaxiLocname[playerid]="Las Payasadas";
				PF[playerid]=-249.0508;
				QF[playerid]=2693.2722;
				RF[playerid]=62.2541;
			}
		    if (locationid == 17) {
				TaxiLocname[playerid]="Golden Gate Bridge";
				PF[playerid]=-2676.9097;
				QF[playerid]=1933.9713;
				RF[playerid]=217.2739;
			}

			PlayerMoney=GetPlayerMoney(playerid);
			TotalMoney[playerid]=PlayerMoney+bank[playerid];

			if(TotalMoney[playerid] < 501) {
				if (TaxiUsedNew[playerid] == 3){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You already made 3 taxitrips, no more free rides.");
					return 1;
				} else {
				    TaxiUsedNew[playerid]=TaxiUsedNew[playerid]+1;
				    TaxiUpcomingDrive[playerid]=1;
				    taxidone=1;
				}
			}
   		    if((TotalMoney[playerid] < 50001) && taxidone == 0) {
				if (TaxiUsedPoor[playerid] == 4) {
					taxinumber=TaxiUsedRich[playerid];
					CurrentTaxiRate=TaxiPricePlayer[taxinumber];
					if (CurrentTaxiRate > PlayerMoney){
 						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					} else {
					    TaxiUpcomingDrive[playerid]=3;
					    TaxiUsedRich[playerid]=TaxiUsedRich[playerid]+1;
					    taxidone=1;
					}
				}
				if (TaxiUsedPoor[playerid] == 3){
       				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You already made 3 taxitrips for the reduced price, from now on you'll have to pay the full price.");
      				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Next trip will cost you $10.000, use /taxi to request the taxi again.");
					TaxiUsedPoor[playerid]=TaxiUsedPoor[playerid]+1;
					return 1;
				}
				if (TaxiUsedPoor[playerid] < 3) {
					CurrentTaxiRate=5000;
					if (CurrentTaxiRate > GetPlayerMoney(playerid)){
   						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					}
					TaxiUpcomingDrive[playerid]=2;
					TaxiUsedPoor[playerid]=TaxiUsedPoor[playerid]+1;
					taxidone=1;
				}
			}
			if((TotalMoney[playerid] > 50000) && taxidone == 0) {
				if (TaxiUsedRich[playerid]==5) {
					CurrentTaxiRate=TaxiPricePlayer[4];
					if (CurrentTaxiRate > PlayerMoney){
   						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					} else {
					    TaxiUpcomingDrive[playerid]=3;
					    taxidone=1;
					}
				}
				if (TaxiUsedRich[playerid] < 5) {
				   	taxinumber=TaxiUsedRich[playerid];
					CurrentTaxiRate=TaxiPricePlayer[taxinumber];
					if (CurrentTaxiRate > PlayerMoney){
 						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					}
					TaxiUpcomingDrive[playerid]=3;
					TaxiUsedRich[playerid]=TaxiUsedRich[playerid]+1;
					taxidone=1;

				}
			}
			RequestedTaxi[playerid] = 1;
            WaitingTime[playerid] = 10;
		}
	}
	return 1;
}

dcmd_credittaxi(playerid,params[])  {
	new index = 0;
	new locationid;
	new CurrentTaxiRate;
	new taxinumber;
	new taxidone;
	new PlayerMoney;
	if(logged[playerid] == 1){
        GetPlayerName(playerid, playername, sizeof(playername));
		format(strings, sizeof(strings), "--- Player %s (id: %d) wants to take the taxi.", playername,playerid);
		printf(strings);

		PF[playerid]=0.0000;
		QF[playerid]=0.0000;
		RF[playerid]=0.0000;

		tmps1 = strtok(params, index);

		if (!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_CMD , "* USAGE: /credittaxi [locationid]. This will transport you to [locationid]");
			SendClientMessage(playerid, COLOR_CMD , "* You can view the taxilocations with the command /taxilocs");
			return 1;
		}

		locationid = strval(tmps1);

		if(IsPlayerInAnyVehicle(playerid)){
			format(strings, sizeof(strings), "* You are already in a vehicle, you can only request a taxi while on foot.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
			return 1;
		}

		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* No easy way out, sorry. You'll have to do your time.");
		    return 1;
		}

		if(admindived[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* No easy way out, sorry. Enjoy the ride.");
		    return 1;
		}

		if (locationid < 1 || locationid > 17) {
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Invalid location id, check /taxilocs for the correct ones.");
			return 1;
		}

		if (IsPlayerConnected(playerid) && Z250[playerid] > 900) {
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, we cannot pick you up indoors. Please stand outside to order the taxi.");
			return 1;
		}

		if (IsPlayerConnected(playerid)) {
			InteriorID[playerid] = 0;
		    if (locationid == 1) {
 				TaxiLocname[playerid]="LS Skate Park.";
				PF[playerid]=1868.3408;
				QF[playerid]=-1380.3097;
				RF[playerid]=13.5117;
			}
            if (locationid == 2) {
				TaxiLocname[playerid]="Wang Cars.";
				PF[playerid]=-2047.6205;
				QF[playerid]=251.5972;
				RF[playerid]=35.7182;
			}
		    if (locationid == 3) {
				TaxiLocname[playerid]="Mount Chilliad base.";
				PF[playerid]=-2405.1335;
				QF[playerid]=-2184.5051;
				RF[playerid]=33.2891;
			}
		    if (locationid == 4) {
				TaxiLocname[playerid]="Abandoned Airport.";
				PF[playerid]=401.5054;
				QF[playerid]=2500.1238;
				RF[playerid]=16.4844;
			}
		    if (locationid == 5) {
				TaxiLocname[playerid]="Pirate Ship.";
				PF[playerid]=2033.2911;
				QF[playerid]=1544.2891;
				RF[playerid]=10.8203;
			}
		    if (locationid == 6) {
				TaxiLocname[playerid]="Top of Mount Chilliad.";
				PF[playerid]=-2315.4053;
				QF[playerid]=-1635.9091;
				RF[playerid]=483.7031;
			}
			if (locationid == 7) {
				TaxiLocname[playerid]="Palomino Creek";
				PF[playerid]=2335.6091;
				QF[playerid]=84.6496;
				RF[playerid]=26.4844;
			}
		    if (locationid == 8) {
				TaxiLocname[playerid]="Montgomery";
				PF[playerid]=1358.6831;
				QF[playerid]=250.8536;
				RF[playerid]=19.5669;
			}
		    if (locationid == 9) {
				TaxiLocname[playerid]="Dillmore";
				PF[playerid]=695.2390;
				QF[playerid]=-498.7034;
				RF[playerid]=16.3359;
			}
		    if (locationid == 10) {
				TaxiLocname[playerid]="Blueberry";
				PF[playerid]=223.1478;
				QF[playerid]=-81.5003;
				RF[playerid]=1.5781;
			}
		    if (locationid == 11) {
				TaxiLocname[playerid]="Angel Pine";
				PF[playerid]=-2180.3259;
				QF[playerid]=-2396.1731;
				RF[playerid]=30.6250;
			}
		    if (locationid == 12) {
				TaxiLocname[playerid]="El Quebradas";
				PF[playerid]=-1436.8586;
				QF[playerid]=2663.7063;
				RF[playerid]=55.4082;
			}
		    if (locationid == 13) {
				TaxiLocname[playerid]="Las Barrancas";
				PF[playerid]=-879.6643;
				QF[playerid]=1499.6860;
				RF[playerid]=24.1947;
			}
		    if (locationid == 14) {
				TaxiLocname[playerid]="Ghost Town";
				PF[playerid]=-400.4375;
				QF[playerid]=2260.4839;
				RF[playerid]=41.7421;
			}
		    if (locationid == 15) {
				TaxiLocname[playerid]="Fort Carson";
				PF[playerid]=42.7667;
				QF[playerid]=1206.6785;
				RF[playerid]=18.5784;
			}
		    if (locationid == 16) {
				TaxiLocname[playerid]="Las Payasadas";
				PF[playerid]=-249.0508;
				QF[playerid]=2693.2722;
				RF[playerid]=62.2541;
			}
		    if (locationid == 17) {
				TaxiLocname[playerid]="Golden Gate Bridge";
				PF[playerid]=-2676.9097;
				QF[playerid]=1933.9713;
				RF[playerid]=217.2739;
			}

			PlayerMoney=bank[playerid];
			TotalMoney[playerid]=GetPlayerMoney(playerid)+bank[playerid];

			if(TotalMoney[playerid] < 501) {
				if (TaxiUsedNew[playerid] == 3){
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You already made 3 taxitrips, no more free rides.");
					return 1;
				} else {
				    TaxiUsedNew[playerid]=TaxiUsedNew[playerid]+1;
				    TaxiUpcomingDrive[playerid]=1;
				    taxidone=1;
				}
			}
   		    if((TotalMoney[playerid] < 50001) && taxidone == 0) {
				if (TaxiUsedPoor[playerid] == 4) {
					taxinumber=TaxiUsedRich[playerid];
					CurrentTaxiRate = TaxiPricePlayer[taxinumber];
					CurrentTaxiRate = CurrentTaxiRate + floatround(CurrentTaxiRate*(float(CREDITCOST)/100));
					if (CurrentTaxiRate > PlayerMoney){
 						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					} else {
					    TaxiUpcomingDrive[playerid]=3;
					    TaxiUsedRich[playerid]=TaxiUsedRich[playerid]+1;
					    taxidone=1;
					}
				}
				if (TaxiUsedPoor[playerid] == 3){
       				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You already made 3 taxitrips for the reduced price, from now on you'll have to pay the full price.");
      				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Next trip will cost you $10.000, use /taxi or /credittaxi to request the taxi again.");
					TaxiUsedPoor[playerid]=TaxiUsedPoor[playerid]+1;
					return 1;
				}
				if (TaxiUsedPoor[playerid] < 3) {
					CurrentTaxiRate=5000;
					CurrentTaxiRate = CurrentTaxiRate + floatround(CurrentTaxiRate*(float(CREDITCOST)/100));
					if (CurrentTaxiRate > GetPlayerMoney(playerid)){
   						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					}
					TaxiUpcomingDrive[playerid]=2;
					TaxiUsedPoor[playerid]=TaxiUsedPoor[playerid]+1;
					taxidone=1;
				}
			}
			if((TotalMoney[playerid] > 50000) && taxidone == 0) {
				if (TaxiUsedRich[playerid]==5) {
					CurrentTaxiRate=TaxiPricePlayer[4];
					CurrentTaxiRate = CurrentTaxiRate + floatround(CurrentTaxiRate*(float(CREDITCOST)/100));
					if (CurrentTaxiRate > PlayerMoney){
   						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					} else {
					    TaxiUpcomingDrive[playerid]=3;
					    taxidone=1;
					}
				}
				if (TaxiUsedRich[playerid] < 5) {
				   	taxinumber=TaxiUsedRich[playerid];
					CurrentTaxiRate=TaxiPricePlayer[taxinumber];
					CurrentTaxiRate = CurrentTaxiRate + floatround(CurrentTaxiRate*(float(CREDITCOST)/100));
					if (CurrentTaxiRate > PlayerMoney){
 						format(strings, sizeof(strings), "* You do not have enough money for the trip, you need $%d!", CurrentTaxiRate);
						SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
						return 1;
					}
					TaxiUpcomingDrive[playerid]=3;
					TaxiUsedRich[playerid]=TaxiUsedRich[playerid]+1;
					taxidone=1;
				}
			}
			RequestedTaxi[playerid] = 1;
            WaitingTime[playerid] = 10;
			TaxiCreditcard[playerid]=1;
		}
	}
	return 1;
}

dcmd_visit(playerid,params[]) {
	#pragma unused params
	if(logged[playerid] == 1){
        GetPlayerName(playerid, playername, sizeof(playername));
		format(strings, sizeof(strings), "--- Player %s (id: %d) wants to take the taxi.", playername,playerid);
		printf(strings);

		PF[playerid]=0.0000;
		QF[playerid]=0.0000;
		RF[playerid]=0.0000;

		if(IsPlayerInAnyVehicle(playerid)){
			format(strings, sizeof(strings), "* You are already in a vehicle, you can only request a taxi to the prison while on foot.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
			return 1;
		}

		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* No easy way out, sorry. You'll have to do your time.");
		    return 1;
		}

		if(admindived[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* No easy way out, sorry. Enjoy the ride.");
		    return 1;
		}

		if (IsPlayerConnected(playerid) && Z250[playerid] > 900) {
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, we cannot pick you up indoors. Please stand outside to order the taxi to the prison.");
			return 1;
		}
		TaxiLocname[playerid]="San Fierro prison (visiting)";
		PF[playerid]=241.6479;
		QF[playerid]=112.6493;
		RF[playerid]=1003.2188;
		InteriorID[playerid]=10;
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You can leave the prison using the command /leave or committing suicide.");
		RequestedTaxi2[playerid] = 1;
        WaitingTime2[playerid] = 10;
	}
	return 1;
}

dcmd_leave(playerid,params[]){
	#pragma unused params
	if(logged[playerid] == 1){
	    if(VisitingPrison[playerid] == 0){
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You haven't visited the prison, so you cannot use our free service to leave the prison.");
			return 1;
		}
	    if(jailed[playerid] == 1){
 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are jailed, you cannot leave the prison like this!");
			VisitingPrison[playerid] = 0;
			return 1;
		}
		SetPlayerInterior(playerid, 0);
		SetPlayerFacingAngle(playerid, 175.0);
		SetPlayerPos(playerid,PFold[playerid],QFold[playerid],RFold[playerid]);
		SetCameraBehindPlayer(playerid);
		VisitingPrison[playerid] = 0;
	}
	return 1;
}

dcmd_taxilocs(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU , "____________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* 1. Skate Park *** 2. Wang Cars *** 3. Mount Chilliad Base");
		SendClientMessage(playerid, COLOR_MENU , "* 4. Abandoned Airport *** 5. Pirate ship ** 6. Top of Mount Chilliad");
		SendClientMessage(playerid, COLOR_MENU , "* 7. Palomino Creek *** 8. Montgomery *** 9. Dillmore *** 10. Blueberry");
		SendClientMessage(playerid, COLOR_MENU , "* 11. Angel Pine *** 12. El Quebradas *** 13. Las Barrancas");
		SendClientMessage(playerid, COLOR_MENU , "* 14. Ghost Town *** 15. Fort Carson *** 16. Las Payasadas");
		SendClientMessage(playerid, COLOR_MENU , "* 17. On top of the Golden Gate");
        SendClientMessage(playerid, COLOR_MENU , "____________________________________________________________________________");
	}
	return 1;
}

dcmd_new(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU , "____________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* Recently additions to this server:");
		SendClientMessage(playerid, COLOR_MENU , "* - Added some 40 new selectable player skins");
		SendClientMessage(playerid, COLOR_MENU , "* - Choose your own player color with /owncolor , see /colors for the available colors.");
		SendClientMessage(playerid, COLOR_MENU , "* - Automatic cardoor locking available at the Black carparts market in San Fierro");
		SendClientMessage(playerid, COLOR_MENU , "* - Withdraw without visiting a bank with /transfer - see /help transfer for more information");
		SendClientMessage(playerid, COLOR_MENU , "* - Change the way the profit of your properties is handled by the commands /payout and /nopayout");
		SendClientMessage(playerid, COLOR_MENU , "* Check /help for a list of the available commands.");
        SendClientMessage(playerid, COLOR_MENU , "____________________________________________________________________________________");
	}
	return 1;
}

dcmd_hackthebank(playerid,params[])  {
	new index = 0;
	new property=999;
	new victimid;
	new victimname[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(BankHacker[playerid]==1){
			SendClientMessage(playerid, COLOR_MENU , "* You have 4 passwords at your disposal. Enter them with: /hackpass [number] .");
			SendClientMessage(playerid, COLOR_MENU , "* Only enter the number, not the password. Entering the wrong id or fault id will");
			SendClientMessage(playerid, COLOR_MENU , "* send you to jail!");
			SendClientMessage(playerid, COLOR_MENU , "* Password 1: iamgod                    Password 2: BiGsM0K3");
			SendClientMessage(playerid, COLOR_MENU , "* Password 3: CJisGREAT                 Password 4: wannabeeadmin");
			SendClientMessage(playerid, COLOR_MENU , "* If you want to see this list again, type /hacklist .");
			SendClientMessage(playerid, COLOR_MENU , "* But be quick, you only have 60 seconds before the police is on the doorstep!");
			SendClientMessage(playerid, COLOR_MENU , "* You are frozen during the time; there is no escaping.");
			return 1;
		}

		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_BANKHACKING){
					property = P_BANKHACKING;
			}
			if (property == 999) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can not hack the bank from here.");
				return 1;
			}

			if(!strlen(tmps1) || !IsNumeric(tmps1)) {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* USAGE: /hackthebank [playerid]. With this you can hack the bankaccount of [playerid].");
				return 1;
			}

            GetPlayerName(playerid, playername, sizeof(playername));

			if(BankHackAttempt[playerid] > 0) {
			    if(BankHackWarning[playerid] == 0) {
			        BankHackWarning[playerid] = 1;
					format(strings, sizeof(strings), "* You need to wait %d days till the police loose interest in you.", BankHackAttempt[playerid]);
					SendClientMessage(playerid, COLOR_RULES , strings);
					SendClientMessage(playerid, COLOR_RULES , "* If you try to hack the bank again within these days, you wil be jailed!");
					return 1;
				} else {
					SendClientMessage(playerid, COLOR_RULES , "* The police has found you despite the warning, and sentenced you to 5 minutes jailtime!");
					format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
					SendClientMessageToAll(COLOR_RULES, strings);
					jailed[playerid] = 1;
					jailtime[playerid] = 5;
			        BankHackWarning[playerid] = 0;

					dini_IntSet(udb_encode(playername), "jailed", 1);
					dini_IntSet(udb_encode(playername), "jailtime", 5);

					SetPlayerInterior(playerid,10);
					SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
					if(jailcelcounter < 3) {
					    jailcelcounter++;
					} else {
					    jailcelcounter=0;
					}
			        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
			        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
			        DisablePlayerCheckpoint(playerid);
					ResetPlayerWeapons(playerid);

					return 1;
				}
			}

			victimid = strval(tmps1);

			if(BankHackVictimAttempt[victimid] > 0) {
	            GetPlayerName(victimid, victimname, sizeof(victimname));
				format(strings, sizeof(strings), "* %s has been hacked within the past 7 days - the bank is observing the players bank account.", victimname);
				SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
				format(strings, sizeof(strings), "* You have to wait %d days till you can hack the players bank account", BankHackVictimAttempt[victimid]);
				SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
				return 1;
			}

			if (IsPlayerConnected(victimid)) {
				BankHackTime[playerid]=worldTime;
				BankHacker[playerid]=1;
				BankHackVictim[playerid]=victimid;
				BankHackPassword[playerid]=0;
				BankHackVictimAttempt[victimid]=14;
				BankHackAttempt[playerid]=14;

				format(strings, sizeof(strings), "~w~Connecting to server......~n~User: ~p~hackplanet~n~~r~Enter password:~w~_");
				GameTextForPlayer(playerid,strings,5000,3);
				SendClientMessage(playerid, COLOR_MENU , "* You have 4 passwords at your disposal. Enter them with: /hackpass [number] .");
				SendClientMessage(playerid, COLOR_MENU , "* Only enter the number, not the password. Entering the wrong id or fault id will");
				SendClientMessage(playerid, COLOR_MENU , "* send you to jail!");
				SendClientMessage(playerid, COLOR_MENU , "* Password 1: iamgod                    Password 2: BiGsM0K3");
				SendClientMessage(playerid, COLOR_MENU , "* Password 3: CJisGREAT                 Password 4: wannabeeadmin");
				SendClientMessage(playerid, COLOR_MENU , "* If you want to see this list again, type /hacklist .");
				SendClientMessage(playerid, COLOR_MENU , "* But be quick, you only have 60 seconds before the police is on the doorstep!");
				SendClientMessage(playerid, COLOR_MENU , "* You are frozen during the time; there is no escaping.");
				for(new j = 0; j < MAX_PLAYERS; j++) {
			    	if(IsPlayerConnected(j) && IsAdmin(j)) {
				  		format(strings, sizeof(strings), "* Player %s (id: %d) is frozen because he is hacking the bank.", playername, playerid);
						SendClientMessage(j, COLOR_ADMINCHAT, strings);
					}
				}
				BankHackTimer[playerid]=60;
			} else {
				format(strings, sizeof(strings), "* Your hacking attempt failed: %d is not an active player.", victimid);
				SendClientMessage(playerid, COLOR_RULES , strings);
				SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
				format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
				SendClientMessageToAll(COLOR_RULES, strings);
				jailed[playerid] = 1;
				jailtime[playerid] = 5;
				dini_IntSet(udb_encode(playername), "jailed", 1);
				dini_IntSet(udb_encode(playername), "jailtime", 5);

				SetPlayerInterior(playerid,10);
				SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}

		        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
		        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);

				return 1;
			}
			return 1;
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can not hack the bank from here. Go to your safehouse in Los Santos.");
			return 1;
		}
	}
	return 1;
}

dcmd_hacklist(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1 && BankHacker[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU , "* You have 4 passwords at your disposal. Enter them with: /hackpass [number] .");
		SendClientMessage(playerid, COLOR_MENU , "* Only enter the number, not the password. Entering the wrong id or fault id will");
		SendClientMessage(playerid, COLOR_MENU , "* send you to jail!");
		SendClientMessage(playerid, COLOR_MENU , "* Password 1: iamgod");
		SendClientMessage(playerid, COLOR_MENU , "* Password 2: BiGsM0K3");
		SendClientMessage(playerid, COLOR_MENU , "* Password 3: CJisGREAT");
		SendClientMessage(playerid, COLOR_MENU , "* Password 4: wannabeeadmin");
		SendClientMessage(playerid, COLOR_MENU , "* If you want to see this list again, type /hacklist .");
		SendClientMessage(playerid, COLOR_MENU , "* But be quick, you only have 60 seconds before the police is on the doorstep!");
	}
	return 1;
}

dcmd_hackpass(playerid,params[])  {
	new index = 0;
	new HackPassword;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);
        GetPlayerName(playerid, playername, sizeof(playername));

		if(BankHacker[playerid] == 1) {
			if(!strlen(tmps1) || !IsNumeric(tmps1)) {
				format(strings, sizeof(strings), "* Your hacking attempt failed: you should have entered the password id, one number.");
				SendClientMessage(playerid, COLOR_RULES , strings);
				SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
				format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
				SendClientMessageToAll(COLOR_RULES, strings);
				BankHacker[playerid]=0;
				jailed[playerid] = 1;
				jailtime[playerid] = 5;
				dini_IntSet(udb_encode(playername), "jailed", 1);
				dini_IntSet(udb_encode(playername), "jailtime", 5);

				SetPlayerInterior(playerid,10);
				SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}
		        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
		        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);

				return 1;
			}

	        HackPassword = strval(tmps1);
	 		if (HackPassword < 1 || HackPassword > 4) {
				format(strings, sizeof(strings), "* Your hacking attempt failed: you entered an incorrect password id.");
				SendClientMessage(playerid, COLOR_RULES , strings);
				SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
				format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
				SendClientMessageToAll(COLOR_RULES, strings);
				BankHacker[playerid]=0;
				jailed[playerid] = 1;
				jailtime[playerid] = 5;
				dini_IntSet(udb_encode(playername), "jailed", 1);
				dini_IntSet(udb_encode(playername), "jailtime", 5);

				SetPlayerInterior(playerid,10);
				SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}
		        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
		        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);

				return 1;
			}

			BankHackPassword[playerid] = HackPassword;

		}
	}
	return 1;
}

dcmd_springbreak(playerid,params[])  {
	#pragma unused params
	new property=999;
	if(logged[playerid] == 1){

		if(JailBreaker[playerid]==1){
			SendClientMessage(playerid, COLOR_MENU , "* You have 7 passwords at your disposal. Enter them with: /springpass [number] .");
			SendClientMessage(playerid, COLOR_MENU , "* Only enter the number, not the password. Entering the wrong id or fault id will send you to jail!");
			SendClientMessage(playerid, COLOR_MENU , "* Password 1: donut                     Password 2: cr4ck");
			SendClientMessage(playerid, COLOR_MENU , "* Password 3: wannabepresident          Password 4: tenfour");
			SendClientMessage(playerid, COLOR_MENU , "* Password 5: ugoingdown                Password 6: iamthabest");
			SendClientMessage(playerid, COLOR_MENU , "* Password 7: youpunk                   Password 8: junky");
			SendClientMessage(playerid, COLOR_MENU , "* If you want to see this list again, type /springlist .");
			SendClientMessage(playerid, COLOR_MENU , "* But be quick, you only have 60 seconds before the police is on the doorstep!");
			SendClientMessage(playerid, COLOR_MENU , "* You are frozen during the time; there is no escaping.");
			return 1;
		}

		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_JAILBREAK){
					property = P_JAILBREAK;
			}
			if (property == 999) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can not hack into the Dillmore PD computer. Go to the Dillmore PD Headquaters.");
				return 1;
			}

			if(JailBreakAttempt[playerid] > 0) {
			    if(JailBreakWarning[playerid] == 0) {
			        JailBreakWarning[playerid] = 1;
					format(strings, sizeof(strings), "* You need to wait %d days till the police loose interest in you.", JailBreakAttempt[playerid]);
					SendClientMessage(playerid, COLOR_RULES , strings);
					SendClientMessage(playerid, COLOR_RULES , "* If you try to hack computer of the Dillmore PD again within these days, you wil be jailed!");
					return 1;
				} else {
					SendClientMessage(playerid, COLOR_RULES , "* The police has found you despite the warning, and sentenced you to 5 minutes jailtime!");
					format(strings, sizeof(strings), "* %s has been caught hacking into the Dillmore PD computer, and has been send to jail.", playername);
					SendClientMessageToAll(COLOR_RULES, strings);
					jailed[playerid] = 1;
					jailtime[playerid] = 5;
			        JailBreakWarning[playerid] = 0;
                    JailBreakAttempt[playerid] = 0;

					dini_IntSet(udb_encode(playername), "jailed", 1);
					dini_IntSet(udb_encode(playername), "jailtime", 5);

					SetPlayerInterior(playerid,10);
					SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
					if(jailcelcounter < 3) {
					    jailcelcounter++;
					} else {
					    jailcelcounter=0;
					}

			        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to spring the jail.", GetPlayerMoney(playerid), playerid);
			        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
			        DisablePlayerCheckpoint(playerid);
					ResetPlayerWeapons(playerid);

					return 1;
				}
			}

			JailBreakTime[playerid]=worldTime;
			JailBreaker[playerid]=1;
			JailBreakPassword[playerid]=0;

			format(strings, sizeof(strings), "~w~Connecting to server......~n~User: ~p~polowski~n~~r~Enter password:~w~_");
			GameTextForPlayer(playerid,strings,5000,3);
			SendClientMessage(playerid, COLOR_MENU , "* You have 7 passwords at your disposal. Enter them with: /springpass [number] .");
			SendClientMessage(playerid, COLOR_MENU , "* Only enter the number, not the password. Entering the wrong id or fault id will send you to jail!");
			SendClientMessage(playerid, COLOR_MENU , "* Password 1: donut                     Password 2: cr4ck");
			SendClientMessage(playerid, COLOR_MENU , "* Password 3: wannabepresident          Password 4: tenfour");
			SendClientMessage(playerid, COLOR_MENU , "* Password 5: ugoingdown                Password 6: iamthabest");
			SendClientMessage(playerid, COLOR_MENU , "* Password 7: youpunk                   Password 8: junky");
			SendClientMessage(playerid, COLOR_MENU , "* If you want to see this list again, type /springlist .");
			SendClientMessage(playerid, COLOR_MENU , "* But be quick, you only have 60 seconds before the police is on the doorstep!");
			SendClientMessage(playerid, COLOR_MENU , "* You are frozen during the time; there is no escaping.");
			for(new j = 0; j < MAX_PLAYERS; j++) {
		    	if(IsPlayerConnected(j) && IsAdmin(j)) {
			  		format(strings, sizeof(strings), "* Player %s (id: %d) is frozen because he is hacking the Dillmore PD computer.", playername, playerid);
					SendClientMessage(j, COLOR_ADMINCHAT, strings);
				}
			}
			JailBreakTimer[playerid]=62;
			return 1;
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can not hack into the Dillmore PD computer. Go to the Dillmore PD Headquaters.");
			return 1;
		}
	}
	return 1;
}

dcmd_springlist(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(JailBreaker[playerid] == 1) {
			SendClientMessage(playerid, COLOR_MENU , "* You have 7 passwords at your disposal. Enter them with: /springpass [number] .");
			SendClientMessage(playerid, COLOR_MENU , "* Only enter the number, not the password. Entering the wrong id or fault id will send you to jail!");
			SendClientMessage(playerid, COLOR_MENU , "* Password 1: donut                     Password 2: cr4ck");
			SendClientMessage(playerid, COLOR_MENU , "* Password 3: wannabepresident          Password 4: tenfour");
			SendClientMessage(playerid, COLOR_MENU , "* Password 5: ugoingdown                Password 6: iamthabest");
			SendClientMessage(playerid, COLOR_MENU , "* Password 7: youpunk                   Password 8: junky");
			SendClientMessage(playerid, COLOR_MENU , "* If you want to see this list again, type /springlist .");
			SendClientMessage(playerid, COLOR_MENU , "* But be quick, you only have 60 seconds before the police is on the doorstep!");
			SendClientMessage(playerid, COLOR_MENU , "* You are frozen during the time; there is no escaping.");
		}
	}
	return 1;
}

dcmd_springpass(playerid,params[])  {
	new index = 0;
	new JailPassword;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);
        GetPlayerName(playerid, playername, sizeof(playername));

		if(JailBreaker[playerid] == 1) {
			if(!strlen(tmps1) || !IsNumeric(tmps1)) {
				format(strings, sizeof(strings), "* Your hacking attempt failed: you should have entered the password id, one number.");
				SendClientMessage(playerid, COLOR_RULES , strings);
				SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
				format(strings, sizeof(strings), "* %s has been caught hacking into the Dillmore PD computer, and has been send to jail.", playername);
				SendClientMessageToAll(COLOR_RULES, strings);
				jailed[playerid] = 1;
				jailtime[playerid] = 5;
				dini_IntSet(udb_encode(playername), "jailed", 1);
				dini_IntSet(udb_encode(playername), "jailtime", 5);

				SetPlayerInterior(playerid,10);
				SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}

				JailBreakTime[playerid]=0;
				JailBreaker[playerid]=0;
				JailBreakPassword[playerid]=0;
				JailBreakAttempt[playerid]=7;
				JailBreakWarning[playerid]=0;

		        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to spring the jail.", GetPlayerMoney(playerid), playerid);
		        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);

				return 1;
			}

	        JailPassword = strval(tmps1);

	 		if (JailPassword < 1 || JailPassword > 8) {
				format(strings, sizeof(strings), "* Your hacking attempt failed: you entered an incorrect password id.");
				SendClientMessage(playerid, COLOR_RULES , strings);
				SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
				format(strings, sizeof(strings), "* %s has been caught hacking into the Dillmore PD computer, and has been send to jail.", playername);
				SendClientMessageToAll(COLOR_RULES, strings);
				jailed[playerid] = 1;
				jailtime[playerid] = 5;
				dini_IntSet(udb_encode(playername), "jailed", 1);
				dini_IntSet(udb_encode(playername), "jailtime", 5);

				SetPlayerInterior(playerid,10);
				SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}
				JailBreakTime[playerid]=0;
				JailBreaker[playerid]=0;
				JailBreakPassword[playerid]=0;
				JailBreakAttempt[playerid]=7;
				JailBreakWarning[playerid]=0;

		        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to spring the jail.", GetPlayerMoney(playerid), playerid);
		        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);

				return 1;
			}

			JailBreakPassword[playerid] = JailPassword;

		}
	}
	return 1;
}

dcmd_givetime(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		format(strings, sizeof(strings), "It is now %d hour.", worldTime);
		SendClientMessage(playerid, COLOR_MENU , strings);
	}
	return 1;
}

dcmd_hackthebankhelp(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU,"_________________________________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With /hackthebank you can hack into [id] 's bankaccount and transfer");
		SendClientMessage(playerid, COLOR_MENU,"* at most $1.000.000 to your own bank account.");
		SendClientMessage(playerid, COLOR_MENU,"* You have one computer with access to the bank terminal, it is sitting in your safe house in Los Santos.");
		SendClientMessage(playerid, COLOR_MENU,"* Find the computer, type /hackthebank and observe the passwords.");
		SendClientMessage(playerid, COLOR_MENU,"* During some hours the firewall of the bank is lowered for maintenance,");
		SendClientMessage(playerid, COLOR_MENU,"* which gives you the chance to log in. A password will only work at a");
		SendClientMessage(playerid, COLOR_MENU,"* given time, one that worked before will probably not work now anymore.");
        SendClientMessage(playerid, COLOR_MENU,"* One mistake and you will be jailed yourself: wrong password,");
		SendClientMessage(playerid, COLOR_MENU,"* waiting too long are just two examples why you can end up in jail.");
		SendClientMessage(playerid, COLOR_MENU,"_________________________________________________________________________________________________________");
	}
	return 1;
}

dcmd_springbreakhelp(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* With /springbreak you can set all the prisoners free.");
		SendClientMessage(playerid, COLOR_MENU,"* To accomplish this, you need to login to a computer at");
		SendClientMessage(playerid, COLOR_MENU,"* Dillmore police department headquaters, in Dillmore.");
		SendClientMessage(playerid, COLOR_MENU,"* Find the computer, type /springbreak and observe the passwords.");
		SendClientMessage(playerid, COLOR_MENU,"* Only one will work at that given point of time, one that worked before");
		SendClientMessage(playerid, COLOR_MENU,"* will probably not work now anymore.");
        SendClientMessage(playerid, COLOR_MENU,"* One mistake and you will be jailed yourself: wrong password,");
		SendClientMessage(playerid, COLOR_MENU,"* waiting too long are just two examples why you can end up in jail.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________________");
	}
	return 1;
}

dcmd_whois(playerid,params[])  {
	new index = 0;
	new cashamount;
	new bankamount;
    if(IsAdmin(playerid) && adminlevel[playerid] > 0) {

 		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /whois [playerid]. This will display certain information regarding [playerid].");
			return 1;
		}

		giveplayerid = strval(tmps1);

		if (IsPlayerConnected(giveplayerid)) {
            GetPlayerName(giveplayerid, giveplayer, sizeof(giveplayer));
			cashamount=GetPlayerMoney(giveplayerid);
			bankamount=bank[giveplayerid];
			format(strings, sizeof(strings), "* ID %d, Name %s, Cash $%d, Bank $%d.", giveplayerid,giveplayer,cashamount,bankamount);
			SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
		} else {
			format(strings, sizeof(strings), "* Player ID %d is not connected.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
		}
	}
	return 1;
}

dcmd_20(playerid,params[])  {
	#pragma unused params
    if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SendClientMessage(playerid, COLOR_ADMIN_GM, "Userlist of ID over 19:");
		//Manual adjusting when userslots are increased.
		for(new i=20;i<30;i++){
			if(IsPlayerConnected(i)){
				GetPlayerName(i, giveplayer, sizeof(giveplayer));
				format(strings, sizeof(strings), "* ID %d, Name %s", i,giveplayer);
				SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
			} else {
				format(strings, sizeof(strings), "* ID %d is not connected", i);
				SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
			}
		}
	}
					SendDeathMessage(INVALID_PLAYER_ID, playerid, 201);
	return 1;
}

dcmd_30(playerid,params[])  {
	#pragma unused params
    if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SendClientMessage(playerid, COLOR_ADMIN_GM, "Userlist of ID over 29:");
		//Manual adjusting when userslots are increased.
		for(new i=30;i<40;i++){
			if(IsPlayerConnected(i)){
				GetPlayerName(i, giveplayer, sizeof(giveplayer));
				format(strings, sizeof(strings), "* ID %d, Name %s", i,giveplayer);
				SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
			} else {
				format(strings, sizeof(strings), "* ID %d is not connected", i);
				SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
			}
		}
	}
					SendDeathMessage(INVALID_PLAYER_ID, playerid, 201);
	return 1;
}

dcmd_40(playerid,params[])  {
	#pragma unused params
    if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SendClientMessage(playerid, COLOR_ADMIN_GM, "Userlist of ID over 39:");
		//Manual adjusting when userslots are increased.
		for(new i=40;i<50;i++){
			if(IsPlayerConnected(i)){
				GetPlayerName(i, giveplayer, sizeof(giveplayer));
				format(strings, sizeof(strings), "* ID %d, Name %s", i,giveplayer);
				SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
			} else {
				format(strings, sizeof(strings), "* ID %d is not connected", i);
				SendClientMessage(playerid, COLOR_ADMIN_GM, strings);
			}
		}
	}
					SendDeathMessage(INVALID_PLAYER_ID, playerid, 201);
	return 1;
}

dcmd_taxirates(playerid,params[])  {
	#pragma unused params
    new PlayerMoney;
	if(logged[playerid] == 1){
		PlayerMoney=GetPlayerMoney(playerid);
		TotalMoney[playerid]=PlayerMoney+bank[playerid];

		if(TotalMoney[playerid] < 501) {
			SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________");
			SendClientMessage(playerid, COLOR_MENU,"* You can take three taxi rides for free throughout San Andreas.");
			SendClientMessage(playerid, COLOR_MENU,"* When you have used up those three taxi rides, you'll have to earn");
			SendClientMessage(playerid, COLOR_MENU,"* money in order to pay for the rides.");
			SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________");
			return 1;
		}
	    if(TotalMoney[playerid] < 50001) {
 			if (TaxiUsedPoor[playerid] < 3) {
				SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________");
				SendClientMessage(playerid, COLOR_MENU,"* You can take three taxi rides throughout San Andreas at a reduced");
				SendClientMessage(playerid, COLOR_MENU,"* rate of $5,000 . When you have used up those reduced rides, you");
				SendClientMessage(playerid, COLOR_MENU,"* will have to pay the full rate.");
				SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________");
				return 1;
			}
		}

		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* You have to pay the full rate price for the taxi rides.");
		SendClientMessage(playerid, COLOR_MENU,"* First ride:   $10000");
		SendClientMessage(playerid, COLOR_MENU,"* Second ride:  $50000");
		SendClientMessage(playerid, COLOR_MENU,"* Third ride:  $100000");
		SendClientMessage(playerid, COLOR_MENU,"* Fourth ride: $500000");
		SendClientMessage(playerid, COLOR_MENU,"* Fifth ride: $1000000 - Sixth and following rides cost the same.");
		SendClientMessage(playerid, COLOR_MENU,"* As taxi company owner you can ride the taxi at the reduced rate");
		SendClientMessage(playerid, COLOR_MENU,"* of 50% of the corresponding full rate price.");
		SendClientMessage(playerid, COLOR_MENU,"___________________________________________________________________");
	}
	return 1;
}

dcmd_speedo(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* At the Black Market Carparts Salesoffice you can buy a speedometer.");
		SendClientMessage(playerid, COLOR_MENU,"* With /buyspeedo you can buy the speedo paying cash, or you can use");
		SendClientMessage(playerid, COLOR_MENU,"* your creditcard with /creditspeedo .");
		SendClientMessage(playerid, COLOR_MENU,"* Selling the speedometer is possible with /sellspeedo.");
		SendClientMessage(playerid, COLOR_MENU,"* Use /speedoon to turn on the speedometer.");
		SendClientMessage(playerid, COLOR_MENU,"* Use /speedooff to turn the speedometer off.");
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________");
	}
	return 1;
}

dcmd_clearchat(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
    	for (new a=1;a<=10;a++) SendClientMessage(playerid,COLOR_MENU,"\n");
	}
	return 1;
}

dcmd_callmedic(playerid,params[])  {
	#pragma unused params
	new victim[MAX_PLAYER_NAME];
	new medical[MAX_PLAYER_NAME];
	new ownerAngel;
	new ownerElQ;
	if(logged[playerid] == 1){

		ownerAngel=propertyOwner[P_ANGELMED];
		ownerElQ=propertyOwner[P_ELQMED];

		if(ownerAngel==999 && ownerElQ == 999){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* There is no medical officer currently present.");
			return 1;
		}

		if(ownerAngel==playerid || ownerElQ==playerid){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You ARE the medical officer, you can't call yourself!");
			return 1;
		}

		if(ownerAngel!=999){
			GetPlayerName(playerid, victim, sizeof(victim));
			GetPlayerName(ownerAngel, medical, sizeof(medical));
			format(strings, sizeof(strings), "* Player %s requested your service as medical officer.", victim);
			SendClientMessage(ownerAngel, COLOR_SYSTEM_GM , strings);
			format(strings, sizeof(strings), "* You requested the medical serviced of player %s. He has been notified.", medical);
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
		}
		if(ownerElQ!=999){
			GetPlayerName(playerid, victim, sizeof(victim));
			GetPlayerName(ownerElQ, medical, sizeof(medical));
			format(strings, sizeof(strings), "* Player %s requested your service as medical officer.", victim);
			SendClientMessage(ownerElQ, COLOR_SYSTEM_GM , strings);
			format(strings, sizeof(strings), "* You requested the medical serviced of player %s. He has been notified.", medical);
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
		}
	}
	return 1;
}

dcmd_eaglematch(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't join the desert eagle deathmatch, you already subscribed you to one.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(eaglematchinprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* There is already a desert eagle deathmatch in progress, please wait for it to finish.");
			return 1;
		}
		if(eaglematchplayers[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You are already signed up for this deathmatch!");
			return 1;
		}
	 	if(eaglematchinprogress == 0){
	        if(playerseaglematch < 2){
	            if(playerseaglematch == 0){
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $10000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					eaglecountdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a desert eagle DM",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a desert eagle deathmatch. Type /eaglematch to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					eaglematch[0]=1;
					eaglematchstarted=1;
					eaglematchplayers[playerid]=1;
					playerseaglematch=1;
					DMplayer[playerid]=1;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $10000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					eaglematch[1]=1;
					eaglematchplayers[playerid]=1;
					playerseaglematch=2;
					DMplayer[playerid]=1;
					format(strings, sizeof(strings), "Desert eagle DM is full and will start in %d seconds", eaglecountdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for the current match to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, there is already an eagle deathmatch in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_chainmatch(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't join the chainsaw massacre, you already subscribed you to one.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(chainmatchinprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* There is already a chainsaw massacre in progress, please wait for it to finish.");
			return 1;
		}
		if(chainmatchplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already signed up for this deathmatch.");
			return 1;
		}
	    if(chainmatchinprogress == 0){
	        if(playerschainmatch<4){
	            if(playerschainmatch==0){
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $10000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a chainsaw massacre",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a chainsaw massacre minigame. Type /chainmatch to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					chainmatch[0]=1;
					chainmatch[1]=0;
					chainmatch[2]=0;
					chainmatch[3]=0;
					chaincountdownseconds = 30;
					chainmatchstarted=1;
					playerschainmatch=1;
					chainmatchprice=10000;
					chainmatchplayers[playerid]=1;
					DMplayer[playerid]=1;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $10000.");
						return 1;
					}
					for(new i=0;i<4;i++){
					    if(chainmatch[i] == 0){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 10000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, -10000, strings);
							chainmatchprice=chainmatchprice+10000;
							chainmatch[i]=1;
							playerschainmatch++;
							chainmatchplayers[playerid]=1;
							DMplayer[playerid]=1;
							chainmatchprice=chainmatchprice+10000;
							return 1;
						}
					}
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for the current match to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, there is already an eagle deathmatch in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_minimatch(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't join the minigun madness, you already subscribed you to one.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(minimatchinprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* There is already a minigun madness in progress, please wait for it to finish.");
			return 1;
		}
		if(minimatchplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already signed up for this deathmatch.");
			return 1;
		}
	    if(minimatchinprogress == 0){
	        if(playersminimatch<6){
	            if(playersminimatch==0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a minigun madness",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a minigun madness minigame. Type /minimatch to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					minimatch[0]=1;
					minimatch[1]=0;
					minimatch[2]=0;
					minimatch[3]=0;
					minimatch[4]=0;
					minimatch[5]=0;
					minicountdownseconds = 30;
					minimatchstarted=1;
					playersminimatch=1;
					minimatchprice=25000;
					minimatchplayers[playerid]=1;
					DMplayer[playerid]=1;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $25000.");
						return 1;
					}
					for(new i=0;i<6;i++){
			    		if(minimatch[i] == 0){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 25000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, -25000, strings);
							minimatch[i]=1;
							playersminimatch++;
							minimatchplayers[playerid]=1;
							DMplayer[playerid]=1;
							minimatchprice=minimatchprice+25000;
							return 1;
						}
					}
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for the current match to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, there is already a minigun madness minigame in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_uzimatch(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't join the crazy uzis deathmatch, you already subscribed you to one.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(uzimatchinprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* There is already a crazy uzis deathmatch in progress, please wait for it to finish.");
			return 1;
		}
		if(uzimatchplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already signed up for this deathmatch.");
			return 1;
		}
	    if(uzimatchinprogress == 0){
	        if(playersuzimatch<6){
	            if(playersuzimatch==0){
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $10000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a crazy uzis deathmatch",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a crazy uzis deathmatch. Type /uzimatch to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					uzimatch[0]=1;
					uzimatch[1]=0;
					uzimatch[2]=0;
					uzimatch[3]=0;
					uzimatch[4]=0;
					uzimatch[5]=0;
					uzicountdownseconds = 30;
					uzimatchstarted=1;
					playersuzimatch=1;
					uzimatchprice=10000;
					uzimatchplayers[playerid]=1;
					DMplayer[playerid]=1;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $10000.");
						return 1;
					}
					for(new i=0;i<6;i++){
			    		if(uzimatch[i] == 0){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 10000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, -10000, strings);
							uzimatch[i]=1;
							playersuzimatch++;
							uzimatchplayers[playerid]=1;
							DMplayer[playerid]=1;
							uzimatchprice=uzimatchprice+10000;
							return 1;
						}
					}
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for the current match to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, there is already a uzigun madness uzigame in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}
dcmd_dragrace1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a dragrace.");
	  	    return 1;
		}
		if(dragrace1inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace1players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace1inprogress == 0){
	        if(playersdragrace1 < 2){
	            if(playersdragrace1 == 0){
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $10000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher7[i] = 0;
						dragrace1players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					dragrace1countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 1",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 1. Type /dragrace1 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace1[0]=1;
					dragrace1[1]=0;
					dragrace1started=1;
					dragrace1players[playerid]=1;
					playersdragrace1=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $10000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					dragrace1[1]=1;
					dragrace1players[playerid]=1;
					playersdragrace1=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 1.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				    dragrace1countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 1 is full and will start in %d seconds", dragrace1countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 1 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a dragrace.");
	  	    return 1;
		}
		if(dragrace2inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace2players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace2inprogress == 0){
	        if(playersdragrace2 < 4){
	            if(playersdragrace2 == 0){
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $10000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher8[i] = 0;
						dragrace2players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 10000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					dragrace2countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 2",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 2. Type /dragrace2 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace2[0]=1;
					dragrace2[1]=0;
					dragrace2[2]=0;
					dragrace2[3]=0;
					dragrace2started=1;
					dragrace2players[playerid]=1;
					playersdragrace2=1;
					DMplayer[playerid]=1;
					dragrace2money=20000;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					for(new i=0;i<4;i++){
			    		if(dragrace2[i] == 0){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 10000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, -10000, strings);
							dragrace2money=dragrace2money+10000;
							dragrace2[i]=1;
							dragrace2players[playerid]=1;
							playersdragrace2++;
							GetPlayerName(playerid,playername,sizeof(playername));
							format(strings, sizeof(strings), "%s has joined the drag race type 2.", playername);
							SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
							DMplayer[playerid]=1;
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
							return 1;
						}
					}
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 2 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace3inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace3players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace3inprogress == 0){
	        if(playersdragrace3 < 2){
	            if(playersdragrace3 == 0){
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher9[i] = 0;
						dragrace3players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace3countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 3",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 3. Type /dragrace3 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace3[0]=1;
					dragrace3[1]=0;
					dragrace3started=1;
					dragrace3players[playerid]=1;
					playersdragrace3=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace3[1]=1;
					dragrace3players[playerid]=1;
					playersdragrace3=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 3.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace3countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 3 is full and will start in %d seconds", dragrace3countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 3 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace4(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace4inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace4players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace4inprogress == 0){
	        if(playersdragrace4 < 2){
	            if(playersdragrace4 == 0){
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher11[i] = 0;
						dragrace4players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace4countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 4",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 4. Type /dragrace4 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace4[0]=1;
					dragrace4[1]=0;
					dragrace4started=1;
					dragrace4players[playerid]=1;
					playersdragrace4=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace4[1]=1;
					dragrace4players[playerid]=1;
					playersdragrace4=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 4.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace4countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 4 is full and will start in %d seconds", dragrace4countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 4 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}
dcmd_dragrace5(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace5inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace5players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace5inprogress == 0){
	        if(playersdragrace5 < 2){
	            if(playersdragrace5 == 0){
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $10000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher11[i] = 0;
						dragrace5players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					dragrace5countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 5",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 5. Type /dragrace5 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace5[0]=1;
					dragrace5[1]=0;
					dragrace5started=1;
					dragrace5players[playerid]=1;
					playersdragrace5=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<10000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $10000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -10000, strings);
					dragrace5[1]=1;
					dragrace5players[playerid]=1;
					playersdragrace5=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 5.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace5countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 5 is full and will start in %d seconds", dragrace5countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 5 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace6(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace6inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace6players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace6inprogress == 0){
	        if(playersdragrace6 < 2){
	            if(playersdragrace6 == 0){
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher11[i] = 0;
						dragrace6players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace6countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 6",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 6. Type /dragrace6 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace6[0]=1;
					dragrace6[1]=0;
					dragrace6started=1;
					dragrace6players[playerid]=1;
					playersdragrace6=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace6[1]=1;
					dragrace6players[playerid]=1;
					playersdragrace6=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 6.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace6countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 6 is full and will start in %d seconds", dragrace6countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 6 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace7(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace7inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace7players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace7inprogress == 0){
	        if(playersdragrace7 < 2){
	            if(playersdragrace7 == 0){
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher11[i] = 0;
						dragrace7players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace7countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 7",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 7. Type /dragrace7 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace7[0]=1;
					dragrace7[1]=0;
					dragrace7started=1;
					dragrace7players[playerid]=1;
					playersdragrace7=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace7[1]=1;
					dragrace7players[playerid]=1;
					playersdragrace7=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 7.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace7countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 7 is full and will start in %d seconds", dragrace7countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 7 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace8(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace8inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace8players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace8inprogress == 0){
	        if(playersdragrace8 < 2){
	            if(playersdragrace8 == 0){
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher11[i] = 0;
						dragrace8players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace8countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 8",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 8. Type /dragrace8 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace8[0]=1;
					dragrace8[1]=0;
					dragrace8started=1;
					dragrace8players[playerid]=1;
					playersdragrace8=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $20000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					dragrace8[1]=1;
					dragrace8players[playerid]=1;
					playersdragrace8=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 8.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace8countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 8 is full and will start in %d seconds", dragrace8countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 8 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_dragrace9(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this dragrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a dragrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a dragrace.");
	  	    return 1;
		}
		if(dragrace9inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a drag race in progress, please wait for it to finish.");
			return 1;
		}
		if(dragrace9players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this deagrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a dragrace.");
			return 1;
		}
	 	if(dragrace9inprogress == 0){
	        if(playersdragrace9 < 2){
	            if(playersdragrace9 == 0){
					if(GetPlayerMoney(playerid)<40000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $40000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher11[i] = 0;
						dragrace9players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -40000, strings);
					dragrace9countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a drag race type 9",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a drag race type 9. Type /dragrace9 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					dragrace9[0]=1;
					dragrace9[1]=0;
					dragrace9started=1;
					dragrace9players[playerid]=1;
					playersdragrace9=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<40000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this drag race. You need $40000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -40000, strings);
					dragrace9[1]=1;
					dragrace9players[playerid]=1;
					playersdragrace9=2;
					DMplayer[playerid]=1;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the drag race type 9.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				    dragrace9countdownseconds = 5;
					format(strings, sizeof(strings), "The drag race type 9 is full and will start in %d seconds", dragrace9countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the dragrace.");
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a drag race type 9 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_sprintrace1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprint race since you are already subscribed you to a deathmatch or race.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprintrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a sprint race.");
	  	    return 1;
		}
		if(sprintrace1inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace1players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprint race!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprintrace.");
			return 1;
		}
	 	if(sprintrace1inprogress == 0){
	        if(playerssprintrace1 < 4){
	            if(playerssprintrace1 == 0){
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $20000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher10[i] = 0;
						sprintrace1players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -20000, strings);
					sprintrace1countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a sprint race type 1",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 1. Type /sprintrace1 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					sprintrace1[0]=1;
					sprintrace1[1]=0;
					sprintrace1[2]=0;
					sprintrace1money=20000;
					sprintrace1[3]=0;
					sprintrace1started=1;
					sprintrace1players[playerid]=1;
					playerssprintrace1=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprint race.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<20000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $20000.");
						return 1;
					}
					for(new i=0;i<4;i++){
			    		if(sprintrace1[i] == 0){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 20000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, -20000, strings);
							sprintrace1money=sprintrace1money+20000;
							sprintrace1[i]=1;
							sprintrace1players[playerid]=1;
							playerssprintrace1++;
							DMplayer[playerid]=1;
							GetPlayerName(playerid,playername,sizeof(playername));
							format(strings, sizeof(strings), "%s has joined the sprint race type 1.", playername);
							SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprint race.");
							return 1;
						}
					}
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 1 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_sprintrace2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprint race since you are already subscribed you to a deathmatch or race.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprint race.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can participate in a sprint race.");
	  	    return 1;
		}
		if(sprintrace2inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace2players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprint race!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprint race.");
			return 1;
		}
	 	if(sprintrace2inprogress == 0){
	        if(playerssprintrace2 < 4){
	            if(playerssprintrace2 == 0){
					if(GetPlayerMoney(playerid)<30000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $30000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher12[i] = 0;
						sprintrace2players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a drag race.", playerid, 30000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -30000, strings);
					sprintrace2countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a Sprint race type 2",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 2. Type /sprintrace2 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					sprintrace2[0]=1;
					sprintrace2[1]=0;
					sprintrace2[2]=0;
					sprintrace2[3]=0;
					sprintrace2started=1;
					sprintrace2players[playerid]=1;
					playerssprintrace2=1;
					DMplayer[playerid]=1;
					sprintrace2money=30000;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprint race.");
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<30000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $30000.");
						return 1;
					}
					for(new i=0;i<4;i++){
			    		if(sprintrace2[i] == 0){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a sprint race.", playerid, 30000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, -30000, strings);
							sprintrace2money=sprintrace2money+30000;
							sprintrace2[i]=1;
							sprintrace2players[playerid]=1;
							playerssprintrace2++;
							DMplayer[playerid]=1;
							GetPlayerName(playerid,playername,sizeof(playername));
							format(strings, sizeof(strings), "%s has joined the sprint race type 2.", playername);
							SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprint race.");
							return 1;
						}
					}
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 2 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_buyspeedo(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(GetPlayerMoney(playerid)<2500000){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry sir, the speedometer currently costs $2.500.000 .");
					return 1;
				}
				if(speedometer[playerid]==1){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already have a speedometer, you can't buy another one .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he bought a speedometer.", playerid, 25000000, GetPlayerMoney(playerid));
				StatGivePlayerMoney(playerid, -2500000, strings);
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has bought a speedometer for $2500000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "The speedometer is turned off by default. Use /speedoon and /speedooff to switch the state.");
				speedometer[playerid]=1;
				dini_IntSet(udb_encode(playername), "speedometer", speedometer[playerid]);
				return 1;
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy a speedometer here. Check with your local black market salesman.");
				return 1;
			}
		}
	}
	return 1;
}

dcmd_speedooff(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(speedometer[playerid]==0){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You don't have a speedometer, so there is nothing to switch off.");
			return 1;
		}
		if(speedometeron[playerid]==0){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The speedometer is already off!");
			return 1;
		}
		GetPlayerName(playerid,playername,sizeof(playername));
		speedometeron[playerid]=0;
		calculatespeed[playerid]=0;
		SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The speedometer has been turned off!");
		dini_IntSet(udb_encode(playername), "speedoon", speedometeron[playerid]);
	}
	return 1;
}

dcmd_speedoon(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(speedometer[playerid]==0){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You don't have a speedometer, so there is nothing to switch on.");
			return 1;
		}
		if(speedometeron[playerid]==1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The speedometer is already on!");
			return 1;
		}
		GetPlayerName(playerid,playername,sizeof(playername));
		speedometeron[playerid]=1;
		SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The speedometer has been turned on!");
		dini_IntSet(udb_encode(playername), "speedoon", speedometeron[playerid]);
	}
	return 1;
}

dcmd_sellspeedo(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(speedometer[playerid]==0){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell what you don't have! .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because he sold a speedometer.", playerid, 250000, GetPlayerMoney(playerid));
				StatGivePlayerMoney(playerid, 250000, strings);
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has sold a speedometer for $250000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				speedometer[playerid]=0;
				dini_IntSet(udb_encode(playername), "speedometer", speedometer[playerid]);
				return 1;
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell your speedometer here. Check with your local black market salesman.");
				return 1;
			}
		}
	}
	return 1;
}

dcmd_flip(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerDriver(playerid)){
			new VehicleID;
  			VehicleID = GetPlayerVehicleID(playerid);
  			SetVehiclePos(VehicleID, X250[playerid], Y250[playerid], Z250[playerid]);
  			SetVehicleZAngle(VehicleID, 0);
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can flip the car.");
		}
	}
	return 1;
}

dcmd_clue(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    if(GoldPotActive == 1){
			format(strings, sizeof(strings), "* The clue: %s", propertyNames[GoldPotChoice-P_OFFSET]);
			SendClientMessage(playerid,COLOR_GOLD, strings);
		} else {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Currently there is no pot of gold for grabs. Wait around, it will come soon.");
		}
	}
	return 1;
}

dcmd_kickpassenger(playerid,params[])  {
	new index = 0;
	new vehicleid;
	new vehicleid2;
	new victimid;
	if(logged[playerid] == 1){
		GetPlayerName(playerid,playername,sizeof(playername));

		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* USAGE: /kickpassenger [playerid] to kick a passenger out of your vehicle.");
			return 1;
		}
		if(IsPlayerInAnyVehicle(playerid)){
			victimid = strval(tmps1);
			if (playerid == victimid){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't kick yourself out of the car.");
				return 1;
			}
			if(IsPlayerDriver(playerid)){
				if(!IsPlayerConnected(victimid)){
					SendClientMessage(playerid,COLOR_SYSTEM_GM,"* That player is not connected...");
					return 1;
				}
				vehicleid = GetPlayerVehicleID(playerid);
				vehicleid2= GetPlayerVehicleID(victimid);
				if(vehicleid != vehicleid2){
					SendClientMessage(playerid,COLOR_SYSTEM_GM,"* That player is not in your vehicle...");
					return 1;
				}
				RemovePlayerFromVehicle(victimid);
				format(strings,sizeof(strings),"* You have been kicked out of %s's vehicle.",playername);
				SendClientMessage(victimid,COLOR_RED,strings);
			} else {
				SendClientMessage(playerid,COLOR_SYSTEM_GM,"* Passengers can't use this!");
			}
		} else {
			SendClientMessage(playerid,COLOR_SYSTEM_GM,"* You need to be in a vehicle to use this");
		}
	}
	return 1;
}

dcmd_payandspray(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(payandspray[playerid] != 0){
			format (strings, sizeof(strings), "* Sorry, you'll have to wait %d minutes before you can respray again.",payandspray[playerid]);
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
			return 1;
		}
		if(GetPlayerMoney(playerid)<250000){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need $250 000 to use this service.");
			return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to respray it.");
			return 1;
		}
		if(IsPlayerDriver(playerid)){
			GetPlayerName(playerid,playername,sizeof(playername));
            CarSprayCountdown[playerid]=21;
            payandspray[playerid]=10;
			askedpayandspray[playerid]=1;
			format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he resprayed his vehicle.", playerid, 2500000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, -250000, strings);
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings), "%s has requested a respray of his vehicle for $250 000.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can respray the car.");
		}
	}
	return 1;
}

dcmd_lowtuner(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(GetPlayerMoney(playerid)<250000){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need $250 000 to use this service.");
			return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to take a teleport to the lowriders tuner.");
			return 1;
		}
		if(IsPlayerDriver(playerid)){
			GetPlayerName(playerid,playername,sizeof(playername));
            LowTunerCountdown[playerid]=21;
			askedlowtuner[playerid]=1;
			format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he teleported to the lowrider tuner.", playerid, 250000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, -250000, strings);
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings), "%s has requested a teleport with his car to the lowrider tuner in Los Santos for $250 000.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
			SendClientMessage(playerid, COLOR_LIGHTBLUE, "* Note: This function works properly when in a car. If you wish to cancel, type /canceltuner.");
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can request a car telepot.");
		}
	}
	return 1;
}

dcmd_streettuner(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(GetPlayerMoney(playerid)<250000){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need $250 000 to use this service.");
			return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to take a teleport to the streetracers tuner.");
			return 1;
		}
		if(IsPlayerDriver(playerid)){
			GetPlayerName(playerid,playername,sizeof(playername));
            StreetTunerCountdown[playerid]=21;
			askedstreettuner[playerid]=1;
			format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he teleported to the street racers tuner.", playerid, 250000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, -250000, strings);
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings), "%s has requested a teleport with his car to the streetracers tuner in San Fierro for $250 000.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
			SendClientMessage(playerid, COLOR_LIGHTBLUE, "* Note: This function works properly when in a car. If you wish to cancel, type /canceltuner.");
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can request a car telepot.");
		}
	}
	return 1;
}

dcmd_backtolv(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to take a teleport to the streetracers tuner.");
			return 1;
		}
		if(readylowtuner[playerid]==0 && readystreettuner[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* This function is only available when you have tuned your car at the lowrider or streetracer tuner.");
			return 1;
		}
		if(IsPlayerDriver(playerid)){
			GetPlayerName(playerid,playername,sizeof(playername));
			if(readylowtuner[playerid]==1){
	            LowTunerCountdown[playerid]=11;
				lowtunerback[playerid]=1;
				format(strings, sizeof(strings), "%s has requested to be teleported with his car back to Las Venturas after visiting the lowrider tuner.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				return 1;
			}
			if(readystreettuner[playerid]==1){
	            StreetTunerCountdown[playerid]=11;
				streettunerback[playerid]=1;
				format(strings, sizeof(strings), "%s has requested to be teleported with his car back to Las Venturas after visiting the streetracer tuner.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				return 1;
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can request a car telepot.");
		}
	}
	return 1;
}

dcmd_cancelback(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		askedlowtuner[playerid]=0;
		readylowtuner[playerid]=0;
		lowtunerback[playerid]=0;
		askedstreettuner[playerid]=0;
		readystreettuner[playerid]=0;
		streettunerback[playerid]=0;
		SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Values resetted, you can no longer use /backtolv.");
		Teleporting[playerid]=0;
	}
	return 1;
}

dcmd_canceltuner(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		askedlowtuner[playerid] = 0;
	    LowTunerCountdown[playerid] = 0;
		askedstreettuner[playerid] = 0;
	    StreetTunerCountdown[playerid] = 0;
		SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Tuner teleport request has been canceled.");
	}
	return 1;
}

dcmd_grouptalk(playerid,params[])  {
	#pragma unused params
	new GroupTalkID;
	if(logged[playerid] == 1){
		if(GroupTalkers[playerid] != 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have started a new grouptalk, you can no longer send or receive messaged of your previous grouptalk.");
			GroupTalkID=GroupTalkers[playerid];
			GroupTalkers[playerid]=0;
			GetPlayerName(playerid,playername,sizeof(playername));
			for(new i=0;i<MAX_PLAYERS;i++){
		    	if(GroupTalkers[i]==GroupTalkID){
					format(strings, sizeof(strings), "* %s has left your grouptalk.", playername);
					SendClientMessage(i, COLOR_SYSTEM_PM, strings);
				}
			}
		}
		if(GroupTalk == 0){
			GroupTalk = 1;
		}
		format(strings, sizeof(strings), "* You have started a new grouptalk with ID %d.", GroupTalk);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		format(strings, sizeof(strings), "* You can invite players to this grouptalk with the command /groupinvite [playerid].");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Type # in front of your message to talk to the group.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Type /grouphelp for grouptalk related commands.");
		GroupTalkers[playerid]=GroupTalk;
		GroupTalk++;
	}
	return 1;
}

dcmd_groupinvite(playerid,params[])  {
	new index = 0;
	new friendid;
	new friendname[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		GetPlayerName(playerid,playername,sizeof(playername));

		if(GroupTalkers[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have to start a grouptalk before you can invite people.");
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Use the command /grouptalk and invite the player again.");
			return 1;
		}
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* USAGE: /groupinvite [playerid]. With this command you can invite someone to your grouptalk.");
			return 1;
		}
		friendid = strval(tmps1);
		if(!IsPlayerConnected(friendid)){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* That player is not connected...");
			return 1;
		}
		GetPlayerName(friendid,friendname,sizeof(friendname));
		format(strings, sizeof(strings), "* You have invited %s (id %d) to your grouptalk.", friendname, friendid);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		format(strings, sizeof(strings), "* %s has invited you to his grouptalk. Type /groupaccept to accept the invitation, /groupdeny to deny it.", playername);
		SendClientMessage(friendid, COLOR_SYSTEM_PM, strings);
		GroupInvites[friendid]=GroupTalkers[playerid];
		GroupInviter[friendid]=playerid;
	}
	return 1;
}

dcmd_groupaccept(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new GroupTalkID;
		GetPlayerName(playerid,playername,sizeof(playername));

		if(GroupInvites[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are currently not invited to anyones grouptalk, so there is nothing to accept.");
			return 1;
		}
		GroupTalkID=GroupInvites[playerid];
		for(new i=0;i<MAX_PLAYERS;i++){
		    if(GroupTalkers[i]==GroupTalkID){
				format(strings, sizeof(strings), "* %s has joined your grouptalk.", playername);
				SendClientMessage(i, COLOR_SYSTEM_PM, strings);
			}
		}
		format(strings, sizeof(strings), "* You have joined the grouptalk with ID %d.", GroupInvites[playerid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		format(strings, sizeof(strings), "* You can invite players to this grouptalk with the command /groupinvite [playerid].");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Type # in front of your message to talk to the group.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Type /grouphelp for grouptalk related commands.");
		GroupTalkers[playerid]=GroupInvites[playerid];
		GroupInvites[playerid]=0;
		GroupInviter[playerid]=0;
	}
	return 1;
}

dcmd_groupdeny(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new inviter;
		if(GroupInvites[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are currently not invited to anyones grouptalk, so there is nothing to deny.");
			return 1;
		}
		format(strings, sizeof(strings), "* You have denied the invitation for grouptalk ID %d.", GroupInvites[playerid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		inviter=GroupInviter[playerid];
		GetPlayerName(playerid,playername,sizeof(playername));
		format(strings, sizeof(strings), "* Player %s (id %d) has denied your invitation.", playername, playerid);
		SendClientMessage(inviter, COLOR_SYSTEM_PM, strings);
		GroupInvites[playerid]=0;
		GroupInviter[playerid]=0;
	}
	return 1;
}

dcmd_grouplist(playerid,params[])  {
	#pragma unused params
	new GroupTalkID;
	new Talkers [MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		if(GroupTalkers[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You are no part of a grouptalk at this moment.");
			return 1;
		}
		GroupTalkID=GroupTalkers[playerid];
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* List of players in your grouptalk:");
		for(new i=0;i<MAX_PLAYERS;i++){
		    if(GroupTalkers[i]==GroupTalkID){
				GetPlayerName(i,Talkers,sizeof(Talkers));
				format(strings, sizeof(strings), "* %s with id %d", Talkers, i);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			}
		}
	}
	return 1;
}

dcmd_groupleave(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new GroupTalkID;
		new Talkers[MAX_PLAYER_NAME];
		if(GroupTalkers[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You are no part of a grouptalk at this moment so there is nothing to leave.");
			return 1;
		}
		GroupTalkID=GroupTalkers[playerid];
		GetPlayerName(playerid,playername,sizeof(playername));
		GroupTalkers[playerid]=0;
		for(new i=0;i<MAX_PLAYERS;i++){
		    if(GroupTalkers[i]==GroupTalkID){
				GetPlayerName(i,Talkers,sizeof(Talkers));
				format(strings, sizeof(strings), "* %s has left your grouptalk.", playername);
				SendClientMessage(i, COLOR_SYSTEM_PM, strings);
			}
		}
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have left the grouptalk.");
	}
	return 1;
}

dcmd_grouphelp(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(GroupTalkers[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* The commands described in /grouphelp are only valid when you are participating in a grouptalk.");
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Type /grouptalk to start one.");
			return 1;
		}
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* Commands specifically for grouptalks:");
		SendClientMessage(playerid, COLOR_MENU,"* /groupinvite [playerid] : to invite players to your grouptalk");
		SendClientMessage(playerid, COLOR_MENU,"* /groupaccept : to accept a grouptalk invitation");
		SendClientMessage(playerid, COLOR_MENU,"* /grouplist : to see who are part of your grouptalk");
		SendClientMessage(playerid, COLOR_MENU,"* /groupdeny : to deny a grouptalk invitation");
		SendClientMessage(playerid, COLOR_MENU,"* /groupleave : to leave your current grouptalk");
		SendClientMessage(playerid, COLOR_MENU,"* Type # in front of your message to talk to the group. ");
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________");
	}
	return 1;
}

dcmd_invisible(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		SetPlayerColor(playerid, 0xFF820000);
		SendClientMessage(playerid,COLOR_ADMIN_GM,"* You have become invisible on the radar.");
	}
	return 1;
}

dcmd_invis(playerid,params[])  {
	return dcmd_invisible(playerid,params);
}

dcmd_noadinvis(playerid,params[])  {
	#pragma unused params
	new temp;
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
	    if(OwnPlayerColorChosen[playerid] == 0){
		    SetPlayerColor(playerid, playerInvisColors[playerid]);
		} else {
			temp=PlayerInvisibleChoice[OwnPlayerColor[playerid]];
		    SetPlayerColor(playerid, temp);
		}
		SendClientMessage(playerid,COLOR_ADMIN_GM,"* You have become invisible on the radar.");
	}
	return 1;
}

dcmd_visible(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		SetPlayerColor(playerid, COLOR_ADMIN);
		SendClientMessage(playerid,COLOR_ADMIN_GM,"* You have become visible on the radar.");
		AdminPlayer[playerid] = 1;
	}
	return 1;
}

dcmd_vis(playerid,params[])  {
	return dcmd_visible(playerid,params);
}

dcmd_iamnoadmin(playerid,params[])  {
	#pragma unused params
	new temp;
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
	    if(OwnPlayerColorChosen[playerid] == 0){
		    SetPlayerColor(playerid, playerColors[playerid]);
		} else {
			temp=PlayerColorsChoice[OwnPlayerColor[playerid]];
		    SetPlayerColor(playerid, temp);
		}
		SendClientMessage(playerid,COLOR_ADMIN_GM,"* You are no longer colored as an admin.");
		AdminPlayer[playerid] = 0;
	}
	return 1;
}

dcmd_noad(playerid,params[])  {
	return dcmd_iamnoadmin(playerid,params);
}

dcmd_iamadmin(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 0) {
		SetPlayerColor(playerid, COLOR_ADMIN);
		SendClientMessage(playerid,COLOR_ADMIN_GM,"* You are now colored as an admin.");
		AdminPlayer[playerid] = 1;
	}
	return 1;
}

dcmd_iad(playerid,params[])  {
	return dcmd_iamadmin(playerid,params);
}

dcmd_report(playerid,params[])  {
	new index = 0;
	new send;
	new text[256];
	if(logged[playerid] == 1){
		GetPlayerName(playerid,playername,sizeof(playername));
		tmps1 = strtok(params, index);

		if(!strlen(tmps1)) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* USAGE: /report [message]. With this command you can notify all the connected admins about a situation.");
			SendClientMessage(playerid, COLOR_FIREBRICK,"* DO NOT MISUSE THIS FUNCTION. Abusive use can lead to your own ban.");
			return 1;
		}
	    strmid(text, params, strlen(cmd), strlen(params));

		format(strings, sizeof(strings), "* Player %s reports: %s.", playername, text);
		for(new i = 0; i < MAX_PLAYERS; i++) {
	    	if(IsPlayerConnected(i) && IsAdmin(i)) {
				SendClientMessage(i, COLOR_ADMIN_REPORT, strings);
				send=1;
			}
		}
		if(send==0){
		    SendClientMessage(playerid,COLOR_SYSTEM_PM,"* There are no admins connected at this moment.");
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* The admins have received your report. Depending on the content, they will contact you or take action.");
			format(strings, sizeof(strings), "* You submitted this report: %s.", text);
			SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		}
	}
	return 1;
}

dcmd_givespeedo(playerid,params[])  {
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /givespeedo [playerid]. This wil give [playerid] a speedometer.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(IsPlayerConnected(giveplayerid)){
			if(speedometer[giveplayerid]==0){
			    speedometer[giveplayerid]=1;
				dini_IntSet(udb_encode(giveplayername), "speedometer", speedometer[giveplayerid]);
				format(strings, sizeof(strings), "* You have given %s (id: %d) a speedometer.", giveplayername,giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* %s has granted you a speedometer. Type /speedoon to activate it, /speedooff to deactivate it.", playername);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				format(strings, sizeof(strings), "* %s (id: %d) already have a speedometer.", giveplayername,giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
			}
		} else {
			format(strings, sizeof(strings), "* Playr id: %d is not connected.",giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
		}
	}
	return 1;
}

dcmd_spyon(playerid,params[])  {
	new index = 0;
	new spyingon;
	if (IsAdmin(playerid) && adminlevel[playerid] > 1){
		if(SpyPlayer[playerid]==1)
		{
			SendClientMessage(playerid,COLOR_YELLOW,"Already Spectating Someone!");
			return 1;
		}
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1))
		{
			SendClientMessage(playerid,COLOR_YELLOW,"USAGE: /Spyon [playerid] [Zoom 1-50](playerid Invalid)");
			return 1;
		}
		spyingon=strval(tmps1);
		if(!IsPlayerConnected(spyingon)){
			SendClientMessage(playerid,COLOR_YELLOW,"* That player is not connected");
			return 1;
		}
		if(playerid == spyingon){
			SendClientMessage(playerid,COLOR_YELLOW,"* You can't spy on yourself!");
			return 1;
		}
		SetPlayerInterior(playerid, 0);
		SetPlayerPos(playerid, 212.4342,1909.7079,17.6406 + 1);
		SpyPlayer[playerid]=1;
		SpyPlayerOn[playerid]=strval(tmps1);
		TogglePlayerControllable(playerid,0);
		SpyTimer[playerid] = SetTimer("SpyCam",250,1);
	}
	return 1;
}

dcmd_spyoff(playerid,params[])  {
	#pragma unused params
	if (IsAdmin(playerid) && adminlevel[playerid] > 1)
	{
		if (SpyPlayer[playerid]==1)
		{
			SpyPlayer[playerid]=0;
			KillTimer(SpyTimer[playerid]);
			TogglePlayerControllable(playerid,1);
			SpawnPlayer(playerid);
			return 1;
		}
		SendClientMessage(playerid,COLOR_RED,"You're Not Spectating Anyone!");
	}
	return 1;
}

dcmd_spystaton(playerid,params[])  {
	new index = 0;
	if (IsAdmin(playerid) && adminlevel[playerid] > 1)
	{
		new spyingon;
		if(SpyPlayer[playerid]==1){
			SendClientMessage(playerid,COLOR_YELLOW,"Already Spectating Someone!");
			return 1;
		}
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)){
			SendClientMessage(playerid,COLOR_YELLOW,"USAGE: /spystaton [playerid] - to observe a players stats.");
			return 1;
		}
		spyingon=strval(tmps1);
		if(!IsPlayerConnected(spyingon)){
			SendClientMessage(playerid,COLOR_YELLOW,"* That player is not connected");
			return 1;
		}
/*		if(playerid == spyingon){
			SendClientMessage(playerid,COLOR_YELLOW,"* You can't spy on yourself!");
			return 1;
		}*/
		SendClientMessage(playerid,COLOR_YELLOW,"Starting spystat.");
		SpyPlayer[playerid]=1;
		SpyPlayerOn[playerid]=strval(tmps1);
		SpyTimer[playerid] = SetTimer("SpyStat",250,1);
	}
	return 1;
}

dcmd_ssn(playerid,params[])  {
	return dcmd_spystaton(playerid,params);
}

dcmd_spystatoff(playerid,params[])  {
	#pragma unused params
	if (IsAdmin(playerid) && adminlevel[playerid] > 1){
		if (SpyPlayer[playerid]==1){
			SpyPlayer[playerid]=0;
			KillTimer(SpyTimer[playerid]);
			SendClientMessage(playerid,COLOR_YELLOW,"Spystat has been stopped!");
			return 1;
		}
		SendClientMessage(playerid,COLOR_RED,"You're Not Spectating Anyone!");
	}
	return 1;
}

dcmd_ssf(playerid,params[])  {
	return dcmd_spystatoff(playerid,params);
}

dcmd_fillup(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerDriver(playerid)){
			new VehicleID, StationLoc;
			StationLoc=IsVehicleAtStation(playerid);
	        if( StationLoc == 999){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, you need to be at or closer to a gasstation to use this service.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can view the locations of the gasstations with /gaslocs.");
				return 1;
			}
  			VehicleID = GetPlayerVehicleID(playerid);
			VehicleGroup[playerid]=WhichVehicleGroup(VehicleID);
			if(VehicleGroup[playerid] < 5 || VehicleGroup[playerid] == 11){
			    if(StationLoc >= 17){
				    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Sorry sir, we do not sell normal gasoline. You'd better find a gasstation.");
					return 1;
				}
			}
			if(VehicleGroup[playerid] == 5){
			    if(StationLoc <= 20){
				    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* What an achievement to get your boat to this refill location!");
				    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* However, we do not sell gasoline for boats. You'd better try a hardbour for refilling.");
					return 1;
				}
			}
			if(VehicleGroup[playerid] > 5 && VehicleGroup[playerid] < 11){
			    if(StationLoc <= 16 || StationLoc >= 21){
				    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Sorry sir, we do not sell kerosine, it is only sold at airports.");
					return 1;
				}
			}
			TogglePlayerControllable(playerid,0);
			Tanking[playerid] = 1;
            TotalPetrol[playerid] = 0;
			PlayerPlaySound(playerid,1022,X250[playerid],Y250[playerid],Z250[playerid]);
            SendClientMessage(playerid,COLOR_SYSTEM_PM,"* Starting refilling. Please do not move during the refill.");
            SendClientMessage(playerid,COLOR_SYSTEM_PM,"* You can stop the refilling with /fillstop or wait till the tank is full for the autmatic stop.");
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can refill the vehicle.");
		}
	}
	return 1;
}

dcmd_fillupcan(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerDriver(playerid)){
		    if(Fuelcan[playerid] == 0){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have an emergency fuel can which can be filled.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Visit the black market if you are interested in purchasing one.");
				return 1;
		    }
			new StationLoc;
			StationLoc=IsVehicleAtStation(playerid);
	        if( StationLoc == 999){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, you need to be at or closer to a gasstation to use this service.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can view the locations of the gasstations with /gaslocs.");
				return 1;
			}
		    if(FuelcanContent[playerid] == 1){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Your emergency fuel can is already filled, it cannot be topped even more.");
				return 1;
		    }
            if(GetPlayerMoney(playerid) < 1000) {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash to fill up your fuel can, you need $ 1000.");
				return 1;
            }
			FuelcanContent[playerid]=1;
			format(strings, sizeof(strings), "* Money decreased by $%d (old: $%d), because player-id %d refilled his fuel can", 1000, GetPlayerMoney(playerid), playerid);
			StatGivePlayerMoney(playerid, -1000, strings);
            SendClientMessage(playerid,COLOR_SYSTEM_PM,"* Your emergency fuel can has been refilled.");
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can refill the vehicle.");
		}
	}
	return 1;
}

dcmd_fillstop(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
	    if(Tanking[playerid] == 1){
			format(strings,sizeof(strings),"* Refilling operation stopped. You purchased %d liters. Have a nice day.",TotalPetrol[playerid]);
			SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
			TogglePlayerControllable(playerid,1);
			Tanking[playerid] = 0;
			TotalPetrol[playerid] = 0;
 		} else {
			SendClientMessage(playerid,COLOR_SYSTEM_PM,"* There is no refilling operation in progress, so there is nothing to stop");
		}
	}
	return 1;
}

dcmd_viewtank(playerid,params[])  {
	#pragma unused params
    new Petrol, CurrentID, PetrolInTank;
	if(logged[playerid] == 1){
		if(IsPlayerInAnyVehicle(playerid)){
		    CurrentID=GetPlayerVehicleID(playerid);
			VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
			if(VehicleGroup[playerid] != 10){
			    Petrol=floatround(VehiclePetrol[CurrentID]);
				PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
				format(strings,sizeof(strings),"* Your tank holds %d liter which is %d %% full",Petrol, PetrolInTank);
				SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
			} else {
			    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Your bike isn't running on petrol, it's running on pure mussle power.");
			}
		} else {
		    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You need to be in a car to view the content of its petrol tank.");
		}
	}
	return 1;
}

dcmd_gaslocs(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* Areas in which you can find a gasstation:");
		SendClientMessage(playerid, COLOR_MENU,"* Land => LS: Vinewood, Idlewood *** SF: Eastern Basin, Juniper Hollow");
		SendClientMessage(playerid, COLOR_MENU,"* Land => Badlands: Flint county, Dillmore, Montgommery, Angel Pine, Whetstone");
		SendClientMessage(playerid, COLOR_MENU,"* Land => Desert: El Quabrados, Bone County, Tierra Robada");
		SendClientMessage(playerid, COLOR_MENU,"* Land => LV: Spinybed, Redsands, Behind Come-a-lot, Emerald isle, Besides Come-a-lot");
		SendClientMessage(playerid, COLOR_MENU,"* Sea  => LS: Marina *** SF: Eastern basin *** Desert: Bayside");
		SendClientMessage(playerid, COLOR_MENU,"* Sea  => LV: Rockshore West, Randolph Industrial Estate");
		SendClientMessage(playerid, COLOR_MENU,"* Air  => LS: Airport *** SF: Airport *** Desert: Abandoned airport *** LV: Airport");
		SendClientMessage(playerid, COLOR_MENU,"* When searching for sea or air locations: look for spinning fuelpumps.");
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________________________");
	}
	return 1;
}

dcmd_fuelmeteron(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(FuelmeterOff[playerid]==0){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The fuelmeter is already on!");
			return 1;
		}
		FuelmeterOff[playerid]=0;
		SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The fuelmeter has been turned on!");
		dini_IntSet(udb_encode(playername), "fuelmeteroff", FuelmeterOff[playerid]);
	}
	return 1;
}

dcmd_fuelmeteroff(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(FuelmeterOff[playerid]==1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The fuelmeter is already off!");
			return 1;
		}
		FuelmeterOff[playerid]=1;
		SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The fuelmeter has been turned off!");
		dini_IntSet(udb_encode(playername), "fuelmeteroff", FuelmeterOff[playerid]);
	}
	return 1;
}

dcmd_spawnmethere(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1))
		{
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* USAGE: /spawnmethere [spawnlocid] . Check /spawnlocs for valid id's.");
			return 1;
		}
		spawnloc[playerid]=strval(tmps1);
		if(spawnloc[playerid] < 0 || spawnloc[playerid] > 8){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You selected an invalid spawnlocation id. Check /spawnlocs for valid id's.");
			return 1;
		}
		if(bank[playerid] < OwnSpawnPrices[spawnloc[playerid]]){
			format(strings,sizeof(strings),"* You do not have enough on your bank account to set this spawn location, you need $%d.", OwnSpawnPrices[spawnloc[playerid]]);
			SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
			return 1;
		}

		bank[playerid]-=OwnSpawnPrices[spawnloc[playerid]];
		GetPlayerName(playerid,playername,sizeof(playername));
    	dini_IntSet(udb_encode(playername), "ownspawn", 1);
    	dini_FloatSet(udb_encode(playername), "x", OwnSpawnLocations[spawnloc[playerid]][0]);
     	dini_FloatSet(udb_encode(playername), "y", OwnSpawnLocations[spawnloc[playerid]][1]);
      	dini_FloatSet(udb_encode(playername), "z", OwnSpawnLocations[spawnloc[playerid]][2]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have set your spawn location, you will spawn there from now on.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* If you want to change that, use the command /spawnlocoff . However, you will NOT get your money back!.");
		format(strings, sizeof(strings), "* Player %s has just purchased a spawn location for $%d.",playername,OwnSpawnPrices[spawnloc[playerid]]);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		OwnSpawner[playerid]=1;
	}
	return 1;
}

dcmd_spawnlocoff(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
    	dini_IntSet(udb_encode(playername), "ownspawn", 0);
		SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You have disabled your fixed spawn location, you will spawn randomly again");
		OwnSpawner[playerid]=0;
	}
	return 1;
}

dcmd_spawnlocs(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________________________");
		SendClientMessage(playerid, COLOR_MENU,"* You can select one of the following spawn locations:");
		SendClientMessage(playerid, COLOR_MENU,"* 0. LS: Near lowrider tuner. Price: $37.5 mil *** 1. SF: At Wangs Cars. Price: $100 mil");
		SendClientMessage(playerid, COLOR_MENU,"* 2. LV: Near the golf course. Price: $62.5 mil");
		SendClientMessage(playerid, COLOR_MENU,"* 3. LV: In Creek, close to V Rock hotel. Price: $ 25 mil");
		SendClientMessage(playerid, COLOR_MENU,"* 4. LV: Pilgrim, near Aztec Motel. Price $75 mil *** 5. LS: Grove street. Price $87.5 mil");
		SendClientMessage(playerid, COLOR_MENU,"* 6. LS: Mad Dogg's mansion. Price $150 mil *** 7. LV: At LVPD. Price: $11 mil");
		SendClientMessage(playerid, COLOR_MENU,"* 8. LV: At Royal Casino. Price $15 mil");
		SendClientMessage(playerid, COLOR_MENU,"* You can inspect each location with the command /spawnview [spawnlocationid] .");
		SendClientMessage(playerid, COLOR_MENU,"* If you buy a spawn location, the amount will be taken out of your bank account.");
		SendClientMessage(playerid, COLOR_MENU,"_____________________________________________________________________________________");
	}
	return 1;
}

dcmd_spawnview(playerid,params[])  {
	new index = 0;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1))
		{
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* USAGE: /spawnview [spawnlocid] . Check /spawnlocs for valid id's.");
			return 1;
		}
		spawnloc[playerid]=strval(tmps1);
		if(spawnloc[playerid] < 0 || spawnloc[playerid] > 8){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You selected an invalid spawnlocation id. Check /spawnlocs for valid id's.");
			return 1;
		}
		if(IsPlayerInInterior(playerid)){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You need to be outside in order to request a view of a spawn lcoation.");
			return 1;
		}

		if(GetPlayerMoney(playerid) < 25000){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You need $ 25 000 to inspect a spawn location.");
			return 1;
		}

		if(SpawnViewer[playerid] == 1){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You'll have to wait till you are back before you can review another location.");
			return 1;
		}

		format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he checked out a spawn location.", playerid, 25000, GetPlayerMoney(playerid));
		StatGivePlayerMoney(playerid, -25000, strings);
		GetPlayerPos(playerid,PF[playerid],QF[playerid],RF[playerid]);
		SpawnViewCountdown[playerid] = 20;
		AskedSpawnView1[playerid]=1;
		SpawnViewer[playerid]=1;
	}
	return 1;
}

dcmd_adminspawn(playerid,params[])  {
	#pragma unused params
	if (IsAdmin(playerid) && adminlevel[playerid] > 1){
    	dini_IntSet(udb_encode(playername), "ownspawn", 1);
    	dini_FloatSet(udb_encode(playername), "x", 217.5765);
     	dini_FloatSet(udb_encode(playername), "y", 1859.4368);
      	dini_FloatSet(udb_encode(playername), "z", 13.5000);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have set your spawn location, you will spawn there from now on.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* If you want to change that, use the command /spawnlocoff . However, you will NOT get your money back!.");
		OwnSpawner[playerid]=1;
	}
	return 1;
}

dcmd_medic(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(MedicalOfficer[playerid] == 0){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* To start a medical mission you need to be a medical officer, which you become by owning a medical center.");
			return 1;
		}
		if(MedicalOfficerOnMission[playerid] == 1){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You are already on a medical mission.");
			return 1;
		}
        if(IsPlayerInAnyVehicle(playerid) && GetPlayerState(playerid) == PLAYER_STATE_DRIVER){
			SendClientMessage(playerid,COLOR_SYSTEM_PM,"* Medical mission has started.");
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings),"~b~%s has started a medical mission",playername);
			GameTextForAll(strings,3000,5);
			format(strings, sizeof(strings),"* Player %s has started a medical mission, you can call him/her to heal you with /callmedic.",playername);
			SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
            if(IsPlayerInVehicle(playerid,201)){
				MedicalOfficerOnMission[playerid]=1;
				medicalreward[0]=2500;
				AmbuHealing[0]=playerid;
				return 1;
			}
            if(IsPlayerInVehicle(playerid,202)){
				MedicalOfficerOnMission[playerid]=1;
				medicalreward[1]=2500;
				AmbuHealing[1]=playerid;
				return 1;
			}
		}
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You need to be driving in an ambulance to start a medical mission.");
	}
	return 1;
}

dcmd_medicoff(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(MedicalOfficer[playerid] == 0){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You are not a medical officer, so you can't be performing a medical mission that you can end.");
			return 1;
		}
		if(MedicalOfficerOnMission[playerid] == 0){
			SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You already stopped the medical mission.");
			return 1;
		}
        if(IsPlayerInAnyVehicle(playerid) && GetPlayerState(playerid) == PLAYER_STATE_DRIVER){
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings),"* Player %s has ended the medical mission, you can no longer call him/her.",playername);
			SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM,"* Medical mission has ended.");
            if(IsPlayerInVehicle(playerid,201)){
				MedicalOfficerOnMission[playerid]=0;
				medicalreward[0]=5000;
				AmbuHealing[0]=999;
				return 1;
			}
            if(IsPlayerInVehicle(playerid,202)){
				MedicalOfficerOnMission[playerid]=0;
				medicalreward[1]=5000;
				AmbuHealing[1]=999;
				return 1;
			}
		}
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You can only end a medical mission when you are driving an ambulance.");
	}
	return 1;
}

dcmd_test(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid,COLOR_SYSTEM_PM,"* You are still connected to the server.");
	}
	return 1;
}

dcmd_tip(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* This server is running freeroam v2.3 with lots of addons. The main goal of this server");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* is to make money. With that money you can participate in for instance minigames.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Money can be made by holding the pirate ship (gives you $100 each 2 seconds), buying properties");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* and killing other players for their cash or their bounties.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Type /help to see the various helpmenu's , use /help [command] to see the purpose of that command.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Remember that this is a server for everyone. Obey the rules (defined in /rules (dutch version /rulesnl))");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* and enjoy your time here.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Are you looking for work? Check /jobhelp for the available jobs to earn some money.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* For a dutch version of this story type /tipnl");
	}
	return 1;
}

dcmd_tipnl(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Op deze server draait freeroam v2.3 met veel toevoegingen. Het doel van deze server is het verkrijgen van geld.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Dit geld kan vervolgens gebruikt worden om bijvoorbeeld deel te nemen aan minigames.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Geld kan verdient worden door op het piratenschip in Las Venturas te gaan staan - je krijgt $100 per 2 seconden,");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Handelen in vastgoed en andere spelers doden voor hun geld en het eventuele losgeld.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Met /help kun je diverse helpmenu's zien, /help [commando] kan gebruikt worden voor extra informatie omtrend dat commando.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Denk er aub aan dat deze server wil voorzien in spelplezier voor iedereen.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Hou je aan de regels (te vinden in /rulesnl) en veel speelplezier toegewenst.");
		SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Ben je op zoek naar werk? Type /jobhelp om de beschikbare banen te zien.");
	}
	return 1;
}

dcmd_pcd(playerid,params[])  {
	new index = 0;
	if(RegularPlayer[playerid] == 1 && logged[playerid] == 1) {

		tmps1 = strtok(params, index);

		if(countdownseconds >0) {
			SendClientMessage(playerid, COLOR_ADMIN_PW, "Countdown allready in progress.");
			return 1;
		}

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* USAGE: /pcd [seconds]. This will show a counter in the middle of the screen.");
			return 1;
		}

		countdownseconds=strval(tmps1);

		if(countdownseconds > 60) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "Maximum seconds for countdown is 60");
			countdownseconds = 0;
			return 1;
		}

		GetPlayerName(playerid, playername, sizeof(sendername));

		format(strings, sizeof(strings), "--- %s Started a countdown of %d seconds.", playername,countdownseconds);
		printf(strings);
	}
	return 1;
}

dcmd_regular(playerid,params[])  {
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /regular [playerid]. This wil set the boolean regular player for [playerid] to 1, enabling /pcd.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(RegularPlayer[giveplayerid]==0){
		    RegularPlayer[giveplayerid]=1;
			dini_IntSet(udb_encode(giveplayername), "regularplayer", RegularPlayer[giveplayerid]);
			format(strings, sizeof(strings), "* You have set the status of regular player for %s (id: %d).", giveplayername,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s has given you the status of regular player. You can now perform a countdown with /pcd.", playername);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		} else {
			format(strings, sizeof(strings), "* %s (id: %d) is already marked as regular player.", giveplayername,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
		}
	}
	return 1;
}

dcmd_notregular(playerid,params[])  {
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(IsAdmin(playerid) && adminlevel[playerid] > 1) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /notregular [playerid]. This wil set the boolean regular player for [playerid] to 0, disabling /pcd.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(RegularPlayer[giveplayerid]==1){
		    RegularPlayer[giveplayerid]=0;
			dini_IntSet(udb_encode(playername), "regularplayer", RegularPlayer[playerid]);
			format(strings, sizeof(strings), "* You have removed the status of regular player for %s (id: %d).", giveplayername,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
			format(strings, sizeof(strings), "* %s has revoked you the status of regular player. You can no longer perform a countdown with /pcd.", playername);
			SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
		} else {
			format(strings, sizeof(strings), "* %s (id: %d) is no regular player.", giveplayername,giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
		}
	}
	return 1;
}

dcmd_uptime(playerid,params[])  {
	#pragma unused params
	
	if(IsAdmin(playerid)) {
		format(strings, sizeof(strings), "* Serveruptime: %d days, %d hours, %d minutes.", Uptime_days, Uptime_hours, Uptime);
		SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
	}
	return 1;
}

dcmd_resetdm(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		DMplayer[playerid] = 0;
		dragracer[playerid]=0;
		deathmatcher18[playerid] = 0;
    	deathmatcher19[playerid] = 0;
    	deathmatcher20[playerid] = 0;
   		deathmatcher21[playerid] = 0;
    	deathmatcher22[playerid] = 0;
    	deathmatcher24[playerid] = 0;
    	deathmatcher25[playerid] = 0;
    	deathmatcher26[playerid] = 0;
    	deathmatcher27[playerid] = 0;
    	deathmatcher28[playerid] = 0;
		sprintracer[playerid] = 0;
		motorracer[playerid] = 0;
		SendClientMessage(playerid,COLOR_SYSTEM_PM,"* Your deathmatch-indicator has been resetted to zero.");
	}
	return 1;
}

dcmd_resetdrag1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace1inprogress = 0;
		dragrace1started = 0;
		dragrace1[0] = 0;
		dragrace1[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher7[i] = 0;
			dragrace1players[i] = 0;
		}
		dragrace1countdownseconds = 0;
		playersdragrace1 = 0;
		dragrace1racer[0]=0;
		dragrace1racer[1]=0;
		KillTimer(DragRace1Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 1 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace2inprogress = 0;
		dragrace2started = 0;
		dragrace2[0] = 0;
		dragrace2[1] = 0;
		dragrace2[2] = 0;
		dragrace2[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher8[i] = 0;
			dragrace2players[i] = 0;
		}
		dragrace2countdownseconds = 0;
		playersdragrace2 = 0;
		dragrace2racer[0]=0;
		dragrace2racer[1]=0;
		dragrace2racer[2]=0;
		dragrace2racer[3]=0;
		KillTimer(DragRace2Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 2 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace3inprogress = 0;
		dragrace3started = 0;
		dragrace3[0] = 0;
		dragrace3[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher9[i] = 0;
			dragrace3players[i] = 0;
		}
		dragrace3countdownseconds = 0;
		playersdragrace3 = 0;
		dragrace3racer[0]=0;
		dragrace3racer[1]=0;
		KillTimer(DragRace3Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 3 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag4(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace4inprogress = 0;
		dragrace4started = 0;
		dragrace4[0] = 0;
		dragrace4[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher11[i] = 0;
			dragrace4players[i] = 0;
		}
		dragrace4countdownseconds = 0;
		playersdragrace4 = 0;
		dragrace4racer[0]=0;
		dragrace4racer[1]=0;
		KillTimer(DragRace4Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 4 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag5(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace5inprogress = 0;
		dragrace5started = 0;
		dragrace5[0] = 0;
		dragrace5[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher13[i] = 0;
			dragrace5players[i] = 0;
		}
		dragrace5countdownseconds = 0;
		playersdragrace5 = 0;
		dragrace5racer[0]=0;
		dragrace5racer[1]=0;
		KillTimer(DragRace5Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 5 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag6(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace6inprogress = 0;
		dragrace6started = 0;
		dragrace6[0] = 0;
		dragrace6[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher14[i] = 0;
			dragrace6players[i] = 0;
		}
		dragrace6countdownseconds = 0;
		playersdragrace6 = 0;
		dragrace6racer[0]=0;
		dragrace6racer[1]=0;
		KillTimer(DragRace6Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 6 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag7(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace7inprogress = 0;
		dragrace7started = 0;
		dragrace7[0] = 0;
		dragrace7[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher15[i] = 0;
			dragrace7players[i] = 0;
		}
		dragrace7countdownseconds = 0;
		playersdragrace7 = 0;
		dragrace7racer[0]=0;
		dragrace7racer[1]=0;
		KillTimer(DragRace7Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 7 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag8(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace8inprogress = 0;
		dragrace8started = 0;
		dragrace8[0] = 0;
		dragrace8[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher16[i] = 0;
			dragrace8players[i] = 0;
		}
		dragrace8countdownseconds = 0;
		playersdragrace8 = 0;
		dragrace8racer[0]=0;
		dragrace8racer[1]=0;
		KillTimer(DragRace8Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 8 has been resetted.");
	}
	return 1;
}

dcmd_resetdrag9(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace9inprogress = 0;
		dragrace9started = 0;
		dragrace9[0] = 0;
		dragrace9[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher17[i] = 0;
			dragrace9players[i] = 0;
		}
		dragrace9countdownseconds = 0;
		playersdragrace9 = 0;
		dragrace9racer[0]=0;
		dragrace9racer[1]=0;
		KillTimer(DragRace9Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles dragrace 9 has been resetted.");
	}
	return 1;
}

dcmd_resetalldrags(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		dragrace1inprogress = 0;
		dragrace1started = 0;
		dragrace1[0] = 0;
		dragrace1[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			DMplayer[playerid] = 0;
			dragracer[playerid]=0;
			deathmatcher7[i] = 0;
			dragrace1players[i] = 0;
			deathmatcher8[i] = 0;
			dragrace2players[i] = 0;
			deathmatcher9[i] = 0;
			dragrace3players[i] = 0;
			deathmatcher11[i] = 0;
			dragrace4players[i] = 0;
			deathmatcher13[i] = 0;
			dragrace5players[i] = 0;
			deathmatcher14[i] = 0;
			dragrace6players[i] = 0;
			deathmatcher15[i] = 0;
			dragrace7players[i] = 0;
			deathmatcher16[i] = 0;
			dragrace8players[i] = 0;
			deathmatcher17[i] = 0;
			dragrace9players[i] = 0;
			deathmatcher10[i] = 0;
			sprintrace1players[i] = 0;
			deathmatcher12[i] = 0;
			sprintrace2players[i] = 0;
			deathmatcher18[i] = 0;
			sprintrace3players[i] = 0;
			deathmatcher19[i] = 0;
			sprintrace4players[i] = 0;
			deathmatcher20[i] = 0;
			sprintrace5players[i] = 0;
			deathmatcher21[i] = 0;
			sprintrace6players[i] = 0;
			deathmatcher22[i] = 0;
			sprintrace7players[i] = 0;
			deathmatcher24[i] = 0;
			motorrace1players[i] = 0;
			deathmatcher25[i] = 0;
			motorrace2players[i] = 0;
			deathmatcher26[i] = 0;
			motorrace3players[i] = 0;
			deathmatcher27[i] = 0;
			motorrace4players[i] = 0;
			deathmatcher28[i] = 0;
			motorrace5players[i] = 0;
		}
		dragrace1countdownseconds = 0;
		playersdragrace1 = 0;
		dragrace1racer[0]=0;
		dragrace1racer[1]=0;
		KillTimer(DragRace1Finish);
		dragrace2inprogress = 0;
		dragrace2started = 0;
		dragrace2[0] = 0;
		dragrace2[1] = 0;
		dragrace2[2] = 0;
		dragrace2[3] = 0;
		dragrace2countdownseconds = 0;
		playersdragrace2 = 0;
		dragrace2racer[0]=0;
		dragrace2racer[1]=0;
		dragrace2racer[2]=0;
		dragrace2racer[3]=0;
		KillTimer(DragRace2Finish);
		dragrace3inprogress = 0;
		dragrace3started = 0;
		dragrace3[0] = 0;
		dragrace3[1] = 0;
		dragrace3countdownseconds = 0;
		playersdragrace3 = 0;
		dragrace3racer[0]=0;
		dragrace3racer[1]=0;
		KillTimer(DragRace3Finish);
		dragrace4inprogress = 0;
		dragrace4started = 0;
		dragrace4[0] = 0;
		dragrace4[1] = 0;
		dragrace4countdownseconds = 0;
		playersdragrace4 = 0;
		dragrace4racer[0]=0;
		dragrace4racer[1]=0;
		KillTimer(DragRace4Finish);
		dragrace5inprogress = 0;
		dragrace5started = 0;
		dragrace5[0] = 0;
		dragrace5[1] = 0;
		dragrace5countdownseconds = 0;
		playersdragrace5 = 0;
		dragrace5racer[0]=0;
		dragrace5racer[1]=0;
		KillTimer(DragRace5Finish);
		dragrace6inprogress = 0;
		dragrace6started = 0;
		dragrace6[0] = 0;
		dragrace6[1] = 0;
		dragrace6countdownseconds = 0;
		playersdragrace6 = 0;
		dragrace6racer[0]=0;
		dragrace6racer[1]=0;
		KillTimer(DragRace6Finish);
		dragrace7inprogress = 0;
		dragrace7started = 0;
		dragrace7[0] = 0;
		dragrace7[1] = 0;
		dragrace7countdownseconds = 0;
		playersdragrace7 = 0;
		dragrace7racer[0]=0;
		dragrace7racer[1]=0;
		KillTimer(DragRace7Finish);
		dragrace8inprogress = 0;
		dragrace8started = 0;
		dragrace8[0] = 0;
		dragrace8[1] = 0;
		dragrace8countdownseconds = 0;
		playersdragrace8 = 0;
		dragrace8racer[0]=0;
		dragrace8racer[1]=0;
		KillTimer(DragRace8Finish);
		dragrace9inprogress = 0;
		dragrace9started = 0;
		dragrace9[0] = 0;
		dragrace9[1] = 0;
		dragrace9countdownseconds = 0;
		playersdragrace9 = 0;
		dragrace9racer[0]=0;
		dragrace9racer[1]=0;
		KillTimer(DragRace9Finish);
		sprintrace1inprogress = 0;
		sprintrace1started = 0;
		sprintrace1[0] = 0;
		sprintrace1[1] = 0;
		sprintrace1[2] = 0;
		sprintrace1[3] = 0;
		sprintrace1countdownseconds = 0;
		playerssprintrace1 = 0;
		sprintrace1racer[0]=0;
		sprintrace1racer[1]=0;
		sprintrace1racer[2]=0;
		sprintrace1racer[3]=0;
		KillTimer(SprintRace1Finish);
		sprintrace2inprogress = 0;
		sprintrace2started = 0;
		sprintrace2[0] = 0;
		sprintrace2[1] = 0;
		sprintrace2[2] = 0;
		sprintrace2[3] = 0;
		sprintrace2countdownseconds = 0;
		playerssprintrace2 = 0;
		sprintrace2racer[0]=0;
		sprintrace2racer[1]=0;
		sprintrace2racer[2]=0;
		sprintrace2racer[3]=0;
		KillTimer(SprintRace2Finish);
		sprintrace3[0] = 0;
		sprintrace3[1] = 0;
		sprintrace3countdownseconds = 0;
		sprintrace3started = 0;
		playerssprintrace3 = 0;
		sprintrace3inprogress = 0;
		sprintrace3racer[0] = 0;
		sprintrace3racer[1] = 0;
		SprintRace3Countdown2Seconds = 0;
		SprintRace3Finisher = 0;
		sprintrace4[0] = 0;
		sprintrace4[1] = 0;
		sprintrace4countdownseconds = 0;
		sprintrace4started = 0;
		playerssprintrace4 = 0;
		sprintrace4inprogress = 0;
		sprintrace4racer[0] = 0;
		sprintrace4racer[1] = 0;
		SprintRace4Countdown2Seconds = 0;
		SprintRace4Finisher = 0;
		sprintrace5[0] = 0;
		sprintrace5[1] = 0;
		sprintrace5countdownseconds = 0;
		sprintrace5started = 0;
		playerssprintrace5 = 0;
		sprintrace5inprogress = 0;
		sprintrace5racer[0] = 0;
		sprintrace5racer[1] = 0;
		SprintRace5Countdown2Seconds = 0;
		SprintRace5Finisher = 0;
		sprintrace6[0] = 0;
		sprintrace6[1] = 0;
		sprintrace6countdownseconds = 0;
		sprintrace6started = 0;
		playerssprintrace6 = 0;
		sprintrace6inprogress = 0;
		sprintrace6racer[0] = 0;
		sprintrace6racer[1] = 0;
		SprintRace6Countdown2Seconds = 0;
		SprintRace6Finisher = 0;
		sprintrace7[0] = 0;
		sprintrace7[1] = 0;
		sprintrace7countdownseconds = 0;
		sprintrace7started = 0;
		playerssprintrace7 = 0;
		sprintrace7inprogress = 0;
		sprintrace7racer[0] = 0;
		sprintrace7racer[1] = 0;
		SprintRace7Countdown2Seconds = 0;
		SprintRace7Finisher = 0;
		motorrace1[0] = 0;
		motorrace1[1] = 0;
		motorrace1countdownseconds = 0;
		motorrace1started = 0;
		playersmotorrace1 = 0;
		motorrace1inprogress = 0;
		motorrace1racer[0] = 0;
		motorrace1racer[1] = 0;
		MotorRace1Countdown2Seconds = 0;
		MotorRace1Finisher = 0;
		motorrace2[0] = 0;
		motorrace2[1] = 0;
		motorrace2countdownseconds = 0;
		motorrace2started = 0;
		playersmotorrace2 = 0;
		motorrace2inprogress = 0;
		motorrace2racer[0] = 0;
		motorrace2racer[1] = 0;
		MotorRace2Countdown2Seconds = 0;
		MotorRace2Finisher = 0;
		motorrace3[0] = 0;
		motorrace3[1] = 0;
		motorrace3countdownseconds = 0;
		motorrace3started = 0;
		playersmotorrace3 = 0;
		motorrace3inprogress = 0;
		motorrace3racer[0] = 0;
		motorrace3racer[1] = 0;
		MotorRace3Countdown2Seconds = 0;
		MotorRace3Finisher = 0;
		motorrace4[0] = 0;
		motorrace4[1] = 0;
		motorrace4countdownseconds = 0;
		motorrace4started = 0;
		playersmotorrace4 = 0;
		motorrace4inprogress = 0;
		motorrace4racer[0] = 0;
		motorrace4racer[1] = 0;
		MotorRace4Countdown2Seconds = 0;
		MotorRace4Finisher = 0;
		motorrace5[0] = 0;
		motorrace5[1] = 0;
		motorrace5countdownseconds = 0;
		motorrace5started = 0;
		playersmotorrace5 = 0;
		motorrace5inprogress = 0;
		motorrace5racer[0] = 0;
		motorrace5racer[1] = 0;
		MotorRace5Countdown2Seconds = 0;
		MotorRace5Finisher = 0;
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles all races have been resetted.");
	}
	return 1;
}

dcmd_resetsprint1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		sprintrace1inprogress = 0;
		sprintrace1started = 0;
		sprintrace1[0] = 0;
		sprintrace1[1] = 0;
		sprintrace1[2] = 0;
		sprintrace1[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher10[i] = 0;
			sprintrace1players[i] = 0;
		}
		sprintrace1countdownseconds = 0;
		playerssprintrace1 = 0;
		sprintrace1racer[0]=0;
		sprintrace1racer[1]=0;
		sprintrace1racer[2]=0;
		sprintrace1racer[3]=0;
		KillTimer(SprintRace1Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles sprint race 1 has been resetted.");
	}
	return 1;
}

dcmd_resetsprint2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		sprintrace2inprogress = 0;
		sprintrace2started = 0;
		sprintrace2[0] = 0;
		sprintrace2[1] = 0;
		sprintrace2[2] = 0;
		sprintrace2[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher12[i] = 0;
			sprintrace2players[i] = 0;
		}
		sprintrace2countdownseconds = 0;
		playerssprintrace2 = 0;
		sprintrace2racer[0]=0;
		sprintrace2racer[1]=0;
		sprintrace2racer[2]=0;
		sprintrace2racer[3]=0;
		KillTimer(SprintRace2Finish);
		SendClientMessage(playerid, COLOR_ADMIN_PM , "* Variabeles sprint race 2 has been resetted.");
	}
	return 1;
}

dcmd_cardive(playerid,params[])  {
	#pragma unused params
	new VehicleID;
	if(logged[playerid] == 1){
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle in order to go in a dive with it.");
			return 1;
		}
		if(IsPlayerDriver(playerid)){
			if(GetPlayerMoney(playerid)<100000){
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need $100 000 to use this service.");
				return 1;
			}
  			VehicleID = GetPlayerVehicleID(playerid);
			if(VehicleID <= 61 || VehicleID >= 219){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks can cardive.");
		  	    return 1;
			}
			GetPlayerName(playerid,playername,sizeof(playername));
            CarDiveCountdownSeconds[playerid]=16;
			askedcardive[playerid]=1;
			format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he requested a cardive.", playerid, 100000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, -100000, strings);
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings), "* %s is going to throw his car in a cardive for $100 000.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
			TogglePlayerControllable(playerid, 0);
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Only the driver of this vehicle can send this vehicle in a dive.");
		}
	}
	return 1;
}

dcmd_url(playerid,params[]){
	#pragma unused params
	if(logged[playerid] == 1){
//		SendClientMessageToAll(COLOR_ADMIN_TOALL , "* Website & forum: http://www.samp.nl/");
		SendClientMessage(playerid, COLOR_ADMIN_TOALL, "* Modify the pwn version to put the url of your website / forum here to display your users.");
	}
	return 1;
}

dcmd_patrol(playerid,params[])  {
	#pragma unused params
	new VehicleID;
	if(logged[playerid] == 1){
		if(playerid != propertyOwner[P_FORTCARSONPD]){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to own the Highway Patrol Headquaters in order to patrol the highways.");
			return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in your patrol vehicle to start a highway patrol.");
			return 1;
		}
		if(HighwayOnMission[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You are already on patrol.");
			return 1;
		}
		if(PatrolDisable == 1){
		    format(strings, sizeof(strings), "* Sorry sir, reloading the camera's is gonna take another %d minutes. After that you can patrol again.", PatrolTimer2);
			SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
			return 1;
		}
		VehicleID = GetPlayerVehicleID(playerid);
		if(IsPlayerDriver(playerid) && VehicleID == 99){
			GetPlayerName(playerid,playername,sizeof(playername));
			format(strings, sizeof(strings), "* %s has started patrolling the highways, watch your speeed! Over 140 kph and you will be fined.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "* You have started your highway patrol. You need to get relatively close to another player to check its speed and fine him.");
			HighwayOnMission[playerid] = 1;
			HighwayMission = 1;
			PatrolCountingUp = 1;
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be driving your patrol vehicle to start a highway patrol.");
		}
	}
	return 1;
}

dcmd_stoppatrol(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(HighwayOnMission[playerid] == 1){
		    HighwayOnMission[playerid] = 0;
			format(strings, sizeof(strings),"* Player %s has ended the highway patrol mission, you can roam freely over the highways without getting a ticket.",playername);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			OutOfRanger[playerid]=0;
			HighwayMission = 0;
			SetPlayerColor(playerid,playerColors[playerid]);
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You aren't patrolling the highways, so there is nothing to end.");
		}
	}
	return 1;
}

dcmd_veid(playerid,params[])  {
	#pragma unused params
    new vehicleid, vehiclemod, vehiclemod2;
	if(logged[playerid] == 1){
		vehicleid=GetPlayerVehicleID(playerid);
		vehiclemod=VehicleModels[vehicleid];
		vehiclemod2=vehiclemod-400;
		format(strings, sizeof(strings),"* Driving in %d, type %d, name %s.",vehicleid, vehiclemod, vehicleNames[vehiclemod2]);
		SendClientMessage(playerid,COLOR_ADMIN_TOALL,strings);
	}
	return 1;
}

dcmd_liftme(playerid,params[]){
	#pragma unused params
	if(logged[playerid] == 1){
	    if(IsPlayerInCheckpoint(playerid) == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at the entrance of the chair-lift to enter it. The entrance is at the bottom of Mount Chilliad.");
			return 1;
		}
		if(Chairlifter1[playerid] == 1){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You are already signed up for a chair-lift ride.");
			return 1;
		}
		if(getCheckpointType(playerid) == CP_LIFTMECHIL){
			GetPlayerName(playerid,playername, sizeof(playername));
			format(strings, sizeof(strings),"* Player %s is taking the chair-lift to the top of the mountain.",playername);
			SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "* Please wait for the chair to pick you up. This will take approx 3 seconds.");
			Chairliftcounter1[playerid] = 0;
			Chairlifter1[playerid] = 1;
			ChairliftDelay[playerid] = 0;
			return 1;
		}
		if(getCheckpointType(playerid) == CP_LIFTMEGATE){
			GetPlayerName(playerid,playername, sizeof(playername));
			format(strings, sizeof(strings),"* Player %s is taking the chair-lift to the top of the Golden Gate Bridge.",playername);
			SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "* Please wait for the chair to pick you up. This will take approx 3 seconds.");
			Chairliftcounter2[playerid] = 0;
			Chairlifter2[playerid] = 1;
			ChairliftDelay[playerid] = 0;
			return 1;
		}
        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You must be at the entrance of a chair-lift to enter it.");
        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* One entrance is at the bottom of Mount Chilliad, the other is on a bridge from the desert to San Fierro.");
	}
	return 1;
}

dcmd_pizza(playerid,params[])  {
	#pragma unused params
	new VehicleID;
	if(logged[playerid] == 1){
	    if(Pizza[playerid] == 1){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Luigi already employed you, you can't take up two jobs.");
			return 1;
		}
	    if(IsPlayerInCheckpoint(playerid) == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Ask Luigi's if he has a job for you. You can find him next to the Well Stacked Pizza at the Pier 69 in San Fierro.");
			return 1;
		}
		if(getCheckpointType(playerid) != CP_LUIGIS){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Ask Luigi's if he has a job for you. You can find him next to the Well Stacked Pizza at the Pier 69 in San Fierro.");
			return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be driving a motorbike before you can accept the job of pizza deliverer.");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be driving a motorbike yourself before you can accept the job of pizza deliverer.");
			return 1;
		}
		VehicleID = GetPlayerVehicleID(playerid);
		VehicleGroup[playerid]=WhichVehicleGroup(VehicleID);
		if(VehicleGroup[playerid] > 0){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be driving a motorbike before you can accept the job of pizza deliverer.");
			return 1;
		}
		SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Don't get a different vehicle than the one you are driving, or you will loose your job.");
		PizzaNextCP[playerid] = CP_LUIGIS;
		PizzaTotalTime[playerid]=0;
		PizzaTimer[playerid] = 30;
		PizzaDelivered[playerid] = 0;
		Pizza[playerid] = 1;
		PizzaNextCheckpoint(playerid);
		PizzaVehicle[playerid]=GetPlayerVehicleID(playerid);
	}
	return 1;
}

dcmd_pizzastop(playerid, params[]){
	#pragma unused params
	new delivered;
	if(logged[playerid] == 1){
	    if(Pizza[playerid] == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Luigi didn't employed you, so you there is no job to quit.");
			return 1;
		}
		delivered=PizzaDelivered[playerid];
		format(strings, sizeof(strings),"* You have quit your job and you managed to deliver %d pizza's", delivered);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		TotalPizzas(playerid, delivered);
		Pizza[playerid] = 0;
	    PizzaNextCP[playerid] = 0;
		PizzaVehicle[playerid] = 999;
	}
	return 1;
}

dcmd_pizzaboard(playerid, params[]){
	#pragma unused params
	new GlobalPizzaDel1[MAX_PLAYER_NAME];
	new GlobalPizzaDel2[MAX_PLAYER_NAME];
	new GlobalPizzaDel3[MAX_PLAYER_NAME];
	new GlobalPizzaDel4[MAX_PLAYER_NAME];
	new GlobalPizzaDel5[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_GOLD, "* The global pizza delivery leaderboard:");
		if(!strlen(GlobalPizzaMan1)) {
		    format(GlobalPizzaDel1, sizeof(GlobalPizzaDel1), "none");
		} else {
		    format(GlobalPizzaDel1, sizeof(GlobalPizzaDel1), "%s", GlobalPizzaMan1);
		}
		if(!strlen(GlobalPizzaMan2)) {
		    format(GlobalPizzaDel2, sizeof(GlobalPizzaDel2), "none");
		} else {
		    format(GlobalPizzaDel2, sizeof(GlobalPizzaDel2), "%s", GlobalPizzaMan2);
		}
		if(!strlen(GlobalPizzaMan3)) {
		    format(GlobalPizzaDel3, sizeof(GlobalPizzaDel3), "none");
		} else {
		    format(GlobalPizzaDel3, sizeof(GlobalPizzaDel3), "%s", GlobalPizzaMan3);
		}
		if(!strlen(GlobalPizzaMan4)) {
		    format(GlobalPizzaDel4, sizeof(GlobalPizzaDel4), "none");
		} else {
		    format(GlobalPizzaDel4, sizeof(GlobalPizzaDel4), "%s", GlobalPizzaMan4);
		}
		if(!strlen(GlobalPizzaMan5)) {
		    format(GlobalPizzaDel5, sizeof(GlobalPizzaDel5), "none");
		} else {
		    format(GlobalPizzaDel5, sizeof(GlobalPizzaDel5), "%s", GlobalPizzaMan5);
		}
		format(strings, sizeof(strings),"* #1: %s with %d pizza's delivered", GlobalPizzaDel1, GlobalPizza1);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #2: %s with %d pizza's delivered", GlobalPizzaDel2, GlobalPizza2);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #3: %s with %d pizza's delivered", GlobalPizzaDel3, GlobalPizza3);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #4: %s with %d pizza's delivered", GlobalPizzaDel4, GlobalPizza4);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #5: %s with %d pizza's delivered", GlobalPizzaDel5, GlobalPizza5);
		SendClientMessage(playerid, COLOR_GOLD, strings);
	}
	return 1;
}

dcmd_helperhelp(playerid,params[]){
	#pragma unused params
	if(logged[playerid] == 1 && Helper[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU , "______________ Helper menu ______________________________________");
		SendClientMessage(playerid, COLOR_MENU , "* You can use the following commands:");
		SendClientMessage(playerid, COLOR_MENU , "* /introduce [playerid] - to give a player $ 100.000 on his bank");
		SendClientMessage(playerid, COLOR_MENU , "*              and 2 low-range properties (if they are available)");
		SendClientMessage(playerid, COLOR_MENU , "* /whoneedshelp - to announce your services to new players.");
		SendClientMessage(playerid, COLOR_MENU , "*                 They will see a private message, and you will be");
		SendClientMessage(playerid, COLOR_MENU , "*                 notified as well.");
		SendClientMessage(playerid, COLOR_MENU , "__________________________________________________________________");
	}
	return 1;
}

dcmd_helper(playerid,params[]){
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /helper [playerid]. This wil give [playerid] the helper function.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(IsPlayerConnected(giveplayerid)){
			if(Helper[giveplayerid]==0){
			    Helper[giveplayerid]=1;
				dini_IntSet(udb_encode(giveplayername), "helper", Helper[giveplayerid]);
				format(strings, sizeof(strings), "* You have promoted %s (id: %d) to the helper function.", giveplayername,giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* %s has promoted you to a helper. Type /helperhelp for available commands.", playername);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* Ask %s for more information regarding this promotion and the role of a helper.", playername);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				format(strings, sizeof(strings), "* %s (id: %d) is already a helper.", giveplayername,giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
			}
		} else {
			format(strings, sizeof(strings), "* Player id %d is not connected.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
		}
	}
	return 1;
}

dcmd_nohelper(playerid,params[]){
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /helper [playerid]. This wil give [playerid] the helper function.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(IsPlayerConnected(giveplayerid)){
			if(Helper[giveplayerid]==1){
			    Helper[giveplayerid]=0;
				dini_IntSet(udb_encode(giveplayername), "helper", Helper[giveplayerid]);
				format(strings, sizeof(strings), "* You have demoted %s (id: %d).", giveplayername,giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_PM , strings);
				format(strings, sizeof(strings), "* %s has demoted you, you are no longer a helper.", playername);
				SendClientMessage(giveplayerid, COLOR_ADMIN_PM , strings);
			} else {
				format(strings, sizeof(strings), "* %s (id: %d) is no helper.", giveplayername,giveplayerid);
				SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
			}
		} else {
			format(strings, sizeof(strings), "* Player id %d is not connected.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
		}
	}
	return 1;
}

dcmd_introduce(playerid,params[]){
	new index = 0;
	new prop, property, propertycounter, m;
	new giveplayername[MAX_PLAYER_NAME];
	if(logged[playerid] == 1 && Helper[playerid] == 1) {
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /introduce [playerid]. This wil give [playerid] the newplayer-package.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(IsPlayerConnected(giveplayerid)){
			if(NewPlayer[giveplayerid] == 1){
			    NewPlayer[giveplayerid]=0;
				dini_IntSet(udb_encode(giveplayername), "newplayer", NewPlayer[giveplayerid]);
			    bank[giveplayerid]=bank[giveplayerid]+100000;
				format(strings, sizeof(strings),"* Helper %s has deposited $100.000 on your bank account.",playername);
			    SendClientMessage(giveplayerid,COLOR_SYSTEM_PM, strings);
			    for (new i=0;i<30;i++){
					property=PropsForHelper[random(sizeof(PropsForHelper))];
			        if(prop < 2){
			            if(propertyOwner[property] == 999){
			                if(GetNumberOfProperties(giveplayerid) < MAX_OWNED_PROPERTIES){
								if(prop == 0) SendClientMessage(giveplayerid,COLOR_SYSTEM_PM, "* You are also receiving the following property/properties without paying for them:");
				                prop++;
				                propertyOwner[property] = giveplayerid;
	       						format(strings, sizeof(strings),"* %s with the current value of %d and an estimated increase in value of $%d each minute.", propertyNames[property],propertyCurrentValue[property],floatround(floatmul(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET],1.5)));
							    SendClientMessage(giveplayerid,COLOR_SYSTEM_PM, strings);
							}
						}
					}
				}
				SaveProperties(giveplayerid);
				for(new i=0; i<8; i++){
					m=i+1;
					format(strings, sizeof(strings), "property%d", m);
					dini_IntSet(udb_encode(giveplayername), strings, propertyArray[giveplayerid][i]);
				}
				format(strings, sizeof(strings),"* You have deposited $100.000 on %s's bank account.",giveplayername);
			    SendClientMessage(playerid,COLOR_SYSTEM_PM, strings);
		        for(new j=0; j<MAX_PROPERTIES; j++) {
					if (propertyOwner[j] == giveplayerid) {
						if(propertycounter == 0) SendClientMessage(giveplayerid,COLOR_SYSTEM_PM, "* You have also gave the following properties to the player you are introducing:");
		        	    propertycounter++;
						format(strings, sizeof(strings), "* %d. %s with current value of $%d.", j,propertyNames[j],propertyCurrentValue[j]);
						SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
					}
				}
				if(propertycounter == 0) SendClientMessage(giveplayerid,COLOR_SYSTEM_PM, "* There were no properties available to give to the introducee, or your introducee has already got 8 properties.");
			} else {
				format(strings, sizeof(strings),"* You cannot introduce player %s, he is either already introduced or too long on the server.",giveplayername);
			    SendClientMessage(playerid,COLOR_SYSTEM_PW, strings);
			}
		} else {
			format(strings, sizeof(strings),"* Playerid %d is not connected to the server.",giveplayerid);
		    SendClientMessage(playerid,COLOR_SYSTEM_PW, strings);
		}
	}
	return 1;
}

dcmd_whoneedshelp(playerid,params[]){
	#pragma unused params
	new giveplayername[MAX_PLAYER_NAME];
	new introducee;
	if(logged[playerid] == 1 && Helper[playerid] == 1) {
		GetPlayerName(playerid,playername,sizeof(playername));
		for (new i=0;i<MAX_PLAYERS;i++){
		    if(IsPlayerConnected(i)){
		        if(NewPlayer[i] == 1){
					introducee++;
					GetPlayerName(i,giveplayername,sizeof(giveplayername));
					format(strings, sizeof(strings),"* Player %s is offering you an introduction to this server. Contact %s if you want assistance.",playername,playername);
				    SendClientMessage(giveplayerid,COLOR_SYSTEM_PM, strings);
					format(strings, sizeof(strings),"* Player %s is marked as a new player which you can give an introduction.",giveplayername);
				    SendClientMessage(playerid,COLOR_SYSTEM_PM, strings);
				}
			}
		}
		format(strings, sizeof(strings),"* Total number of players which can be introduced at this moment: %d",introducee);
	    SendClientMessage(playerid,COLOR_SYSTEM_PM, strings);
	}
	return 1;
}

dcmd_ignore(playerid,params[]){
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /ignore [playerid]. With this you will ignore all [playerid]'s private messages.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(IsPlayerConnected(giveplayerid)){
			if (IgnorePlayerlist[playerid][giveplayerid] == 0){
				IgnorePlayerlist[playerid][giveplayerid] = 1;
				format(strings, sizeof(strings), "* You have ignored %s. If you want to undo this, use /unignore %d.", giveplayername, giveplayerid);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			} else {
				format(strings, sizeof(strings), "* You already ignored %s. If you want to undo this, use /unignore %d.", giveplayername, giveplayerid);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			}
		} else {
			format(strings, sizeof(strings), "* Player id %d is not connected.", giveplayerid);
			SendClientMessage(playerid, COLOR_ADMIN_CMD , strings);
		}
	}
	return 1;
}

dcmd_unignore(playerid,params[]){
	new index = 0;
	new giveplayername[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);

		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /unignore [playerid]. With this you will unignore all [playerid]'s private messages.");
			return 1;
		}
		giveplayerid = strval(tmps1);
		GetPlayerName(playerid,playername,sizeof(playername));
		GetPlayerName(giveplayerid,giveplayername,sizeof(giveplayername));

		if(IsPlayerConnected(giveplayerid)){
			if (IgnorePlayerlist[playerid][giveplayerid] == 1){
				IgnorePlayerlist[playerid][giveplayerid] = 0;
				format(strings, sizeof(strings), "* You have unignored %s.", giveplayername);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			} else {
				format(strings, sizeof(strings), "* You are not ignoring %s so there is nothing to undo.", giveplayername);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			}
		} else {
			format(strings, sizeof(strings), "* Player id %d is not connected.", giveplayerid);
			SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
		}
	}
	return 1;
}

dcmd_ignorelist(playerid,params[]){
	#pragma unused params
	new giveplayername[MAX_PLAYER_NAME];
	new found,line;
	if(logged[playerid] == 1){
		for(new i=0; i<MAX_PLAYERS; i++){
		    if(IgnorePlayerlist[playerid][i] == 1){
		        if(found == 0){
		            SendClientMessage(playerid, COLOR_SYSTEM_PM, "You are currently ignoring:");
		            found++;
		        }
				GetPlayerName(i,giveplayername,sizeof(giveplayername));
				if(line == 0){
					format(strings, sizeof(strings), "* %s (id %d)", giveplayername, i);
					line++;
				} else {
				    format(strings, sizeof(strings), "%s *** %s (id %d)", strings, giveplayername, i);
				    line = 0;
				}
				if(line == 0) SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
			}
		}
		if(line != 0) SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		if(found == 0) SendClientMessage(playerid, COLOR_SYSTEM_PM, "You are currently not ignoring anyone.");
	}
	return 1;
}

dcmd_taxidriver(playerid,params[])  {
	#pragma unused params
	new VehicleID;
	if(logged[playerid] == 1){
	    if(TaxiDriver[playerid] == 1){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Mickey already employed you, you can't take up two jobs.");
			return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Mickey has a job for you. Take a cab next at the SA Taxi Company in LS, and type /taxidriver again.");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Mickey has a job for you. Get in a cab next at the SA Taxi Company in LS as a driver, and type /taxidriver again.");
			return 1;
		}
		VehicleID = GetPlayerVehicleID(playerid);
		VehicleGroup[playerid]=WhichVehicleGroup(VehicleID);
		if(VehicleGroup[playerid] != 11){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be driving a taxi before you can accept the job of taxi driver. Get a taxi at the SA Taxi Company in LS.");
			return 1;
		}
		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Don't get a different vehicle than the one you are driving, or you will loose your job.");
		ApplyTaxi[playerid] = 0;
		NewTaxiDriver[playerid] = 0;
		TaxiTotalTime[playerid]=30;
		TaxiTimer[playerid] = 0;
		TaxiDelivered[playerid] = -1;
		TaxiDriver[playerid] = 1;
		TaxiNextCheckpoint(playerid);
		TaxiVehicle[playerid]=GetPlayerVehicleID(playerid);
	}
	return 1;
}

dcmd_notaxidriver(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
	    if(NewTaxiDriver[playerid] == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Mickey didn't made you an offer, so you there is no job to deny.");
			return 1;
		}
		ApplyTaxi[playerid] = 0;
		NewTaxiDriver[playerid] = 0;
		TogglePlayerControllable(playerid, 1);
		if(IsPlayerInAnyVehicle(playerid)) RemovePlayerFromVehicle(playerid);
	}
	return 1;
}

dcmd_taxistop(playerid, params[]){
	#pragma unused params
	new delivered;
	if(logged[playerid] == 1){
	    if(TaxiDriver[playerid] == 0){
	        SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Mickey didn't employed you, so you there is no job to quit.");
			return 1;
		}
		delivered=TaxiDelivered[playerid];
		format(strings, sizeof(strings),"* You have quit your job and you managed to make %d taxiruns", delivered);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		TotalTaxis(playerid, delivered);
		TaxiDriver[playerid] = 0;
	    TaxiNextCP[playerid] = 0;
		TaxiVehicle[playerid] = 999;
	}
	return 1;
}

dcmd_taxiboard(playerid, params[]){
	#pragma unused params
	new GlobalTaxiDel1[MAX_PLAYER_NAME];
	new GlobalTaxiDel2[MAX_PLAYER_NAME];
	new GlobalTaxiDel3[MAX_PLAYER_NAME];
	new GlobalTaxiDel4[MAX_PLAYER_NAME];
	new GlobalTaxiDel5[MAX_PLAYER_NAME];
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_GOLD, "* The global taxi delivery leaderboard:");
		if(!strlen(GlobalTaxiMan1)) {
		    format(GlobalTaxiDel1, sizeof(GlobalTaxiDel1), "none");
		} else {
		    format(GlobalTaxiDel1, sizeof(GlobalTaxiDel1), "%s", GlobalTaxiMan1);
		}
		if(!strlen(GlobalTaxiMan2)) {
		    format(GlobalTaxiDel2, sizeof(GlobalTaxiDel2), "none");
		} else {
		    format(GlobalTaxiDel2, sizeof(GlobalTaxiDel2), "%s", GlobalTaxiMan2);
		}
		if(!strlen(GlobalTaxiMan3)) {
		    format(GlobalTaxiDel3, sizeof(GlobalTaxiDel3), "none");
		} else {
		    format(GlobalTaxiDel3, sizeof(GlobalTaxiDel3), "%s", GlobalTaxiMan3);
		}
		if(!strlen(GlobalTaxiMan4)) {
		    format(GlobalTaxiDel4, sizeof(GlobalTaxiDel4), "none");
		} else {
		    format(GlobalTaxiDel4, sizeof(GlobalTaxiDel4), "%s", GlobalTaxiMan4);
		}
		if(!strlen(GlobalTaxiMan5)) {
		    format(GlobalTaxiDel5, sizeof(GlobalTaxiDel5), "none");
		} else {
		    format(GlobalTaxiDel5, sizeof(GlobalTaxiDel5), "%s", GlobalTaxiMan5);
		}
		format(strings, sizeof(strings),"* #1: %s with %d taxiruns completed", GlobalTaxiDel1, GlobalTaxi1);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #2: %s with %d taxiruns completed", GlobalTaxiDel2, GlobalTaxi2);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #3: %s with %d taxiruns completed", GlobalTaxiDel3, GlobalTaxi3);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #4: %s with %d taxiruns completed", GlobalTaxiDel4, GlobalTaxi4);
		SendClientMessage(playerid, COLOR_GOLD, strings);
		format(strings, sizeof(strings),"* #5: %s with %d taxiruns completed", GlobalTaxiDel5, GlobalTaxi5);
		SendClientMessage(playerid, COLOR_GOLD, strings);
	}
	return 1;
}

dcmd_sprintrace3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprint race since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprintrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a sprintrace.");
	  	    return 1;
		}
		if(sprintrace3inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace3players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprintrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprint race.");
			return 1;
		}
	 	if(sprintrace3inprogress == 0){
	        if(playerssprintrace3 < 2){
	            if(playerssprintrace3 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher18[i] = 0;
						sprintrace3players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace3countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a sprint race type 3",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 3. Type /sprintrace3 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					sprintrace3[0]=1;
					sprintrace3[1]=0;
					sprintrace3started=1;
					sprintrace3players[playerid]=1;
					playerssprintrace3=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					SprintRace3Finisher=0;
					AutoCancelSprint3=120;
					CheckpointsToBeCrossed[playerid]=17;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a sprint race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace3[1]=1;
					sprintrace3players[playerid]=1;
					playerssprintrace3=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the sprint race type 3.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprintrace.");
				    sprintrace3countdownseconds = 5;
					format(strings, sizeof(strings), "The sprint race type 3 is full and will start in %d seconds", sprintrace3countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=17;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 3 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_sprintrace4(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprintrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprintrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a sprintrace.");
	  	    return 1;
		}
		if(sprintrace4inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace4players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprintrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprint race.");
			return 1;
		}
	 	if(sprintrace4inprogress == 0){
	        if(playerssprintrace4 < 2){
	            if(playerssprintrace4 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher19[i] = 0;
						sprintrace4players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace4countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a sprint race type 4",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 4. Type /sprintrace4 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					sprintrace4[0]=1;
					sprintrace4[1]=0;
					sprintrace4started=1;
					sprintrace4players[playerid]=1;
					playerssprintrace4=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					SprintRace4Finisher=0;
					AutoCancelSprint4=120;
					CheckpointsToBeCrossed[playerid]=24;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a sprint race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace4[1]=1;
					sprintrace4players[playerid]=1;
					playerssprintrace4=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the sprint race type 4.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprintrace.");
				    sprintrace4countdownseconds = 5;
					format(strings, sizeof(strings), "The sprint race type 4 is full and will start in %d seconds", sprintrace4countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=24;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 4 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_sprintrace5(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprintrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprintrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a sprintrace.");
	  	    return 1;
		}
		if(sprintrace5inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace5players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprintrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprint race.");
			return 1;
		}
	 	if(sprintrace5inprogress == 0){
	        if(playerssprintrace5 < 2){
	            if(playerssprintrace5 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher20[i] = 0;
						sprintrace5players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace5countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a sprint race type 5",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 5. Type /sprintrace5 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					sprintrace5[0]=1;
					sprintrace5[1]=0;
					sprintrace5started=1;
					sprintrace5players[playerid]=1;
					playerssprintrace5=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					SprintRace5Finisher=0;
					AutoCancelSprint5=120;
					CheckpointsToBeCrossed[playerid]=19;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a sprint race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace5[1]=1;
					sprintrace5players[playerid]=1;
					playerssprintrace5=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the sprint race type 5.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprintrace.");
				    sprintrace5countdownseconds = 5;
					format(strings, sizeof(strings), "The sprint race type 5 is full and will start in %d seconds", sprintrace5countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=19;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 5 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_sprintrace6(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprintrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprintrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a sprintrace.");
	  	    return 1;
		}
		if(sprintrace6inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace6players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprintrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprint race.");
			return 1;
		}
	 	if(sprintrace6inprogress == 0){
	        if(playerssprintrace6 < 2){
	            if(playerssprintrace6 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher21[i] = 0;
						sprintrace6players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace6countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a sprint race type 6",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 6. Type /sprintrace6 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					sprintrace6[0]=1;
					sprintrace6[1]=0;
					sprintrace6started=1;
					sprintrace6players[playerid]=1;
					playerssprintrace6=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					SprintRace6Finisher=0;
					AutoCancelSprint6=120;
					CheckpointsToBeCrossed[playerid]=22;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a sprint race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace6[1]=1;
					sprintrace6players[playerid]=1;
					playerssprintrace6=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the sprint race type 6.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprintrace.");
				    sprintrace6countdownseconds = 5;
					format(strings, sizeof(strings), "The sprint race type 6 is full and will start in %d seconds", sprintrace6countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=22;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 6 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_sprintrace7(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this sprintrace since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a car in order to participate in a sprintrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID <= 61 || (vehicleID >= 219 && vehicleID < 254)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only cars and trucks in a sprintrace.");
	  	    return 1;
		}
		if(sprintrace7inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a sprint race in progress, please wait for it to finish.");
			return 1;
		}
		if(sprintrace7players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this sprintrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a car can sign up for a sprint race.");
			return 1;
		}
	 	if(sprintrace7inprogress == 0){
	        if(playerssprintrace7 < 2){
	            if(playerssprintrace7 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher22[i] = 0;
						sprintrace7players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace7countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a sprint race type 7",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a sprint race type 7. Type /sprintrace7 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					sprintrace7[0]=1;
					sprintrace7[1]=0;
					sprintrace7started=1;
					sprintrace7players[playerid]=1;
					playerssprintrace7=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					AutoCancelSprint7=120;
					SprintRace7Finisher=0;
					CheckpointsToBeCrossed[playerid]=36;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this sprint race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a sprint race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					sprintrace7[1]=1;
					sprintrace7players[playerid]=1;
					playerssprintrace7=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	            	deathmatcher19[playerid] = 0;
	            	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	            	deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the sprint race type 7.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your car, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the sprintrace.");
				    sprintrace7countdownseconds = 5;
					format(strings, sizeof(strings), "The sprint race type 7 is full and will start in %d seconds", sprintrace7countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=36;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a sprint race type 7 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_motorrace1(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this motor race since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a motor in order to participate in a motorrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID > 61){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only motorcycles in a motorrace.");
	  	    return 1;
		}
		if(motorrace1inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a motor race in progress, please wait for it to finish.");
			return 1;
		}
		if(motorrace1players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this motorrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a motor can sign up for a motorrace.");
			return 1;
		}
	 	if(motorrace1inprogress == 0){
	        if(playersmotorrace1 < 2){
	            if(playersmotorrace1 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher24[i] = 0;
						motorrace1players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace1countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a motor race type 1",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a motor race type 1. Type /motorrace1 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
			        deathmatcher19[playerid] = 0;
			        deathmatcher20[playerid] = 0;
	        	   	deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					motorrace1[0]=1;
					motorrace1[1]=0;
					motorrace1started=1;
					motorrace1players[playerid]=1;
					playersmotorrace1=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					MotorRace1Finisher=0;
					AutoCancelMotor1=120;
					CheckpointsToBeCrossed[playerid]=23;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a motor race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace1[1]=1;
					motorrace1players[playerid]=1;
					playersmotorrace1=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	        		deathmatcher19[playerid] = 0;
	        	 	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the motor race type 1.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the motorrace.");
				    if(motorrace1countdownseconds < 5) motorrace1countdownseconds = 5;
					format(strings, sizeof(strings), "The motor race type 1 is full and will start in %d seconds", motorrace1countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=23;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a motor race type 1 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_motorrace2(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this motor race since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a motor in order to participate in a motorrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID > 61){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only motorcycles in a motorrace.");
	  	    return 1;
		}
		if(motorrace2inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a motor race in progress, please wait for it to finish.");
			return 1;
		}
		if(motorrace2players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this motorrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a motor can sign up for a motorrace.");
			return 1;
		}
	 	if(motorrace2inprogress == 0){
	        if(playersmotorrace2 < 2){
	            if(playersmotorrace2 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher25[i] = 0;
						motorrace2players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace2countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a motor race type 2",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a motor race type 2. Type /motorrace2 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
			        deathmatcher19[playerid] = 0;
			        deathmatcher20[playerid] = 0;
	        	   	deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					motorrace2[0]=1;
					motorrace2[1]=0;
					motorrace2started=1;
					motorrace2players[playerid]=1;
					playersmotorrace2=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					MotorRace2Finisher=0;
					AutoCancelMotor2=120;
					CheckpointsToBeCrossed[playerid]=31;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a motor race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace2[1]=1;
					motorrace2players[playerid]=1;
					playersmotorrace2=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	        		deathmatcher19[playerid] = 0;
	        	 	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the motor race type 2.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the motorrace.");
				    if(motorrace2countdownseconds < 5) motorrace2countdownseconds = 5;
					format(strings, sizeof(strings), "The motor race type 2 is full and will start in %d seconds", motorrace2countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=31;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a motor race type 2 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_motorrace3(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this motor race since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a motor in order to participate in a motorrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID > 61){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only motorcycles in a motorrace.");
	  	    return 1;
		}
		if(motorrace3inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a motor race in progress, please wait for it to finish.");
			return 1;
		}
		if(motorrace3players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this motorrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a motor can sign up for a motorrace.");
			return 1;
		}
	 	if(motorrace3inprogress == 0){
	        if(playersmotorrace3 < 2){
	            if(playersmotorrace3 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher26[i] = 0;
						motorrace3players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace3countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a motor race type 3",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a motor race type 3. Type /motorrace3 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
			        deathmatcher19[playerid] = 0;
			        deathmatcher20[playerid] = 0;
	        	   	deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					motorrace3[0]=1;
					motorrace3[1]=0;
					motorrace3started=1;
					motorrace3players[playerid]=1;
					playersmotorrace3=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					MotorRace3Finisher=0;
					AutoCancelMotor3=120;
					CheckpointsToBeCrossed[playerid]=23;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a motor race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace3[1]=1;
					motorrace3players[playerid]=1;
					playersmotorrace3=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	        		deathmatcher19[playerid] = 0;
	        	 	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the motor race type 3.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the motorrace.");
				    if(motorrace3countdownseconds < 5) motorrace3countdownseconds = 5;
					format(strings, sizeof(strings), "The motor race type 3 is full and will start in %d seconds", motorrace3countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=23;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a motor race type 3 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_motorrace4(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this motor race since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a motor in order to participate in a motorrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID > 61){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only motorcycles in a motorrace.");
	  	    return 1;
		}
		if(motorrace4inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a motor race in progress, please wait for it to finish.");
			return 1;
		}
		if(motorrace4players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this motorrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a motor can sign up for a motorrace.");
			return 1;
		}
	 	if(motorrace4inprogress == 0){
	        if(playersmotorrace4 < 2){
	            if(playersmotorrace4 == 0){
					if(GetPlayerMoney(playerid)<50000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $50000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher27[i] = 0;
						motorrace4players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 50000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -50000, strings);
					motorrace4countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a motor race type 4",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a motor race type 4. Type /motorrace4 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
			        deathmatcher19[playerid] = 0;
			        deathmatcher20[playerid] = 0;
	        	   	deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					motorrace4[0]=1;
					motorrace4[1]=0;
					motorrace4started=1;
					motorrace4players[playerid]=1;
					playersmotorrace4=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					MotorRace4Finisher=0;
					AutoCancelMotor4=120;
					CheckpointsToBeCrossed[playerid]=17;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<50000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $40000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a motor race.", playerid, 50000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -50000, strings);
					motorrace4[1]=1;
					motorrace4players[playerid]=1;
					playersmotorrace4=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	        		deathmatcher19[playerid] = 0;
	        	 	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the motor race type 4.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the motorrace.");
				    if(motorrace4countdownseconds < 5) motorrace4countdownseconds = 5;
					format(strings, sizeof(strings), "The motor race type 4 is full and will start in %d seconds", motorrace4countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=17;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a motor race type 4 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_motorrace5(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		new vehicleID;
		if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You can't join this motor race since you are already subscribed you to a deathmatch.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, you need to be in a motor in order to participate in a motorrace.");
			return 1;
		}
		vehicleID=GetPlayerVehicleID(playerid);
		if(vehicleID > 61){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry mate, only motorcycles in a motorrace.");
	  	    return 1;
		}
		if(motorrace5inprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* There is already a motor race in progress, please wait for it to finish.");
			return 1;
		}
		if(motorrace5players[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are already signed up for this motorrace!");
			return 1;
		}
		if(!IsPlayerDriver(playerid)){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Only the driver of a motor can sign up for a motorrace.");
			return 1;
		}
	 	if(motorrace5inprogress == 0){
	        if(playersmotorrace5 < 2){
	            if(playersmotorrace5 == 0){
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $50000.");
						return 1;
					}
					for(new i=0;i<MAX_PLAYERS;i++){
						deathmatcher28[i] = 0;
						motorrace5players[i] = 0;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deag race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace5countdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a motor race type 5",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a motor race type 5. Type /motorrace5 to join", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					deathmatcher18[playerid] = 0;
			        deathmatcher19[playerid] = 0;
			        deathmatcher20[playerid] = 0;
	        	   	deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					deathmatcher28[playerid] = 0;
					motorrace5[0]=1;
					motorrace5[1]=0;
					motorrace5started=1;
					motorrace5players[playerid]=1;
					playersmotorrace5=1;
					DMplayer[playerid]=1;
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the race.");
					MotorRace5Finisher=0;
					AutoCancelMotor5=120;
					CheckpointsToBeCrossed[playerid]=27;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You do not have enough cash for this motor race. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a motor race.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					motorrace5[1]=1;
					motorrace5players[playerid]=1;
					playersmotorrace5=2;
					DMplayer[playerid]=1;
					deathmatcher18[playerid] = 0;
	        		deathmatcher19[playerid] = 0;
	        	 	deathmatcher20[playerid] = 0;
	           		deathmatcher21[playerid] = 0;
	        		deathmatcher22[playerid] = 0;
					deathmatcher24[playerid] = 0;
					deathmatcher25[playerid] = 0;
					deathmatcher26[playerid] = 0;
					deathmatcher27[playerid] = 0;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the motor race type 5.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Do not leave your motor, you need it for the race!");
					SendClientMessage(playerid, COLOR_SYSTEM_PW , "* If you are not in a vehicle at start, you will automatically loose the motorrace.");
				    if(motorrace5countdownseconds < 5) motorrace5countdownseconds = 5;
					format(strings, sizeof(strings), "The motor race type 5 is full and will start in %d seconds", motorrace5countdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					CheckpointsToBeCrossed[playerid]=27;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for the current race to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, there is already a motor race type 5 in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_cancelrace(playerid,params[]){
	#pragma unused params
	if(logged[playerid] == 1){
	    GetPlayerName(playerid, playername, sizeof(playername));
	    if(deathmatcher18[playerid] != 0){
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in sprintrace type 3.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
			DisablePlayerCheckpoint(playerid);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace3[playerid] = 0;
			Fined[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace3players[playerid] = 0;
			deathmatcher18[playerid]=0;
			if(SprintRace3Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 3 has been cancelled completely and is open for new drivers.");
				playerssprintrace3=0;
				sprintrace3started=0;
				sprintrace3inprogress=0;
				sprintrace3racer[0]=0;
				sprintrace3racer[1]=0;
				CancelSprint3 = 0;
				return 1;
			}
			if(CancelSprint3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 3 has been cancelled completely and is open for new drivers.");
				playerssprintrace3=0;
				sprintrace3started=0;
				sprintrace3inprogress=0;
				sprintrace3racer[0]=0;
				sprintrace3racer[1]=0;
				CancelSprint3 = 0;
			} else CancelSprint3 = 1;
			return 1;
		}
	    if(deathmatcher19[playerid] != 0){
			deathmatcher19[playerid]=0;
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in sprintrace type 4.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
		    RaceTiming[playerid] = 0;
			DisablePlayerCheckpoint(playerid);
			DMplayer[playerid] = 0;
			sprintrace4[playerid] = 0;
			Fined[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace4players[playerid] = 0;
			if(SprintRace4Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 4 has been cancelled completely and is open for new drivers.");
				playerssprintrace4=0;
				sprintrace4started=0;
				sprintrace4inprogress=0;
				sprintrace4racer[0]=0;
				sprintrace4racer[1]=0;
				CancelSprint4 = 0;
				return 1;
			}
			if(CancelSprint4 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 4 has been cancelled completely and is open for new drivers.");
				playerssprintrace4=0;
				sprintrace4started=0;
				sprintrace4inprogress=0;
				sprintrace4racer[0]=0;
				sprintrace4racer[1]=0;
				CancelSprint4 = 0;
			} else CancelSprint4 = 1;
			return 1;
		}
	    if(deathmatcher20[playerid] != 0){
			deathmatcher20[playerid]=0;
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in sprintrace type 5.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			DisablePlayerCheckpoint(playerid);
			sprintrace5[playerid] = 0;
			Fined[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace5players[playerid] = 0;
			if(SprintRace5Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 5 has been cancelled completely and is open for new drivers.");
				playerssprintrace5=0;
				sprintrace5started=0;
				sprintrace5inprogress=0;
				sprintrace5racer[0]=0;
				sprintrace5racer[1]=0;
				CancelSprint5 = 0;
				return 1;
			}
			if(CancelSprint5 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 5 has been cancelled completely and is open for new drivers.");
				playerssprintrace5=0;
				sprintrace5started=0;
				sprintrace5inprogress=0;
				sprintrace5racer[0]=0;
				sprintrace5racer[1]=0;
				CancelSprint5 = 0;
			} else CancelSprint5 = 1;
			return 1;
		}
	    if(deathmatcher21[playerid] != 0){
			deathmatcher21[playerid]=0;
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in sprintrace type 6.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace6[playerid] = 0;
			DisablePlayerCheckpoint(playerid);
			Fined[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace6players[playerid] = 0;
			if(SprintRace6Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 6 has been cancelled completely and is open for new drivers.");
				playerssprintrace6=0;
				sprintrace6started=0;
				sprintrace6inprogress=0;
				sprintrace6racer[0]=0;
				sprintrace6racer[1]=0;
				CancelSprint6 = 0;
				return 1;
			}
			if(CancelSprint6 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 6 has been cancelled completely and is open for new drivers.");
				playerssprintrace6=0;
				sprintrace6started=0;
				sprintrace6inprogress=0;
				sprintrace6racer[0]=0;
				sprintrace6racer[1]=0;
				CancelSprint6 = 0;
			} else CancelSprint6 = 1;
			return 1;
		}
	    if(deathmatcher22[playerid] != 0){
			deathmatcher22[playerid]=0;
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in sprintrace type 7.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace7[playerid] = 0;
			DisablePlayerCheckpoint(playerid);
			Fined[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace7players[playerid] = 0;
			if(SprintRace7Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 7 has been cancelled completely and is open for new drivers.");
				playerssprintrace7=0;
				sprintrace7started=0;
				sprintrace7inprogress=0;
				sprintrace7racer[0]=0;
				sprintrace7racer[1]=0;
				CancelSprint6 = 0;
				return 1;
			}
			if(CancelSprint7 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus sprint race type 7 has been cancelled completely and is open for new drivers.");
				playerssprintrace7=0;
				sprintrace7started=0;
				sprintrace7inprogress=0;
				sprintrace7racer[0]=0;
				sprintrace7racer[1]=0;
				CancelSprint7 = 0;
			} else CancelSprint7 = 1;
			return 1;
		}
	    if(deathmatcher24[playerid] != 0){
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in motorrace type 1.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
			DisablePlayerCheckpoint(playerid);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace1[playerid] = 0;
			Fined[playerid] = 0;
			motorracer[playerid] = 0;
			motorrace1players[playerid] = 0;
			deathmatcher24[playerid]=0;
			if(MotorRace1Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 1 has been cancelled completely and is open for new drivers.");
				playersmotorrace1=0;
				motorrace1started=0;
				motorrace1inprogress=0;
				motorrace1racer[0]=0;
				motorrace1racer[1]=0;
				CancelMotor1 = 0;
				return 1;
			}
			if(CancelMotor1 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 1 has been cancelled completely and is open for new drivers.");
				playersmotorrace1=0;
				motorrace1started=0;
				motorrace1inprogress=0;
				motorrace1racer[0]=0;
				motorrace1racer[1]=0;
				CancelMotor1 = 0;
			} else CancelMotor1 = 1;
			return 1;
		}
	    if(deathmatcher25[playerid] != 0){
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in motorrace type 2.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
			DisablePlayerCheckpoint(playerid);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace2[playerid] = 0;
			Fined[playerid] = 0;
			motorracer[playerid] = 0;
			motorrace2players[playerid] = 0;
			deathmatcher25[playerid]=0;
			if(MotorRace2Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 2 has been cancelled completely and is open for new drivers.");
				playersmotorrace2=0;
				motorrace2started=0;
				motorrace2inprogress=0;
				motorrace2racer[0]=0;
				motorrace2racer[1]=0;
				CancelMotor2 = 0;
				return 1;
			}
			if(CancelMotor2 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 2 has been cancelled completely and is open for new drivers.");
				playersmotorrace2=0;
				motorrace2started=0;
				motorrace2inprogress=0;
				motorrace2racer[0]=0;
				motorrace2racer[1]=0;
				CancelMotor2 = 0;
			} else CancelMotor2 = 1;
			return 1;
		}
	    if(deathmatcher26[playerid] != 0){
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in motorrace type 3.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
			DisablePlayerCheckpoint(playerid);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace3[playerid] = 0;
			Fined[playerid] = 0;
			motorracer[playerid] = 0;
			motorrace3players[playerid] = 0;
			deathmatcher26[playerid]=0;
			if(MotorRace3Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 3 has been cancelled completely and is open for new drivers.");
				playersmotorrace3=0;
				motorrace3started=0;
				motorrace3inprogress=0;
				motorrace3racer[0]=0;
				motorrace3racer[1]=0;
				CancelMotor3 = 0;
				return 1;
			}
			if(CancelMotor3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 3 has been cancelled completely and is open for new drivers.");
				playersmotorrace3=0;
				motorrace3started=0;
				motorrace3inprogress=0;
				motorrace3racer[0]=0;
				motorrace3racer[1]=0;
				CancelMotor3 = 0;
			} else CancelMotor3 = 1;
			return 1;
		}
	    if(deathmatcher27[playerid] != 0){
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in motorrace type 4.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
			DisablePlayerCheckpoint(playerid);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace4[playerid] = 0;
			Fined[playerid] = 0;
			motorracer[playerid] = 0;
			motorrace4players[playerid] = 0;
			deathmatcher27[playerid]=0;
			if(MotorRace4Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 4 has been cancelled completely and is open for new drivers.");
				playersmotorrace4=0;
				motorrace4started=0;
				motorrace4inprogress=0;
				motorrace4racer[0]=0;
				motorrace4racer[1]=0;
				CancelMotor4 = 0;
				return 1;
			}
			if(CancelMotor4 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 4 has been cancelled completely and is open for new drivers.");
				playersmotorrace4=0;
				motorrace4started=0;
				motorrace4inprogress=0;
				motorrace4racer[0]=0;
				motorrace4racer[1]=0;
				CancelMotor4 = 0;
			} else CancelMotor4 = 1;
			return 1;
		}
	    if(deathmatcher28[playerid] != 0){
	        format(strings, sizeof(strings), "* %s has cancelled his praticipation in motorrace type 5.", playername);
			SendClientMessageToAll(COLOR_SYSTEM_PW, strings);
			DisablePlayerCheckpoint(playerid);
		    RaceTiming[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace5[playerid] = 0;
			Fined[playerid] = 0;
			motorracer[playerid] = 0;
			motorrace5players[playerid] = 0;
			deathmatcher28[playerid]=0;
			if(MotorRace5Finisher == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 5 has been cancelled completely and is open for new drivers.");
				playersmotorrace5=0;
				motorrace5started=0;
				motorrace5inprogress=0;
				motorrace5racer[0]=0;
				motorrace5racer[1]=0;
				CancelMotor5 = 0;
				return 1;
			}
			if(CancelMotor5 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* By thus motor race type 5 has been cancelled completely and is open for new drivers.");
				playersmotorrace5=0;
				motorrace5started=0;
				motorrace5inprogress=0;
				motorrace5racer[0]=0;
				motorrace5racer[1]=0;
				CancelMotor5 = 0;
			} else CancelMotor5 = 1;
			return 1;
		}
	}
	return 1;
}

dcmd_unban(playerid,params[]){
	new index = 0;
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		tmps1 = strtok(params,index);
		if(!strlen(tmps1)){
			SendClientMessage(playerid, COLOR_ADMIN_CMD , "* USAGE: /unban [playername]. This will remove the parameter banned out of [playername] profile. Note that it will not remove the IP from the banlist.");
			return 1;
		}
		if (dini_Exists(udb_encode(tmps1))) {
		    dini_IntSet(udb_encode(tmps1), "banned", 0);
			format(strings,sizeof(strings),"* You have unbanned %s - if you remove the IP from the banlist the player can login again",tmps1);
			SendClientMessage(playerid,COLOR_RED,strings);
			printf(strings);
		} else {
			format(strings, sizeof(strings), "* %s no such account.", tmps1);
			SendClientMessage(playerid, COLOR_ADMIN_PW , strings);
		}
	}
	return 1;
}

dcmd_chatoff(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		MuteAll=10;
		SendClientMessageToAll(COLOR_SYSTEM_GM, "* The admins have closed the public chat for now. You can still use PM and grouptalk.");
	}
	return 1;
}

dcmd_chaton(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
		MuteAll=0;
		SendClientMessageToAll(COLOR_SYSTEM_GM, "* The admins have opened the public chat again.");
	}
	return 1;
}

dcmd_rusroulette(playerid,params[])  {
	new index=0;
	new RouletteChoice;

	if(logged[playerid] == 1){
	    if(DMplayer[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't join the Russian Roulette, you already subscribed you to a deathmatch or race.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* If you are not subscribed to a deathmatch or race, you can reset your indicator with /resetdm.");
			return 1;
		}
		if(jailed[playerid] == 1) {
		    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You cannot use this feature while you are jailed! No fun in jail!");
		    return 1;
		}
		if(russianmatchinprogress == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* There is already Russian Roulette in progress, please wait for it to finish.");
			return 1;
		}
		if(russianmatchplayers[playerid] == 1){
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You are already signed up for this Russian Roulette!");
			return 1;
		}
	 	if(russianmatchinprogress == 0){
	        if(playersrussianmatch < 2){
	            if(playersrussianmatch == 0){
					tmps1 = strtok(params, index);
					if(!strlen(tmps1) || !IsNumeric(tmps1)) {
						SendClientMessage(playerid, COLOR_ADMIN_CMD, "* USAGE: /rusroulette [number of bullets]. This starts a Russian Roulette with [number of bullets] in the gun - choose between 1 and 3.");
						return 1;
					}
					RouletteChoice = strval(tmps1);
					if(RouletteChoice < 1 || RouletteChoice > 3) {
						SendClientMessage(playerid, COLOR_ADMIN_CMD, "* Invalid number of bullets chosen. You need to choose between the 1 and 3.");
						return 1;
					}
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $25000.");
						return 1;
					}
					RussianRouletteChoice=RouletteChoice;
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					russiancountdownseconds = 30;
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "~w~%s created a russian roulette",playername);
					GameTextForAll(strings,3000,4);
					format(strings, sizeof(strings), "%s has created a russian roulette match with %d bullets. Type /rusroulette to join", playername, RussianRouletteChoice);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					russianmatch[0]=1;
					russianmatchstarted=1;
					russianmatchplayers[playerid]=1;
					playersrussianmatch=1;
					DMplayer[playerid]=1;
					russianrouletteplayer0=playerid;
					return 1;
				} else {
					if(GetPlayerMoney(playerid)<25000){
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You do not have enough cash for this deathmatch. You need $25000.");
						return 1;
					}
					format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", playerid, 25000, GetPlayerMoney(playerid));
					StatGivePlayerMoney(playerid, -25000, strings);
					GetPlayerName(playerid,playername,sizeof(playername));
					format(strings, sizeof(strings), "%s has joined the russian roulette match.", playername);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					russianmatch[1]=1;
					russianmatchplayers[playerid]=1;
					playersrussianmatch=2;
					DMplayer[playerid]=1;
					format(strings, sizeof(strings), "Russian roulette is full and will start in %d seconds", russiancountdownseconds);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					russianrouletteplayer1=playerid;
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, the waitinglist is full.");
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for the current match to end.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry, there is already a russian roulette match in progress.");
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You'll have to wait for it to end.");
		}
	}
	return 1;
}

dcmd_buyautolock(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(GetPlayerMoney(playerid)<2500000){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry sir, the automatic carlock currently costs $2.500.000 .");
					return 1;
				}
				if(autolock[playerid]==1){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already have a automatic carlock, you can't buy another one .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he bought a autocarlock.", playerid, 25000000, GetPlayerMoney(playerid));
				StatGivePlayerMoney(playerid, -2500000, strings);
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has bought a automatic carlock for $2500000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "The autolock locks the doors when you exceed 20 km/h in a car. If you stop, the doors stays locked.");
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "If you want someone to enter your vehicle, use /open or /unlock to open the doors for that person.");
				autolock[playerid]=1;
				dini_IntSet(udb_encode(playername), "autolock", autolock[playerid]);
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy an automatich carlock here. Check with your local black market salesman.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy your automatic carlock here. Check with your local black market salesman.");
		}
	}
	return 1;
}

dcmd_creditautolock(playerid,params[])  {
	#pragma unused params
	new CashForBank;
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(bank[playerid]<3250000){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry sir, you do not have the required $3.250.000 on your bank to cover this purchase.");
					return 1;
				}
				if(autolock[playerid]==1){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already have an automatic carlock, you can't buy another one .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he bought a autolock.", playerid, 3250000, GetPlayerMoney(playerid));
				bank[playerid]=bank[playerid]-3250000;
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has bought an automatic carlock with his creditcard for $3250000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				autolock[playerid]=1;
				dini_IntSet(udb_encode(playername), "autolock", autolock[playerid]);
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "The autolock locks the doors when you exceed 20 km/h in a car. If you stop, the doors stays locked.");
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "If you want someone to enter your vehicle, use /open or /unlock to open the doors for that person.");
				if (propertyOwner[P_BANKADMIN] < 999) {
    		        CashForBank = floatround(750000 / 6);
		    	    format(moneyreason, sizeof(moneyreason), "* Money increased for %d by $%d because the player received creditcard commissions.", propertyOwner[P_BANKADMIN], CashForBank);
    			    StatGivePlayerMoney(propertyOwner[P_BANKADMIN], CashForBank, moneyreason);
  	    			format(strings, sizeof(strings), "* You received out of credit card commissions $%d.", CashForBank);
					SendClientMessage(propertyOwner[P_BANKADMIN], COLOR_SYSTEM_PM, strings);
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy an automatich carlock here. Check with your local black market salesman.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy your automatic carlock here. Check with your local black market salesman.");
		}
	}
	return 1;
}

dcmd_sellautolock(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(autolock[playerid]==0){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell what you don't have! .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because he sold a speedometer.", playerid, 500000, GetPlayerMoney(playerid));
				StatGivePlayerMoney(playerid, 500000, strings);
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has sold an automated carlock for $500000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				autolock[playerid]=0;
				dini_IntSet(udb_encode(playername), "autolock", autolock[playerid]);
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell your automatic carlock here. Check with your local black market salesman.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell your automatic carlock here. Check with your local black market salesman.");
		}
	}
	return 1;
}

dcmd_buyfuelcan(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(GetPlayerMoney(playerid)<2000000){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry sir, the fuel can currently costs $2.000.000 .");
					return 1;
				}
				if(Fuelcan[playerid]==1){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already have an emergency fuel can, you can't buy another one .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he bought a fuel can.", playerid, 20000000, GetPlayerMoney(playerid));
				StatGivePlayerMoney(playerid, -2000000, strings);
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has bought an emergency fuelcan for $2000000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "When you enter a vehicle which has less than 10% fuel in its tank, you automatically add 10 liters to the tank.");
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "Note that you can do this only once, then you need to refill your tank using /fillupcan at a fuelstation.");
				Fuelcan[playerid]=1;
				FuelcanContent[playerid]=1;
				dini_IntSet(udb_encode(playername), "fuelcan", Fuelcan[playerid]);
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy an emergency fuel can here. Check with your local black market salesman.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy your emergency fuel can here. Check with your local black market salesman.");
		}
	}
	return 1;
}

dcmd_creditfuelcan(playerid,params[])  {
	#pragma unused params
	new CashForBank;
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(bank[playerid]<2600000){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Sorry sir, you do not have the required $2.600.000 on your bank to cover this purchase.");
					return 1;
				}
				if(Fuelcan[playerid]==1){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You already have an emergency fuel can, you can't buy another one .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he bought a autolock.", playerid, 2600000, GetPlayerMoney(playerid));
				bank[playerid]=bank[playerid]-2600000;
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has bought an emergency fuel can with his creditcard for $2600000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				Fuelcan[playerid]=1;
				dini_IntSet(udb_encode(playername), "fuelcan", Fuelcan[playerid]);
				FuelcanContent[playerid]=1;
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "When you enter a vehicle which has less than 10% fuel in its tank, you automatically add 10 liters to the tank.");
				SendClientMessage(playerid,COLOR_SYSTEM_PM, "Note that you can do this only once, then you need to refill your tank using /fillupcan at a fuelstation.");
				if (propertyOwner[P_BANKADMIN] < 999) {
    		        CashForBank = floatround(600000 / 6);
		    	    format(moneyreason, sizeof(moneyreason), "* Money increased for %d by $%d because the player received creditcard commissions.", propertyOwner[P_BANKADMIN], CashForBank);
    			    StatGivePlayerMoney(propertyOwner[P_BANKADMIN], CashForBank, moneyreason);
  	    			format(strings, sizeof(strings), "* You received out of credit card commissions $%d.", CashForBank);
					SendClientMessage(propertyOwner[P_BANKADMIN], COLOR_SYSTEM_PM, strings);
				}
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy an emergency fuel can here. Check with your local black market salesman.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't buy your emergency fuel can here. Check with your local black market salesman.");
		}
	}
	return 1;
}

dcmd_sellfuelcan(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		if(IsPlayerInCheckpoint(playerid)) {
			if ((playerCheckpoint[playerid]) == CP_SPEEDO){
				if(Fuelcan[playerid]==0){
					SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell what you don't have! .");
					return 1;
				}
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because he sold a fuelcan.", playerid, 400000, GetPlayerMoney(playerid));
				StatGivePlayerMoney(playerid, 400000, strings);
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings), "%s has sold his/hers emergency fuel can for $400000.", playername);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				Fuelcan[playerid]=0;
				FuelcanContent[playerid]=0;
				dini_IntSet(udb_encode(playername), "autolock", autolock[playerid]);
			} else {
				SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell your emergency fuel can here. Check with your local black market salesman.");
			}
		} else {
			SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can't sell your emergency fuel can here. Check with your local black market salesman.");
		}
	}
	return 1;
}

dcmd_payout(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* From now on the profit of your properties will pay out directly as cash.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* This means that the properties do not increase in value anymore.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* If you want to return to the situation where your properties increase in value,");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* issue the command /nopayout");
		GetPlayerName(playerid,playername,sizeof(playername));
		Payout[playerid]=1;
		dini_IntSet(udb_encode(playername), "payout", Payout[playerid]);
	}
	return 1;
}

dcmd_nopayout(playerid,params[])  {
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* From now on your properties will increase value each minute, and not pay out the profit directly.");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* If you want to return to the situation where your properties pay out directly,");
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* issue the command /payout");
		GetPlayerName(playerid,playername,sizeof(playername));
		Payout[playerid]=0;
		dini_IntSet(udb_encode(playername), "payout", Payout[playerid]);
	}
	return 1;
}

dcmd_disablepatrol(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
	    if(PatrolTimer2 > 0 && PatrolDisable == 1){
			SendClientMessageToAll(COLOR_ADMIN_PM, "* The patrolmission is already been disabled.");
	        return 1;
	    }
		PatrolTimer2=15;
		PatrolDisable = 1;
        PatrolCountingUp = 0;
		SendClientMessageToAll(COLOR_SYSTEM_PM, "* The admins have disabled the patrol mission for the next 15 minutes.");
		for(new i; i < MAX_PLAYERS; i++){
		    if(IsPlayerConnected(i)){
		        if(HighwayOnMission[i] == 1){
		            HighwayOnMission[i] = 0;
					OutOfRanger[i]=0;
					HighwayMission = 0;
					SetPlayerColor(i,playerColors[i]);
				}
		    }
		}
	}
	return 1;
}

dcmd_enablepatrol(playerid,params[])  {
	#pragma unused params
	if(IsAdmin(playerid) && adminlevel[playerid] > 2) {
	    if(PatrolDisable == 0){
			SendClientMessageToAll(COLOR_ADMIN_PM, "* The patrolmission is already been enabled.");
	        return 1;
	    }
		PatrolTimer2=0;
		PatrolDisable = 0;
		SendClientMessageToAll(COLOR_SYSTEM_PM, "* The admins have enabled the patrol mission again.");
	}
	return 1;
}

dcmd_hudcolor(playerid,params[]){
	new index = 0;
	new temp;
	if(logged[playerid] == 1){
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* USAGE: /hudcolor [0-7]. With this command you can set the text in the HUD on the bottom of your screen to a custom color.");
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Choose one of the following numbers for your custom color:");
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* 0 = default *** 1 = red *** 2 = blue *** 3 = green *** 4 = yellow");
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* 5 = purple *** 6 = white *** 7 = black");
			return 1;
		}
		temp=strval(tmps1);
		if(temp < 0 || temp > 7){
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Invalid choice! Choose one of the following numbers for your custom color:");
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* 0 = default *** 1 = red *** 2 = blue *** 3 = green *** 4 = yellow");
            SendClientMessage(playerid, COLOR_SYSTEM_PW, "* 5 = purple *** 6 = white *** 7 = black");
			return 1;
		}
		HUDColor[playerid] = temp;
		format(strings, sizeof(strings),"* You have set your HUD color to %s (choice %d). You can change it anytime you like.", HUDColorNames[HUDColor[playerid]], HUDColor[playerid]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		dini_IntSet(udb_encode(playername), "hudcolor", HUDColor[playerid]);
	}
	return 1;
}

dcmd_colors(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Use one of the following commands to see the list of available colors:");
		SendClientMessage(playerid, COLOR_PLAYER_BLUE, "* /colors1 to see the available blue playercolors");
		SendClientMessage(playerid, COLOR_PLAYER_RED, "* /colors2 to see the available red playercolors");
		SendClientMessage(playerid, COLOR_PLAYER_GREEN, "* /colors3 to see the available green playercolors");
		SendClientMessage(playerid, COLOR_PLAYER_YELLOW, "* /colors4 to see the available yellow playercolors");
		SendClientMessage(playerid, COLOR_PLAYER_PURPLE, "* /colors5 to see the available purple playercolors");
		SendClientMessage(playerid, COLOR_PLAYER_BROWN, "* /colors6 to see the available brown playercolors");
		SendClientMessage(playerid, COLOR_PLAYER_GREY, "* /colors7 to see the available grey playercolors");
		SendClientMessage(playerid, COLOR_MENU, "* /colors8 to see the available misc. playercolors");
	}
	return 1;
}

dcmd_colors1(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTBLUE, "* Color number 0 for light blue.");
		SendClientMessage(playerid, COLOR_PLAYER_BLUE, "* Color number 1 for blue.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKBLUE, "* Color number 2 for dark blue.");
		SendClientMessage(playerid, COLOR_PLAYER_SPECIALBLUE, "* Color number 3 for special blue.");
	}
	return 1;
}

dcmd_colors2(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTRED, "* Color number 4 for light red.");
		SendClientMessage(playerid, COLOR_PLAYER_RED, "* Color number 5 for red.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKRED, "* Color number 6 for dark red.");
		SendClientMessage(playerid, COLOR_PLAYER_SPECIALRED, "* Color number 7 for special red.");
	}
	return 1;
}

dcmd_colors3(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTGREEN, "* Color number 8 for light green.");
		SendClientMessage(playerid, COLOR_PLAYER_GREEN, "* Color number 9 for green.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKGREEN, "* Color number 10 for dark green.");
		SendClientMessage(playerid, COLOR_PLAYER_SPECIALGREEN, "* Color number 11 for special green.");
	}
	return 1;
}

dcmd_colors4(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTYELLOW, "* Color number 12 for light yellow.");
		SendClientMessage(playerid, COLOR_PLAYER_YELLOW, "* Color number 13 for yellow.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKYELLOW, "* Color number 14 for dark yellow.");
		SendClientMessage(playerid, COLOR_PLAYER_SPECIALYELLOW, "* Color number 15 for special yellow.");
	}
	return 1;
}

dcmd_colors5(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTPURPLE, "* Color number 16 for light purple.");
		SendClientMessage(playerid, COLOR_PLAYER_PURPLE, "* Color number 17 for purple.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKPURPLE, "* Color number 18 for dark purple.");
		SendClientMessage(playerid, COLOR_PLAYER_SPECIALPURPLE, "* Color number 19 for special purple.");
	}
	return 1;
}

dcmd_colors6(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTBROWN, "* Color number 20 for light brown.");
		SendClientMessage(playerid, COLOR_PLAYER_BROWN, "* Color number 21 for brown.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKBROWN, "* Color number 22 for dark brown.");
	}
	return 1;
}

dcmd_colors7(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_LIGHTGREY, "* Color number 23 for light grey.");
		SendClientMessage(playerid, COLOR_PLAYER_GREY, "* Color number 24 for grey.");
		SendClientMessage(playerid, COLOR_PLAYER_DARKGREY, "* Color number 25 for dark grey.");
	}
	return 1;
}

dcmd_colors8(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
		SendClientMessage(playerid, COLOR_MENU, "* Choosing your player color costs you $500.000 once. When you have chosen your custom player color once,");
		SendClientMessage(playerid, COLOR_MENU, "* you can choose for free from then on. When chosen a color, you will always play with that color.");
		SendClientMessage(playerid, COLOR_MENU, "* To choose a color, use /owncolor [colornumber] .");
		SendClientMessage(playerid, COLOR_PLAYER_WHITE, "* Color number 26 for white.");
		SendClientMessage(playerid, COLOR_PLAYER_BLACK, "* Color number 27 for black.");
		SendClientMessage(playerid, COLOR_PLAYER_AQUAMARINE, "* Color number 28 for aquamarine.");
		SendClientMessage(playerid, COLOR_PLAYER_CYAN, "* Color number 29 for cyan.");
	}
	return 1;
}

dcmd_owncolor(playerid, params[]){
	new index=0;
	new colorofchoice;
	if(logged[playerid] == 1){
	    if(OwnPlayerColorChosen[playerid] == 0 && GetPlayerMoney(playerid)<500000){
			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry, but you need to have $ 500.000 in order to choose your own color.");
			return 1;
		}
		tmps1 = strtok(params, index);
		if(!strlen(tmps1) || !IsNumeric(tmps1)) {
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* USAGE: /owncolor [colornumber]. This sets your playercolor to the chosen color.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You can choose between 0 and 29, see /colors for the available player colors.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* The charge to set your own color is $500.000, but it is only charged once.");
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* The next time you chose a color, it will be free of charge.");
			return 1;
		}
		colorofchoice=strval(tmps1);
		if(colorofchoice < 0 || colorofchoice > 29){
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* You can choose between 0 and 29, see /colors for the available player colors.");
		}
	    if(OwnPlayerColorChosen[playerid] == 0){
			format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because he purchased an own player color.", playerid, 500000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, -500000, strings);
			OwnPlayerColorChosen[playerid] = 1;
			dini_IntSet(udb_encode(playername), "owncolorchosen", OwnPlayerColorChosen[playerid]);
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have payed $ 500.000 for this service, from now on it is free of charge.");
		}
		OwnPlayerColor[playerid]=colorofchoice;
	    SetPlayerColor(playerid, PlayerColorsChoice[colorofchoice]);
		dini_IntSet(udb_encode(playername), "owncolor", OwnPlayerColor[playerid]);
		format(strings, sizeof(strings), "* You have set your player color to %s.", PlayerColorNames[colorofchoice]);
		SendClientMessage(playerid, PlayerColorsChoice[colorofchoice], strings);
	}
	return 1;
}

dcmd_removeowncolor(playerid, params[]){
	#pragma unused params
	if(logged[playerid] == 1){
	    if(OwnPlayerColorChosen[playerid] == 0){
			SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You have not chosen an own color in the past, so there is nothing to reset.");
			return 1;
		}
		OwnPlayerColorChosen[playerid] = 0;
		dini_IntSet(udb_encode(playername), "owncolorchosen", OwnPlayerColorChosen[playerid]);
		OwnPlayerColor[playerid]=999;
	    SetPlayerColor(playerid, playerColors[playerid]);
		SendClientMessage(playerid, playerColors[playerid], "* You have set your player color to the default value.");
	}
	return 1;
}

dcmd_lvplaytime(playerid,params[]){
	#pragma unused params
	if(logged[playerid] == 1 && adminlevel[playerid] > 2){
	    if(LVPartytime > 0){
	        format(strings, sizeof(strings), "* It is already playtime within LV city limits for the next %d minutes.", LVPartytime);
            SendClientMessage(playerid, COLOR_ADMIN_PW, strings);
            return 1;
	    }
	    LVPartytime=5;
        SendClientMessageToAll(COLOR_ADMIN_TOALL, "* Las Venturas party time! Ask your admin for a weapon for usage within LV city limits.");
	}
	return 1;
}

public OnPlayerSpawn(playerid)
{
	new playercash, temp;

	GetPlayerName(playerid, playername, sizeof(playername));

    if (dini_Exists(udb_encode(playername))) {
		if(logged[playerid] == 0) {
			SetPlayerInterior(playerid,12);
			SetPlayerFacingAngle(playerid, 90);
			SetCameraBehindPlayer(playerid);
	     	SetPlayerPos(playerid, notLoggedSpawn[0], notLoggedSpawn[1], notLoggedSpawn[2]);
	     	spawned[playerid] = 1;
	     	GameTextForPlayer(playerid, "~w~ You are not logged in! type /login", 120000, 3);
			SendClientMessage(playerid, COLOR_GREENYELLOW, "* You are not logged in. Type /login <password> to login.");
			SendClientMessage(playerid, COLOR_GREENYELLOW, "* Note that you will receive your spawn weapons at your next spawn (next time you have died).");
			LoginTimeout[playerid]=60;
	     	return 1;
 		}
	} else {
		SetPlayerInterior(playerid,3);
		SetPlayerFacingAngle(playerid, 90);
		SetCameraBehindPlayer(playerid);
	    SetPlayerPos(playerid, notLoggedSpawn[0], notLoggedSpawn[1], notLoggedSpawn[2]);
	    spawned[playerid] = 1;
   	    GameTextForPlayer(playerid, "~w~ You require an account! type /register", 120000, 3);
    	SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Before you can play, you need to register. You can type /register <your password>.");
        SendClientMessage(playerid, COLOR_SYSTEM_PM, "* After successful registration, identify yourself using /login <your password>.");
        SendClientMessage(playerid, COLOR_SYSTEM_PM, "* This server saves your progress(money, frags, etc).");
   	    LoginTimeout[playerid]=60;
	    return 1;
 	}

	SetPlayerInterior(playerid,0);
	SetPlayerRandomSpawn(playerid);
	spawned[playerid] = 1;

	tmps1 = dini_Get(FILE_SETTINGS, "spawnweapons");
	if (strval(tmps1) == 1) {
    	tmps1 = dini_Get(udb_encode(playername), "weapon1");
		if (strval(tmps1) != 0){
			GivePlayerWeapon(playerid, strval(tmps1), 1);
			melee[playerid] = strval(tmps1);
		}
		tmps1 = dini_Get(udb_encode(playername), "weapon3");
		tmps2 = dini_Get(udb_encode(playername), "ammo3");
		if (strval(tmps1) != 0 && strval(tmps2) != 0){
			GivePlayerWeapon(playerid, strval(tmps1), strval(tmps2));
			shotgun[playerid] = strval(tmps1);
			shotgunammo[playerid] = strval(tmps2);
		}
		tmps1 = dini_Get(udb_encode(playername), "weapon4");
		tmps2 = dini_Get(udb_encode(playername), "ammo4");
		if (strval(tmps1) != 0 && strval(tmps2) != 0){
			GivePlayerWeapon(playerid, strval(tmps1), strval(tmps2));
			smg[playerid] = strval(tmps1);
			smgammo[playerid] = strval(tmps2);
		}
		tmps1 = dini_Get(udb_encode(playername), "weapon5");
		tmps2 = dini_Get(udb_encode(playername), "ammo5");
		if (strval(tmps1) != 0 && strval(tmps2) != 0){
			GivePlayerWeapon(playerid, strval(tmps1), strval(tmps2));
			rifle[playerid] = strval(tmps1);
			rifleammo[playerid] = strval(tmps2);
		}
    	tmps1 = dini_Get(udb_encode(playername), "weapon6");
		if (strval(tmps1) != 0){
			GivePlayerWeapon(playerid, strval(tmps1), 1);
			gift[playerid] = strval(tmps1);
		}
		tmps1 = dini_Get(udb_encode(playername), "weapon2");
		tmps2 = dini_Get(udb_encode(playername), "ammo2");
		if (strval(tmps1) != 0 && strval(tmps2) != 0){
			GivePlayerWeapon(playerid, strval(tmps1), strval(tmps2));
			pistol[playerid] = strval(tmps1);
			pistolammo[playerid] = strval(tmps2);
		}
	}

	if (jailed[playerid] == 1) {
		SetPlayerInterior(playerid,10);
		SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
		if(jailcelcounter < 3) {
		    jailcelcounter++;
		} else {
		    jailcelcounter=0;
		}
		format(strings, sizeof(strings), "--- %s spawned as prisoner.", playername);
		printf(strings);
	    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Your prisoner status is restored.");
	}

    tmps1 = dini_Get(udb_encode(playername), "speedometer");
	if (strval(tmps1) != 0) speedometer[playerid] = 1;

	if (GetPlayerMoney(playerid) <= 0) {
		// TO-DO money scanner update
		format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d got spawn pocketmoney.", PocketMoney-GetPlayerMoney(playerid), GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, PocketMoney-GetPlayerMoney(playerid), moneyreason);
	}

	if (FirstSpawn[playerid] == 1 ) {
	    if(OwnPlayerColorChosen[playerid] == 0){
		    SetPlayerColor(playerid, playerColors[playerid]);
		} else {
			temp=PlayerColorsChoice[OwnPlayerColor[playerid]];
		    SetPlayerColor(playerid, temp);
		}
	    LoginTimeout[playerid]=0;
		SpawnTimeout[playerid] = 15;
		FirstSpawn[playerid] = 0;
	    if (!IsAdmin(playerid)){
			SendClientMessage(playerid, COLOR_RED,"* New on this server? Check out /rules or /rulesnl for the applied rules for this server.");
			SendClientMessage(playerid, COLOR_RED,"* For some hints and tips type /tip or /tipnl. Enjoy your time on this server!");
			FirstSpawn[playerid] = 0;
		}
	} else {
		if(NoReset[playerid]==0){
		    playercash=GetPlayerMoney(playerid);
		    if(playercash > 600){
	    	    playercash=playercash-600;
				format(moneyreason, sizeof(moneyreason), "* Money set to $500 (old: $%d), because player-id %d died.", GetPlayerMoney(playerid), playerid);
				StatGivePlayerMoney(playerid, -playercash, moneyreason);
	    		SendClientMessage(playerid,COLOR_SYSTEM_PW, "* Your cash has been resetted to $500.");
	    	}
		}
		NoReset[playerid]=0;
	}

	SpawnedPlayer[playerid]=1;
	DisarmedPlayer[playerid] = 0;
	Killed[playerid] = 0;

	return 1;
}

public OnPlayerText(playerid, text[]) {
	new privatestrings[256];
	new adminchat[256];
	new grouptalk[256];
	new grouptalkid;
    new character[256];
    new newcharacter[256];
	new replaced;

	GetPlayerName(playerid, playername, sizeof(playername));

	if(IsPlayerConnected(playerid) && !logged[playerid]) {
	    SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are muted and cannot send messages, because you are not logged in. Login with /login.");
	    return 0;
	}

	if (IsPlayerConnected(playerid) && (muted[playerid] == 1)) {
		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You are muted and cannot send messages.");
		return 0;
	}

	if(IsPlayerConnected(playerid) && logged[playerid]) {
	    if(text[0] == '@') {
		    if(IsAdmin(playerid)) {
		        strmid(adminchat,text,1,strlen(text));
		        format(privatestrings, sizeof(strings),"@%s: %s", playername, adminchat);

				for(new i = 0; i < MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i) && IsAdmin(i)) {
							SendClientMessage(i, COLOR_ADMINCHAT, privatestrings);
					}
				}
				format(privatestrings, sizeof(strings), "%s --- ADMIN %s (id: %d) said: %s", SystemTime,playername,playerid,adminchat);
				printf(privatestrings);
			} else {
				SendClientMessage(playerid, COLOR_ADMINCHAT , "You are not an admin.");
			}
			return 0;
		}

		if (text[0] == '!' && query[playerid] != 255) {
	 		if (IsPlayerConnected(query[playerid])) {
	 		    GetPlayerName(query[playerid], giveplayer, sizeof(giveplayer));
				if(IgnorePlayerlist[query[playerid]][playerid] == 0) {
		 		    format(strings, sizeof(strings), "* PM from %s (id: %d): %s", playername,playerid,text);
		    		SendClientMessage(query[playerid], COLOR_IRC, strings);
				}
				format(strings, sizeof(strings), "* PM to %s (id: %d): %s", giveplayer,query[playerid],text);
	    		SendClientMessage(playerid, COLOR_IRC, strings);
	 		}
	 		else {
				format(strings, sizeof(strings), "* %d is not an active player.", query[playerid]);
				SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
			}
			return 0;
		}
		if (text[0] == '#') {
			if (GroupTalkers[playerid] != 0) {
				grouptalkid=GroupTalkers[playerid];
		        strmid(grouptalk,text,1,strlen(text));
			    for (new i=0;i<MAX_PLAYERS;i++){
			        if(GroupTalkers[i] == grouptalkid && IsPlayerConnected(i)){
						format(strings, sizeof(strings), "* Groupmessage from %s: %s", playername,grouptalk);
		    			SendClientMessage(i, COLOR_GROUPTALK, strings);
		    		}
		    	}
		    } else {
		        SendClientMessage(playerid,COLOR_SYSTEM_PW,"* # is used for grouptalk conversations.");
		    }
            return 0;
		}
	}

	for(new i=0; i<(strlen(text)); i++) {
		//next character
		strmid(character, text, i, i+1, 2);
		if(i==0){
		    format(strings, sizeof(strings),"%s",character);
		} else {
		    replaced = 0;
		    for(new x=0;x<27;x++){
		        if(strcmp(character,alphabet[x],true)==0){
					format(newcharacter, sizeof(newcharacter), "%s",calphabet[x]);
					replaced = 1;
				}
			}
			if(replaced == 0){
			    format(newcharacter, sizeof(newcharacter), "%s", character);
			}
		    format(strings, sizeof(strings),"%s%s", strings, newcharacter);
		}
	}

	format(text, sizeof(strings),"%s", strings);

	if(MuteAll > 0){
		SendClientMessage(playerid, COLOR_SYSTEM_PW, "* The admins have closed the public chat for now. Use PM or groupchat to communicate.");
		return 0;
	} else {
		if(FloodProtectionTimer[playerid] != 0 && FloodProtectionCounter[playerid] > 2){
			SendClientMessage(playerid, COLOR_SYSTEM_PW, "* Flood protection: only 3 message every 10 seconds!");
			return 0;
		}
		if(FloodProtectionTimer[playerid] != 0){
			FloodProtectionCounter[playerid]++;
			if(FloodProtectionCounter[playerid] > 2){
			    format(strings, sizeof(strings), "* Warning: Flood protection system activated for %d seconds.", FloodProtectionTimer[playerid]);
				SendClientMessage(playerid, COLOR_SYSTEM_PW, strings);
			}
		} else {
			FloodProtectionTimer[playerid]=10;
			FloodProtectionCounter[playerid]=1;
		}
	    return 1;
	}
	return 1;
}

public SetPlayerRandomSpawn(playerid)
{
	if (OwnSpawner[playerid] == 1) {
        tmps1 = dini_Get(udb_encode(playername), "x");
		tmps2 = dini_Get(udb_encode(playername), "y");
		tmps3 = dini_Get(udb_encode(playername), "z");
		SetPlayerPos(playerid, floatstr(tmps1), floatstr(tmps2), floatstr(tmps3));
	} else {
		if (iSpawnSet[playerid] == 1)
		{
			new rand = random(sizeof(gCopPlayerSpawns));
			SetPlayerPos(playerid, gCopPlayerSpawns[rand][0], gCopPlayerSpawns[rand][1], gCopPlayerSpawns[rand][2]); // Warp the player
			SetPlayerFacingAngle(playerid, 90.0);
	    }
	    else if (iSpawnSet[playerid] == 0)
	    {
			new rand = random(sizeof(gRandomPlayerSpawns));
			SetPlayerPos(playerid, gRandomPlayerSpawns[rand][0], gRandomPlayerSpawns[rand][1], gRandomPlayerSpawns[rand][2]); // Warp the player
			SetPlayerFacingAngle(playerid, 270.0);
		}
	}
	return 1;
}

public OnPlayerDeath(playerid, killerid, reason)
{
    new playercash;
	new killedplayer[MAX_PLAYER_NAME];
	new killername[MAX_PLAYER_NAME];
	new possiblecheaterid;
	new idx;
    new Float:X, Float:Y, Float:Z;
    new Float:P, Float:Q, Float:R;
	new Distance;
	
	Killed[playerid] = 1;

	// Resetting admindived-boolean in case the player was send to death by admin
	admindived[playerid] = 0;
	playercash = GetPlayerMoney(playerid);
	GetPlayerName(playerid, killedplayer, sizeof(killedplayer));

	if(deathmatcher1[playerid] == 1){
	    deathmatcher1[playerid] = 0;
	    ResetPlayerWeapons(playerid);
	    SetPlayerWorldBounds(playerid,5000.0000,-5000.0000,5000.0000,-5000.0000);
		playerseaglematch=playerseaglematch-1;
		DMplayer[playerid]=0;
		NoReset[playerid]=1;
	    return 1;
	}

	if(deathmatcher4[playerid] == 1){
	    deathmatcher4[playerid] = 0;
	    ResetPlayerWeapons(playerid);
	    SetPlayerWorldBounds(playerid,5000.0000,-5000.0000,5000.0000,-5000.0000);
		playerschainmatch=playerschainmatch-1;
		DMplayer[playerid]=0;
		NoReset[playerid]=1;
	    return 1;
	}

	if(deathmatcher5[playerid] == 1){
	    deathmatcher5[playerid] = 0;
	    ResetPlayerWeapons(playerid);
	    SetPlayerWorldBounds(playerid,5000.0000,-5000.0000,5000.0000,-5000.0000);
		playersminimatch=playersminimatch-1;
		DMplayer[playerid]=0;
		NoReset[playerid]=1;
	    return 1;
	}

	if(deathmatcher6[playerid] == 1){
	    deathmatcher6[playerid] = 0;
	    ResetPlayerWeapons(playerid);
	    SetPlayerWorldBounds(playerid,5000.0000,-5000.0000,5000.0000,-5000.0000);
		playersuzimatch=playersuzimatch-1;
		DMplayer[playerid]=0;
		NoReset[playerid]=1;
	    return 1;
	}

	// players receive a automatic bonus for killing

/*    for(new i=0; (i < MAX_PLAYERS) && (notprotectedplayers <= 1); i++) {
	    if(isprotected[i] == 0) {
			possiblecheaterid = i;
			notprotectedplayers++;
		}
  	}*/

//    if(!IsAdmin(killerid) && (killerid != INVALID_PLAYER_ID) && (isprotected[killerid] == 0)) {
      if(!IsAdmin(killerid) && (killerid != INVALID_PLAYER_ID)) {
		for (new i=0;i<47;i++) {
	        tmps1 = dini_Get(FILE_SETTINGS, "forbiddenweapons");
		    if (reason == strval(strtok(tmps1, idx, ',')) && reason != 0) {
		        if(IsPlayerInAnyVehicle(playerid)){
					KickMsg(killerid, -1, "Forbidden weapon detected!");
				} else {
		        	killerid = possiblecheaterid;
   	    			Distance = floatround(floatsqroot(floatpower(floatabs(floatsub(X250[playerid],X250[killerid])),2)+floatpower(floatabs(floatsub(Y250[playerid],Y250[killerid])),2)+floatpower(floatabs(floatsub(Z250[playerid],Z250[killerid])),2)));
					if(Distance < 80){
						KickMsg(killerid, -1, "Forbidden weapon detected!");
						NoReset[playerid]=1;
					} else {
						KickMsg(playerid, -1, "Forbidden weapon bancheat!");
					}
				}
			}
		}
	}
	if (killerid == INVALID_PLAYER_ID) {
        SendDeathMessage(INVALID_PLAYER_ID,playerid,reason);
//money		SetPlayerScore(playerid,GetPlayerScore(playerid)-1);
		if(moneyfterkill == 0) {
		    // TO-DO moneyscanner update
		    format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d suicided.", GetPlayerMoney(playerid), GetPlayerMoney(playerid), playerid);
		    StatGivePlayerMoney(playerid,-GetPlayerMoney(playerid), moneyreason);
		}
		Suicides[playerid]++;

		if (dini_Exists(udb_encode(killedplayer))) {
        	tmps1 = dini_Get(udb_encode(killedplayer), "suicides");
			dini_IntSet(udb_encode(killedplayer), "suicides", strval(tmps1)+1);
		}

	} else {
    	GetPlayerName(killerid, killername, sizeof(killername));

		// Check to see if player OR killer was in jail and was using weapons
		if((X250[playerid] >= 213.0 && X250[playerid] <= 231.0 && Y250[playerid] >= 108.0 && Y250[playerid] <= 114.0 && Z250[playerid] >= 995.0 ) ||
		   (X250[killerid] >= 213.0 && X250[killerid] <= 231.0 && Y250[killerid] >= 108.0 && Y250[killerid] <= 114.0 && Z250[killerid] >= 995.0)) {
		    // Check if it was not suicide
			if(killerid!=INVALID_PLAYER_ID) {
                // Check if reason was a weapon
				for(new i=0;i<47;i++) {
	    			if(reason == i && !IsAdmin(playerid)) {
						if (dini_Exists(udb_encode(killername)) && logged[i] == 1) {
						    dini_IntSet(udb_encode(killername), "jailed", 1);
							dini_IntSet(udb_encode(killername), "jailtime", 5);
						}
						SaveFile(killerid);
	    			    KickMsg(killerid, -1, "Killing a prisoner");
						NoReset[playerid]=1;
					}
				}
			}
			return 1;
		}

		//Check for range of players.
		Distance = floatround(floatsqroot(floatpower(floatabs(floatsub(X,P)),2)+floatpower(floatabs(floatsub(Y,Q)),2)+floatpower(floatabs(floatsub(Z,R)),2)));
		if(Distance > 70){
		    //Player was out of range, so no legitimate kill. Register kill as suicide.
		    format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d suicided.", GetPlayerMoney(playerid), GetPlayerMoney(playerid), playerid);
		    StatGivePlayerMoney(playerid,-GetPlayerMoney(playerid), moneyreason);
		    Suicides[playerid]++;

			if (dini_Exists(udb_encode(killedplayer))) {
   		     	tmps1 = dini_Get(udb_encode(killedplayer), "suicides");
				dini_IntSet(udb_encode(killedplayer), "suicides", strval(tmps1)+1);
				Suicides[playerid]++;
			}

			return 1;
		}

		// Check to see if player OR killer was on ship
		if((X250[playerid] >= 1995.5 && X250[playerid] <= 2006.0 && Y250[playerid] >= 1518.0 && Y250[playerid] <= 1569.0) ||
		   (X250[killerid] >= 1995.5 && X250[killerid] <= 2006.0 && Y250[killerid] >= 1518.0 && Y250[killerid] <= 1569.0)) {
		    // Check if it was not suicide
			if(killerid!=INVALID_PLAYER_ID) {
			    // Illegal kill, now jail killer!
				jailed[killerid] = 1;
			    dini_IntSet(udb_encode(killername), "jailed", 1);
       		    jailtime[killerid] = JAILTIME_ON_SHIP;
			    dini_IntSet(udb_encode(killername), "jailtime", JAILTIME_ON_SHIP);
				SetPlayerInterior(killerid,10);
				SetPlayerPos(killerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}
				SendDeathMessage(killerid,playerid,reason);
//money		        SetPlayerScore(killerid,GetPlayerScore(killerid)-1);
		        // TO-DO moneyscanner update
		        format(moneyreason, sizeof(moneyreason), "* Money decreased $%d (old: $%d), because player-id %d killed illegally.", GetPlayerMoney(killerid), GetPlayerMoney(killerid), killerid);
		        StatGivePlayerMoney(killerid, -GetPlayerMoney(killerid), moneyreason);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);
				if(Kills[killerid] > 0){
				    Kills[killerid] = 0;
				} else {
					Kills[killerid]--;
				}
				format(strings, sizeof(strings),"-- *Jailing player %s for %d minutes for killing %s on the pirateship.", killername, JAILTIME_ON_SHIP, killedplayer);
		        printf(strings);
				format(strings, sizeof(strings),"You are jailed for %d minutes for killing on or from the pirateship. There is no escape!", JAILTIME_ON_SHIP);
		        SendClientMessage(killerid, COLOR_SYSTEM_PW , strings);
				format(strings, sizeof(strings),"* Player %s (id:%d) is jailed for %d minutes for killing on or from the pirateship.", killername, killerid, JAILTIME_ON_SHIP, killedplayer);
				SendClientMessageToAll(COLOR_SYSTEM_GW , strings);
				NoReset[playerid]=1;
    		}

			if (dini_Exists(udb_encode(killedplayer))) {
	        	tmps1 = dini_Get(udb_encode(killedplayer), "suicides");
				dini_IntSet(udb_encode(killedplayer), "suicides", strval(tmps1)+1);
				Suicides[playerid]++;
			}

			return 1;
		}

		// Check to see if player OR killer was indoors
		if(Z250[playerid] >= 1000 || Z250[killerid] >= 1000) {
		    // Check if it was not suicide
			if(killerid!=INVALID_PLAYER_ID) {
			    // Illegal kill, now jail killer!
				jailed[killerid] = 1;
			    dini_IntSet(udb_encode(killername), "jailed", 1);
       		    jailtime[killerid] = JAILTIME_ON_SHIP;
			    dini_IntSet(udb_encode(killername), "jailtime", JAILTIME_ON_SHIP);

				SetPlayerInterior(killerid,10);
				SetPlayerPos(killerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
				if(jailcelcounter < 3) {
				    jailcelcounter++;
				} else {
				    jailcelcounter=0;
				}
				SendDeathMessage(killerid,playerid,reason);
//money		        SetPlayerScore(killerid,GetPlayerScore(killerid)-1);
		        // TO-DO moneyscanner update
				if(Kills[killerid] > 0){
				    Kills[killerid] = 0;
				} else {
					Kills[killerid]--;
				}
		        format(moneyreason, sizeof(moneyreason), "* Money decreased $%d (old: $%d), because player-id %d killed illegally.", GetPlayerMoney(killerid), GetPlayerMoney(killerid), killerid);
		        StatGivePlayerMoney(killerid, -GetPlayerMoney(killerid), moneyreason);
		        DisablePlayerCheckpoint(playerid);
				ResetPlayerWeapons(playerid);
				format(strings, sizeof(strings),"-- *Jailing player %s for %d minutes for killing %s indoors.", killername, JAILTIME_ON_SHIP, killedplayer);
		        printf(strings);
				format(strings, sizeof(strings),"You are jailed for %d minutes for killing indoors. There is no escape!", JAILTIME_ON_SHIP);
		        SendClientMessage(killerid, COLOR_SYSTEM_PW , strings);
				format(strings, sizeof(strings),"* Player %s (id:%d) is jailed for %d minutes for killing indoors.", killername, killerid, JAILTIME_ON_SHIP, killedplayer);
				SendClientMessageToAll(COLOR_SYSTEM_GW , strings);
				NoReset[playerid]=1;
    		}


			if (dini_Exists(udb_encode(killedplayer))) {
	        	tmps1 = dini_Get(udb_encode(killedplayer), "suicides");
				dini_IntSet(udb_encode(killedplayer), "suicides", strval(tmps1)+1);
				Suicides[playerid]++;
			}

			return 1;
		}

	    // Killer was not around ship or jail or indoors, so a legal kill
		if (dini_Exists(udb_encode(killername))) {
        	tmps1 = dini_Get(udb_encode(killername), "kills");
			dini_IntSet(udb_encode(killername), "kills", strval(tmps1)+1);
			Kills[killerid]++;
			Deaths[playerid]++;
		}

    	SendDeathMessage(killerid,playerid,reason);
//money		SetPlayerScore(killerid,GetPlayerScore(killerid)+1);
		if(bounty[playerid] > 0) {
			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d earned bounty-cash.", bounty[playerid], GetPlayerMoney(killerid), killerid);
			if(StatGivePlayerMoney(killerid, bounty[playerid], moneyreason)) {
				format(strings, sizeof(strings), "* You earned a bounty of $%d for killing %s (id: %d).", bounty[playerid], killedplayer, playerid);
				SendClientMessage(killerid, COLOR_MONEY_INC , strings);
				format(strings, sizeof(strings), "* %s (id: %d) earned a bounty of $%d for killing %s (id: %d).", killername, killerid, bounty[playerid], killedplayer, playerid);
				SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
				bounty[playerid] = 0;
			} else {
			    format(strings, sizeof(strings), "* You earned a bounty of $%d for killing %s (id: %d).", MAX_MONEY-GetPlayerMoney(killerid), killedplayer, playerid);
				SendClientMessage(killerid, COLOR_MONEY_INC , strings);
                format(strings, sizeof(strings), "* %s (id: %d) earned a bounty of $%d for killing %s (id: %d).", killername, killerid, MAX_MONEY-GetPlayerMoney(killerid), killedplayer, playerid);
				SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
				format(strings, sizeof(strings), "* The killer %s (id: %d) had too much money with him, so bounty is still $%d.", killername, killerid, bounty[playerid]-(MAX_MONEY-GetPlayerMoney(killerid)));
				SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
				bounty[playerid] = bounty[playerid]-(MAX_MONEY-GetPlayerMoney(killerid));
				StatGivePlayerMoney(killerid, bounty[playerid], moneyreason);
			}
		}

		if(playercash > 0) {
			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d killed a player and got his money.", playercash, GetPlayerMoney(killerid), killerid);
			StatGivePlayerMoney(killerid, playercash, moneyreason);
		}

	 	if (dini_Exists(udb_encode(killedplayer))) {
	       	tmps1 = dini_Get(udb_encode(killedplayer), "deaths");
			dini_IntSet(udb_encode(killedplayer), "deaths", strval(tmps1)+1);
		}

	   	if(playercash > 0) {
			// TO-DO money scanner update
			format(moneyreason, sizeof(moneyreason), "* Money decreased by $%d (old: $%d), because player-id %d was killed and lost money to the killer.", playercash, GetPlayerMoney(playerid), playerid);
			StatGivePlayerMoney(playerid, -playercash, moneyreason);
		}
	}

	return 1;
}

public OnPlayerEnterCheckpoint(playerid)
{
	new ownplayer[MAX_PLAYER_NAME];

	if(Pizza[playerid] == 1){
	    if(getCheckpointType(playerid) == PizzaNextCP[playerid]){
	        PizzaNextCheckpoint(playerid);
	    }
        return 1;
	}
	if(TaxiDriver[playerid] == 1){
	    if(getTaxiCheckpointType(playerid) == TaxiNextCP[playerid]){
	        TaxiNextCheckpoint(playerid);
	    }
        return 1;
	}
	if(motorracer[playerid] == 1 || sprintracer[playerid] == 1){
		if(deathmatcher18[playerid] == 1){
		    if(getRace1CheckpointType(playerid) == SprintRace3NextCP[playerid]){
		        SprintRace3NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher19[playerid] == 1){
		    if(getRace2CheckpointType(playerid) == SprintRace4NextCP[playerid]){
		        SprintRace4NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher20[playerid] == 1){
		    if(getRace3CheckpointType(playerid) == SprintRace5NextCP[playerid]){
		        SprintRace5NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher21[playerid] == 1){
		    if(getRace4CheckpointType(playerid) == SprintRace6NextCP[playerid]){
		        SprintRace6NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher22[playerid] == 1){
		    if(getRace5CheckpointType(playerid) == SprintRace7NextCP[playerid]){
		        SprintRace7NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher24[playerid] == 1){
		    if(getRace6CheckpointType(playerid) == MotorRace1NextCP[playerid]){
		        MotorRace1NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher25[playerid] == 1){
		    if(getRace7CheckpointType(playerid) == MotorRace2NextCP[playerid]){
		        MotorRace2NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher26[playerid] == 1){
		    if(getRace8CheckpointType(playerid) == MotorRace3NextCP[playerid]){
		        MotorRace3NextCheckpoint(playerid);
		    }
	        return 1;
		}
		if(deathmatcher27[playerid] == 1){
		    if(getRace9CheckpointType(playerid) == MotorRace4NextCP[playerid]){
		        MotorRace4NextCheckpoint(playerid);
		    }
	        return 1;
		}

		if(deathmatcher28[playerid] == 1){
		    if(getRace10CheckpointType(playerid) == MotorRace5NextCP[playerid]){
		        MotorRace5NextCheckpoint(playerid);
		    }
	        return 1;
		}
		return 1;
	}

	if(PlayerEnteredCheckpoint[playerid] > 0) return 1;
	
	if(IsAdmin(playerid) && getCheckpointType(playerid) == CP_ADMINTELEPORT){
	    SetPlayerFacingAngle(playerid, 90.0);
	    SetPlayerPos(playerid,298.1740,1972.8597,17.8406);
	    return 1;
	}
	
	switch (getCheckpointType(playerid)) {
		case CP_BANK: {
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You are at an ATM. To store money use '/bank amount', '/bankall' to store all your cash,");
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* to withdraw money use '/withdraw amount', and '/balance' to see your balance.");
		}
		case CP_SFBANK: {
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You are at an deposit ATM. To store money use '/bank amount', '/bankall' to store all your cash,");
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* to see your balance '/balance'.You cannot withdraw money at this ATM.");
		}
		case CP_AMMU: {
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You can purchase weapons here so that you have them every time you spawn.");
			SendClientMessage(playerid, COLOR_SYSTEM_PM , "* Type /bw(melee,pistol,shotgun,smg,rifle) and /weaplist for a list of weapons.");
		} 
		case CP_LSTOWN: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the Los Santos Town Hall, you will become mayor of Los Santos.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* As mayor you will receive 20% of all the income taxes.");
		}
		case CP_SFTOWN: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the San Fierro Town Hall, you will become mayor of San Fierro.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* As mayor you will receive 20% of all the income taxes.");
		}
		case CP_LVTOWN: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the Las Venturas Town Hall, you will become mayor of Las Venturas.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* As mayor you will receive 20% of all the income taxes.");
		}
		case CP_SAGOVERN: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the SA Governor Office, you will become governor of San Andreas.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* As governor you will receive 30% of all the income taxes.");
		}
		case CP_SHOOTING: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the shooting range, you will controll all the weapon transactions.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* You will receive 25% of all the spawn weapon purchases.");
		}
		case CP_TAXICOMP: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the SA Taxi Company, you will receive the taxi fees payed");
			SendClientMessage(playerid, COLOR_MESSAGE , "* by other players when they take the SA taxi.");
		}
		case CP_FORTCARSONPD:{
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the highway patrol head quaters, you can patrol the streets of.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* San Andreas and give speeders a ticket which they have to pay you.");
		}
		case CP_BANKADMIN: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* When buying the SA Administrative Bank Office, all the credit card buys will go");
			SendClientMessage(playerid, COLOR_MESSAGE , "* through your office. You will receive 25% of the commission payed.");
		}
		case CP_LIFTMECHIL: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* You can take the chair-lift to the top of mount Chilliad using the command /liftme .");
			SendClientMessage(playerid, COLOR_MESSAGE , "* This command is free of charge.");
		}
		case CP_LIFTMEGATE: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* You can take the chair-lift to the top of the Golden Gate Bridge using the command /liftme .");
			SendClientMessage(playerid, COLOR_MESSAGE , "* This command is free of charge.");
		}
		case CP_LUIGIS: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* You can make career in pizza delivery! Get a motor bike and type /pizza .");
			SendClientMessage(playerid, COLOR_MESSAGE , "* You will be payed for every pizza delivered on time. You'll have to remain within the timelimits to continue the career.");
		}
		case CP_BANKHACKING: {
        	if (BankHacker[playerid] == 0) {
				SendClientMessage(playerid, COLOR_MESSAGE , "* Here you can hack into the SA Bank computer, and hack a players bank account");
				SendClientMessage(playerid, COLOR_MESSAGE , "* to transfer an amount to your own bank account. Max transfer amount is $1.000.000.");
				SendClientMessage(playerid, COLOR_MESSAGE , "* Type /hackthebank [id] to start the hack - but be warned: you can end up in jail!");
				SendClientMessage(playerid, COLOR_MESSAGE , "* Type /hackthebankhelp for more information.");
				SendClientMessage(playerid, COLOR_RED , "* Chances of succes: 12,5 percent.");
			}
		}
		case CP_JAILBREAK: {
        	if (JailBreaker[playerid] == 0) {
				SendClientMessage(playerid, COLOR_MESSAGE , "* Here you can hack into the Dillmore PD computer to free all the prisoners.");
				SendClientMessage(playerid, COLOR_MESSAGE , "* Type /springbreak to start the hack - but be warned: you can end up in jail yourself!");
				SendClientMessage(playerid, COLOR_MESSAGE , "* Type /springbreakhelp for more information.");
				SendClientMessage(playerid, COLOR_RED , "* Chances of succes: 12,5 percent.");
			}
		}
		case CP_SPEEDO: {
			SendClientMessage(playerid, COLOR_MESSAGE , "* Welcome sir to the Black Market Carparts sales office.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* Currently I have the following part for sale:");
			SendClientMessage(playerid, COLOR_MESSAGE , "* Automatic cardoor lock for $2500000 , to be bought with /buyautolock");
			SendClientMessage(playerid, COLOR_MESSAGE , "* Emergency fuel can for $2000000 , to be bought with /buyfuelcan");
			SendClientMessage(playerid, COLOR_MESSAGE , "* I also except creditcards, use /creditautolock or /creditfuelcan. Don't forget the 30% extra cost when you use your creditcard.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* Don't forget the 30% extra cost when you use your creditcard.");
			SendClientMessage(playerid, COLOR_MESSAGE , "* You can sell the automatic cardoor lock for $500000 with /sellautolock");
			SendClientMessage(playerid, COLOR_MESSAGE , "* You can sell the emergency fuel can for $400000 with /sellfuelcan");
		}

	}

	if (getCheckpointType(playerid) >= P_OFFSET) {
		if(GoldPotActive == 1){
			if(getCheckpointType(playerid) == GoldPotChoice){
			    GoldPotWinner(playerid);
			    return 1;
		    }
		}
		if (getCheckpointType(playerid) >= 206 && getCheckpointType(playerid) <= 237) return 1;
	    new amount, temp1;
		if ((getCheckpointType(playerid) != CP_BANKHACKING) && (getCheckpointType(playerid) != CP_JAILBREAK) &&
			(getCheckpointType(playerid) != CP_SPEEDO) && (getCheckpointType(playerid) != CP_SFBANK) &&
			(getCheckpointType(playerid) != CP_BANK) && (getCheckpointType(playerid) != CP_LIFTMECHIL) &&
			(getCheckpointType(playerid) != CP_LIFTMEGATE) && (getCheckpointType(playerid) != CP_LUIGIS)){
			if (propertyOwner[playerCheckpoint[playerid]-P_OFFSET] < 999) {
				GetPlayerName(propertyOwner[playerCheckpoint[playerid]-P_OFFSET], ownplayer, sizeof(ownplayer));
				amount = propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET] + floatround(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET]*(float(BUYOUT_PERC)/100));
				if(propertyOwner[playerCheckpoint[playerid]-P_OFFSET] == playerid) {
					format(strings, sizeof(strings), "* You own the %s. The current value is $%d.", propertyNames[playerCheckpoint[playerid]-P_OFFSET], propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET]);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
					format(strings, sizeof(strings), "* The buy-out value is now $%d, %d percent higher than the current value.", amount, BUYOUT_PERC);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
//					format(strings, sizeof(strings), "* You own the %s. It's buy-out value is now $%d, which is %d percent higher than it's initial value.", propertyNames[playerCheckpoint[playerid]-P_OFFSET], amount, BUYOUT_PERC);
//					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
					if(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET] == 6000000) {
					    temp1 = 0;
					} else {
						temp1=floatround(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET]*0.015);
					}
					format(strings, sizeof(strings), "* The next property value increase will approx be $%d.", temp1);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
				} else {
					format(strings, sizeof(strings), "* This property is currently owned by %s.", ownplayer);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
					format(strings, sizeof(strings), "* You can buy out the %s for $%d with /buy. You have to pay %d percent more, because you buy it out.", propertyNames[playerCheckpoint[playerid]-P_OFFSET], amount, BUYOUT_PERC);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
					if(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET] == 6000000) {
					    temp1 = 0;
					} else {
						temp1=floatround(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET]*0.015);
					}
					format(strings, sizeof(strings), "* The property value increase is around $%d each minute.", temp1);
					SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
				}
			} else {
				format(strings, sizeof(strings), "* You can buy the %s for $%d with /buy.", propertyNames[playerCheckpoint[playerid]-P_OFFSET], propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET]);
				SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
				if(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET] == 6000000) {
				    temp1 = 0;
				} else {
					temp1=floatround(propertyCurrentValue[playerCheckpoint[playerid]-P_OFFSET]*0.015);
				}
				format(strings, sizeof(strings), "* The property value increase is around $%d each minute.", temp1);
				SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
			}
			if (getCheckpointType(playerid) == CP_LVSOURV) {
				SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You can also buy here gifts with the command /bwgift.");
				SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Issue the command /giftlist to see the various gifts you can buy.");
				SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Note that you can only buy one gift at a time, a new one will override the old one.");
			}
		}
	}
	PlayerEnteredCheckpoint[playerid] = 2;
	return 1;
}

public OnPlayerRequestClass(playerid, classid)
{
//	if(classid == 0 || classid == 1 || classid == 2 || classid == 3 || classid == 4 || classid == 5 || classid == 6)
//	{
//		iSpawnSet[playerid] = 1;
//	}
//	else
//	{
		iSpawnSet[playerid] = 0;
//	}
	SetupPlayerForClassSelection(playerid);
	return 1;
}

public SetupPlayerForClassSelection(playerid)
{
 	SetPlayerInterior(playerid,14);
	SetPlayerPos(playerid,258.4893,-41.8008,1002.0234);
	SetPlayerFacingAngle(playerid, 270.0);
	SetPlayerCameraPos(playerid,256.0815,-40.0475,1004.0234);
	SetPlayerCameraLookAt(playerid,258.4893,-41.8008,1002.0234);
}

public GameModeExitFunc()
{
 	GameModeExit();
}

public OnGameModeInit()
{
	new temp, Hour, Minute, Seconds;

	format(ScriptVersion, sizeof(ScriptVersion), "3.4.0");
	format(strings, sizeof(strings), "Nitro's Freeroam v%s", ScriptVersion);
	SetGameModeText(strings);
	gettime(Hour, Minute, Seconds);
	if(Hour < 10) {
	    format(SystemTime, sizeof(SystemTime), "0%d",Hour);
	} else {
	    format(SystemTime, sizeof(SystemTime), "%d",Hour);
	}
	if(Minute < 10) {
	    format(SystemTime, sizeof(SystemTime), "%s:0%d",SystemTime,Minute);
	} else {
	    format(SystemTime, sizeof(SystemTime), "%s:%d",SystemTime,Minute);
	}
	format(strings, sizeof(strings), "System time: %s", SystemTime);
	printf(strings);

	ShowPlayerMarkers(1);
	ShowNameTags(1);

	AddPlayerClass(280,1958.3783,1343.1572,15.3746,270.1425,0,0,24,300,-1,-1);
	AddPlayerClass(281,1958.3783,1343.1572,15.3746,270.1425,0,0,24,300,-1,-1);
	AddPlayerClass(282,1958.3783,1343.1572,15.3746,270.1425,0,0,24,300,-1,-1);
	AddPlayerClass(283,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(284,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(285,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);

	AddPlayerClass(1,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(2,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(7,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(9,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(10,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(11,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(12,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(13,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(14,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(15,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(16,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(17,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(18,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(19,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(20,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(21,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(22,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(23,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(24,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(25,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(26,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(27,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(28,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(29,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(30,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(31,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(32,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(33,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(34,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(35,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(36,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(37,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(38,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(39,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(40,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(41,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(43,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(44,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(45,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(47,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(48,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(49,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(50,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(51,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(52,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(53,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(54,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(55,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(56,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(57,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(58,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(59,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(60,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(61,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(62,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(63,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(64,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(66,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(67,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(68,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(69,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(70,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(71,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(72,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(73,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(75,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(76,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(77,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(78,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(79,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(80,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(81,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(82,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(83,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(84,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(85,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(87,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(88,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(89,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(90,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(91,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(92,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(93,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(94,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(95,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(96,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(97,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(98,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(99,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(100,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(101,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(102,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(103,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(104,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(105,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(106,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(107,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(108,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(109,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(110,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(111,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(112,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(113,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(114,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(115,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(116,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(117,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(118,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(120,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(121,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(122,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(123,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(124,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(125,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(126,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(127,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(128,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(129,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(130,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(131,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(132,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(133,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(134,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(135,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(136,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(137,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(138,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(139,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(140,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(141,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(142,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(143,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(144,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(145,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(146,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(147,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(148,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(150,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(151,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(152,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(153,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(154,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(155,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(156,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(157,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(158,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(159,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(160,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(161,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(162,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(163,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(164,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(165,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(166,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(167,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(168,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(169,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(170,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(171,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(172,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(173,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(174,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(175,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(176,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(177,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(178,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(179,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(180,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(181,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(182,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(183,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(184,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(185,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(186,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(187,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(188,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(189,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(190,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(191,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(192,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(193,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(194,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(195,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(196,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(197,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(198,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(199,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(200,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(201,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(202,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(203,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(204,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(205,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(206,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(207,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(209,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(210,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(211,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(212,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(213,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(214,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(215,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(216,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(217,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(218,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(219,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(220,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(221,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(222,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(223,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(224,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(225,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(226,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(227,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(228,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(229,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(230,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(231,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(232,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(233,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(234,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(235,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(236,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(237,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(238,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(239,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(240,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(241,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(242,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(243,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(244,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(245,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(246,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(247,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(248,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(249,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(250,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(251,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(253,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(254,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(255,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(256,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(257,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(258,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(259,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(260,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(261,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(262,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(263,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(264,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(274,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(275,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(276,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(277,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(278,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(279,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(286,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(287,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(288,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(290,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(291,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(292,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(293,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(294,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(295,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(296,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(297,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(298,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);
	AddPlayerClass(299,1958.3783,1343.1572,15.3746,269.1425,0,0,24,300,-1,-1);

	new VehicleTemp;
	MotorID[MotorIDCounter] = MotorIDTemp1[random(sizeof(MotorIDTemp1))]; //First element filled
	for (new i=0; i< sizeof(MotorIDTemp1); i++){
	   if (MotorIDTemp1[i] != MotorID[MotorIDCounter]){
	      MotorIDTemp2[VehicleTemp]=MotorIDTemp1[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	MotorIDCounter++;
	MotorID[MotorIDCounter] = MotorIDTemp2[random(sizeof(MotorIDTemp2))]; //Second element filled
	for (new i=0; i< sizeof(MotorIDTemp2); i++){
	   if (MotorIDTemp2[i] != MotorID[MotorIDCounter]){
	      MotorIDTemp3[VehicleTemp]=MotorIDTemp2[i];
	      VehicleTemp++;
	   }
	}
	MotorIDCounter++;
	MotorID[MotorIDCounter] = 522; //Third element filled

	VehicleTemp=0;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp1[random(sizeof(NormalCarIDTemp1))]; //First element filled
	for (new i=0; i< sizeof(NormalCarIDTemp1); i++){
	   if (NormalCarIDTemp1[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp2[VehicleTemp]=NormalCarIDTemp1[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp2[random(sizeof(NormalCarIDTemp2))]; //Second element filled
	for (new i=0; i< sizeof(NormalCarIDTemp2); i++){
	   if (NormalCarIDTemp2[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp3[VehicleTemp]=NormalCarIDTemp2[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp3[random(sizeof(NormalCarIDTemp3))]; //Third element filled
	for (new i=0; i< sizeof(NormalCarIDTemp3); i++){
	   if (NormalCarIDTemp3[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp4[VehicleTemp]=NormalCarIDTemp3[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp4[random(sizeof(NormalCarIDTemp4))]; //Fourth element filled
	for (new i=0; i< sizeof(NormalCarIDTemp4); i++){
	   if (NormalCarIDTemp4[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp5[VehicleTemp]=NormalCarIDTemp4[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp5[random(sizeof(NormalCarIDTemp5))]; //Fifth element filled
	for (new i=0; i< sizeof(NormalCarIDTemp5); i++){
	   if (NormalCarIDTemp5[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp6[VehicleTemp]=NormalCarIDTemp5[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp6[random(sizeof(NormalCarIDTemp6))]; //Sixth element filled
	for (new i=0; i< sizeof(NormalCarIDTemp6); i++){
	   if (NormalCarIDTemp6[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp7[VehicleTemp]=NormalCarIDTemp6[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp7[random(sizeof(NormalCarIDTemp7))]; //Seventh element filled
	for (new i=0; i< sizeof(NormalCarIDTemp7); i++){
	   if (NormalCarIDTemp7[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp8[VehicleTemp]=NormalCarIDTemp7[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp8[random(sizeof(NormalCarIDTemp8))]; //Eight element filled
	for (new i=0; i< sizeof(NormalCarIDTemp8); i++){
	   if (NormalCarIDTemp8[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp9[VehicleTemp]=NormalCarIDTemp8[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp9[random(sizeof(NormalCarIDTemp9))]; //Nineth element filled
	for (new i=0; i< sizeof(NormalCarIDTemp9); i++){
	   if (NormalCarIDTemp9[i] != NormalCarID[NormalCarIDCounter]){
	      NormalCarIDTemp10[VehicleTemp]=NormalCarIDTemp9[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	NormalCarIDCounter++;
	NormalCarID[NormalCarIDCounter] = NormalCarIDTemp10[random(sizeof(NormalCarIDTemp9))]; //Tenth element filled

	VehicleTemp=0;
	PerformanceCarID[PerformanceCarIDCounter] = PerformanceCarIDTemp1[random(sizeof(PerformanceCarIDTemp1))]; //First element filled
	for (new i=0; i< sizeof(PerformanceCarIDTemp1); i++){
	   if (PerformanceCarIDTemp1[i] != PerformanceCarID[PerformanceCarIDCounter]){
	      PerformanceCarIDTemp2[VehicleTemp]=PerformanceCarIDTemp1[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	PerformanceCarIDCounter++;
	PerformanceCarID[PerformanceCarIDCounter] = PerformanceCarIDTemp2[random(sizeof(PerformanceCarIDTemp2))]; //Second element filled
	for (new i=0; i< sizeof(PerformanceCarIDTemp2); i++){
	   if (PerformanceCarIDTemp2[i] != PerformanceCarID[PerformanceCarIDCounter]){
	      PerformanceCarIDTemp3[VehicleTemp]=PerformanceCarIDTemp2[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	PerformanceCarIDCounter++;
	PerformanceCarID[PerformanceCarIDCounter] = PerformanceCarIDTemp3[random(sizeof(PerformanceCarIDTemp3))]; //Third element filled
	for (new i=0; i< sizeof(PerformanceCarIDTemp3); i++){
	   if (PerformanceCarIDTemp3[i] != PerformanceCarID[PerformanceCarIDCounter]){
	      PerformanceCarIDTemp4[VehicleTemp]=PerformanceCarIDTemp3[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	PerformanceCarIDCounter++;
	PerformanceCarID[PerformanceCarIDCounter] = PerformanceCarIDTemp4[random(sizeof(PerformanceCarIDTemp4))]; //Fourth element filled
	for (new i=0; i< sizeof(PerformanceCarIDTemp4); i++){
	   if (PerformanceCarIDTemp4[i] != PerformanceCarID[PerformanceCarIDCounter]){
	      PerformanceCarIDTemp5[VehicleTemp]=PerformanceCarIDTemp4[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	PerformanceCarIDCounter++;
	PerformanceCarID[PerformanceCarIDCounter] = PerformanceCarIDTemp5[random(sizeof(PerformanceCarIDTemp5))]; //Fifth element filled
	for (new i=0; i< sizeof(PerformanceCarIDTemp5); i++){
	   if (PerformanceCarIDTemp5[i] != PerformanceCarID[PerformanceCarIDCounter]){
	      PerformanceCarIDTemp6[VehicleTemp]=PerformanceCarIDTemp5[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	PerformanceCarIDCounter++;
	PerformanceCarID[PerformanceCarIDCounter] = PerformanceCarIDTemp6[random(sizeof(PerformanceCarIDTemp6))]; //Fifth element filled
	
	VehicleTemp=0;
	HelicopterID[HelicopterIDCounter] = HelicopterIDTemp1[random(sizeof(HelicopterIDTemp1))]; //First element filled
	for (new i=0; i< sizeof(HelicopterIDTemp1); i++){
	   if (HelicopterIDTemp1[i] != HelicopterID[HelicopterIDCounter]){
	      HelicopterIDTemp2[VehicleTemp]=HelicopterIDTemp1[i];
	      VehicleTemp++;
	   }
	}
	VehicleTemp=0;
	HelicopterIDCounter++;
	HelicopterID[HelicopterIDCounter] = HelicopterIDTemp2[random(sizeof(HelicopterIDTemp2))]; //Second element filled
	
	temp=StreetRacerIDTemp1[random(sizeof(StreetRacerIDTemp1))];
	VehicleTemp=0;
	for(new i=0; i< sizeof(StreetRacerIDTemp1); i++){
		if(StreetRacerIDTemp1[i] != temp){
	        StreetRacerID[VehicleTemp]=StreetRacerIDTemp1[i];
			VehicleTemp++;
	   }
	}

	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1533.2056,2637.1172,55.5053,70.6050,random(127),random(127),120); // Sanchez @ ElQ
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1920.1937,-1414.6672,13.2388,39.0221,random(127),random(127),120); // Sanchez @ LS skate park
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1985.3895,301.1591,34.8396,88.9331,random(127),random(127),120); // Sanchez 1 @ Wang
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1987.0215,306.2203,34.8437,89.8085,random(127),random(127),120); // Sanchez 2 @ Wang
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2038.7366,1535.8801,10.3410,269.3097,random(127),random(127),120); // Sanchez @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2407.2617,-2184.3149,32.9581,279.7284,random(127),random(127),120); // Sanchez 1 @ base Chilliad
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2407.3423,-2177.7920,32.9582,291.4984,random(127),random(127),120); // Sanchez 2 @ base Chilliad
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],244.6527,-88.1256,1.5457,89.3545,random(127),random(127),120); // sanchez @ blueberry
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2864.6658,-1936.7883,10.7787,37.6392,random(127),random(127),120); // Sanchez @ LS Beach
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-571.3633,-1046.8544,23.5403,235.0852,random(127),random(127),120); // Sanchez@Hunting
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],61.1632,1186.3755,18.5426,336.1639,random(127),random(127),120); // Sanchez 2 @ Bone County
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],65.6089,1186.2059,18.5111,333.8409,random(127),random(127),120); // Sanchez 1 @ Bone County
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1282.2803,2548.6499,10.3891,276.0906,random(127),random(127),120); // FCR 2 @ prickle pine
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1434.7136,2578.1890,10.3948,356.9582,random(127),random(127),120); // FCR 1 @ prickle pine
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1952.8357,294.1922,40.6166,128.9938,random(127),random(127),120); // FCR @ Wang
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2038.9188,1525.0896,10.2422,211.6971,random(127),random(127),120); // FCR 3 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2039.1122,1528.2201,10.2371,215.6279,random(127),random(127),120); // FCR 2 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2039.2969,1531.2208,10.2378,222.3863,random(127),random(127),120); // FCR 1 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2473.5723,2223.5833,4.4141,360.0000,random(127),random(127),120); // FCR @ Bayside
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2496.9685,-1685.8113,13.0023,37.8544,random(127),random(127),120); // FCR @ Grove
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2503.7893,1410.0179,10.3938,88.5423,random(127),random(127),120); // FCR @ Pilgrim
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2671.0405,-2017.5475,13.1266,303.9031,random(127),random(127),120); // FCR @ Lowtuner
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2713.0305,92.4148,3.9010,302.3265,random(127),random(127),120); // FCR @ Archangels
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2766.4370,-282.3144,6.6190,180.2547,random(127),random(127),120); // FCR @ Aspiva
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],363.2322,-2035.0131,7.4088,318.4363,random(127),random(127),120); // FCR @ Sandra
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],692.3276,-491.6766,15.9074,38.2895,random(127),random(127),120); // FCR @ Dillmore
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1026.3271,-1341.0560,13.2907,357.2072,random(127),random(127),120); // NRG @ Donut shop LS
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1235.6003,2609.5479,10.3925,270.8508,random(127),random(127),120); // NRG @ Prickle pine
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1254.5698,-805.2453,83.7114,176.6568,random(127),random(127),120); // NRG @ madd doggs
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1354.3387,240.9132,19.1444,66.4817,random(127),random(127),120); // NRG @ Palimono creek
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1358.9783,-1749.0267,12.9459,90.3639,random(127),random(127),120); // NRG @ LS Bank
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1396.9597,2252.8416,10.3901,271.6272,random(127),random(127),120); // NRG @ LVStadium
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1399.7550,2628.7214,55.3451,91.0775,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // NRG @ ElQ
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1611.2401,651.9069,6.7582,358.5609,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // NRG 2 @ SFPD
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1612.5304,675.0848,6.7523,178.8093,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // NRG 1 @ SFPD
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],183.0717,1925.4849,17.4395,186.4516,random(127),random(127),120); // NRG @ hideout
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],186.7987,1925.1072,17.3036,179.1637,random(127),random(127),120); // NRG 2 @ hideout
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1917.7748,-1415.4630,13.1376,45.5881,random(127),random(127),120); // NRG1 @ LS Skate park
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],1923.4008,-1414.4353,13.1411,47.8829,random(127),random(127),120); // NRG 2 @ LS Skate park
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-1953.0289,297.0631,40.6141,126.3386,random(127),random(127),120); // NRG @ Wang
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2023.7996,1334.6101,10.0343,269.8774,random(127),random(127),120); // NRG 1 @ strip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2025.6573,1351.2919,10.2239,269.2859,random(127),random(127),120); // NRG 2 @ strip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2038.8306,1547.0320,10.2397,315.6745,random(127),random(127),120); // NRG 4 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2038.8995,1542.4043,10.2430,315.3175,random(127),random(127),120); // NRG 2 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2038.9180,1544.8787,10.2352,314.3848,random(127),random(127),120); // NRG 3 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2039.0743,1539.9908,10.2442,315.5362,random(127),random(127),120); // NRG 1 @ Schip
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2080.0693,-2454.4253,30.1958,99.3033,random(127),random(127),120); // NRG @ Angel
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2269.2727,2459.4373,10.3841,359.5104,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // NRG 2 @ LVPD
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2282.3711,2476.9392,10.3910,183.1333,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // NRG 1 @ LVPD
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2353.9155,-1614.6692,483.2152,270.8701,random(127),random(127),120); // NRG 1 @ Top Chilliad
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2354.3506,-1618.0052,483.2209,266.3775,random(127),random(127),120); // NRG 2 @ Top Chilliad
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2360.6243,576.0908,24.4614,141.5990,random(127),random(127),120); // NRG @ Mint
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2467.6750,2224.2979,4.4150,359.9271,random(127),random(127),120); // NRG @ Bayside
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2491.6309,-1685.4508,13.0840,37.0902,random(127),random(127),120); // NRG @ Grove
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2547.6160,197.6915,12.6098,110.2342,random(127),random(127),120); // NRG 2 @ Archangels
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-2713.5916,95.7752,3.9076,298.0560,random(127),random(127),120); // NRG @ Archangels
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],2864.8396,-1940.3760,10.6801,27.0070,random(127),random(127),120); // NRG @ LS Beach
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-423.7122,2237.0413,41.9924,166.3248,random(127),random(127),120); // NRG @ Ghost town
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],657.1005,1718.6760,6.5701,41.4289,random(127),random(127),120); // NRG @ Bone county
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],673.8873,-478.6231,15.9070,207.2630,random(127),random(127),120); // NRG @ Dillmore
	AddStaticVehicleEx2(MotorID[random(sizeof(MotorID))],-74.3304,-1152.7595,1.3224,151.6484,random(127),random(127),120); // NRG @ Flint

	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2034.6055,1919.5320,11.9774,179.9689,random(127),random(127),120); // limo @ Visage
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2039.6914,1008.0771,10.4718,179.3797,random(127),random(127),120); // Limo @ 4 dragons
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2125.7329,2356.8174,10.4719,90.1836,random(127),random(127),120); // limo @ emerald isle
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2159.9075,1681.6281,10.4914,1.1902,random(127),random(127),120); // limo @ caligula
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2172.3906,1121.2025,12.3623,333.0903,random(127),random(127),120); // limo @ Come-a-lot
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2231.0029,1286.5916,10.4719,0.0914,random(127),random(127),120); // limo @ camel toe
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2039.4617,1555.9868,10.3990,2.4595,random(127),random(127),120); // Cabby @ Spinybed
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2190.4900,2787.0776,10.8232,181.7488,random(127),random(127),120); // Cabby @ Spinybed
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-1503.8317,2525.2451,55.8085,1.9370,random(127),random(127),120); // Burito @ ElQ
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-1988.7688,275.2863,35.3029,267.0629,random(127),random(127),120); // Burito @ Wang
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2060.0381,-1694.3223,13.6740,271.1284,random(127),random(127),120); // Burrito @ Grove
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2368.4624,2752.0244,10.9373,179.8092,random(127),random(127),120); // burrito @ spinybed
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2489.6865,1408.6407,10.9408,178.9917,random(127),random(127),120); // Burrito @ pilgrim
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-2613.6755,171.2370,4.4417,181.7263,random(127),random(127),120); // Burrito @ Archangels
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],196.8203,-217.1697,1.1715,270.1252,random(127),random(127),120); // Buccaneer @ Blueberry
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-2025.8600,178.8313,28.4996,271.3418,random(127),random(127),120); // Buccaneer @ Doherty
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2498.7876,-1651.5120,13.1859,169.7736,random(127),random(127),120); // Buccaneer LS
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2134.2141,-1146.5146,24.3403,50.6171,random(127),random(127),120); // remmington 1 LS
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2208.0496,1378.7767,10.4686,88.9865,random(127),random(127),120); // Remmington @ Camel toe
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2650.6438,1084.4218,10.5461,179.9306,random(127),random(127),120); // Remmington @ LV
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2772.7256,-1875.9075,9.4891,0.6532,random(127),random(127),120); // Remmington 2 @ LS arena
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2787.6309,-1875.7819,9.5532,358.5123,random(127),random(127),120); // remmington @ LS arena
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-579.9250,-1063.2717,23.2100,237.1773,random(127),random(127),120); // Remmington@Hunting
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-1605.9363,673.2403,6.9248,180.9365,0,0,120); // Blade @ SFPD
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2127.0483,-1147.4222,24.2097,2.8614,random(127),random(127),120); // Blade 1 LS
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2684.6780,-1991.2439,13.2916,179.2904,random(127),random(127),120); // Blade 2 LS
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],278.4887,1956.0847,17.7688,270.0,random(127),random(127),120); // Huntley @ hideout
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-2177.9902,-2369.7473,30.5524,144.3380,0,0,120); // Huntley @ Angel Pine PD
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2277.1716,2418.3035,10.6792,90.5347,random(127),random(127),120); // Huntley @ LV
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-2378.7922,584.7091,25.6354,2.6150,random(127),random(127),120); // Huntley @ Mint
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],1536.1589,-1665.7711,13.1077,0.9095,0,0,120); // Euros @ LS PD
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-1563.1855,2695.5750,55.5046,177.4416,random(127),random(127),120); // Euros @ ElQ
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-1655.6736,1213.7776,13.4004,342.1390,random(127),random(127),120); // Euros @ Otto
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2345.9473,2737.9866,10.5471,268.6116,random(127),random(127),120); // Euros 1 @ LV
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2476.7688,1428.6506,10.5474,180.3816,random(127),random(127),120); // Euros @ pilgrim
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],-1400.7781,2640.9111,55.4354,91.0812,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // LVPD Car @ ElQ
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],2278.1292,2441.9548,10.5669,1.6619,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // LVPD car @ LVPD
	AddStaticVehicleEx2(490,-210.3319,997.5739,19.8056,89.0349,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // Pol Ranger @ Bone County
	AddStaticVehicleEx2(NormalCarID[random(sizeof(NormalCarID))],612.2429,-601.5456,14.4160,271.5998,CopColor[random(sizeof(CopColor))],CopColor[random(sizeof(CopColor))],120); // PolRanger @ Dillmore

	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1249.0948,-805.8683,83.8677,179.5709,random(127),random(127),120); // Infernus @ madd doggs
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1536.1782,-1678.9762,13.1099,0.5915,0,0,120); // Infernus @ LS PD
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-1663.6481,1210.7828,6.9794,293.1284,random(127),random(127),120); // Infernus @ Otto
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],278.4887,1990.2053,17.7684,270.0,random(127),random(127),120); // infernus @ hideout
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2126.3748,1409.2700,10.5472,180.0050,random(127),random(127),120); // Infernus @ Autobahn
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2474.1328,-1690.7894,13.2412,358.7236,random(127),random(127),120); // Infernus LS
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2494.1250,1233.3997,10.5474,92.3207,random(127),random(127),120); // Infernus @ Pilgrim
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2726.4653,-314.0161,6.8380,316.1367,random(127),random(127),120); // Infernus @ Aspiva
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1316.1147,1279.0482,10.5908,0.3836,random(127),random(127),120); // Cheetah @ LV AP
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-1664.5752,1215.8169,7.0229,282.6185,random(127),random(127),120); // Cheeah @ Otto's
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2132.7312,1397.8306,10.5908,359.5439,random(127),random(127),120); // Cheetah @ Autobahn
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],367.9289,-2044.3730,7.4423,0.7485,random(127),random(127),120); // Cheetah @ Sandra
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1616.6614,-1132.6152,23.5859,271.8268,random(127),random(127),120); // Banshee @ LS Betting shop
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1648.3976,-1135.5791,23.5859,359.3362,random(127),random(127),120); // Banshee 2 @ LS Betting shop
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-1661.4432,1220.1201,13.3515,283.4893,random(127),random(127),120); // banshee @ otto
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1668.3342,999.3648,10.5000,180.5362,random(127),random(127),120); // Banshee @ Freight
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2116.7507,1408.4044,10.4961,180.1416,random(127),random(127),120); // Banshee @ Autobahn
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2134.4670,930.5459,79.6011,359.7708,random(127),random(127),120); // Banshee @ Carlton Heights
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2215.5613,-2404.6665,30.9266,232.5234,random(127),random(127),120); // Banshee @ Angel
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],647.9622,1704.7045,6.6719,131.0057,random(127),random(127),120); // Banshee @ Bone county
	temp=random(sizeof(MonsterID));
	AddStaticVehicleEx2(MonsterID[temp],1563.8162,1186.2534,11.1733,1.6919,random(127),random(127),120); // monster 4
	AddStaticVehicleEx2(MonsterID[temp],1571.3923,1186.0095,11.1733,359.2306,random(127),random(127),120); // monster 3
	if(MonsterID[temp] == 571){
		AddStaticVehicleEx2(MonsterID[temp],1579.5134,1194.6006,11.1838,1.7425,random(127),random(127),120); // monster 6
	} else {
		AddStaticVehicleEx2(MonsterID[temp],278.1295,1951.1654,18.0156,270.0,random(127),random(127),120); // monster 6
	}
	AddStaticVehicleEx2(MonsterID[temp],1579.7565,1185.7780,11.1636,2.4232,random(127),random(127),120); // monster 2
	AddStaticVehicleEx2(MonsterID[temp],1589.7521,1185.7769,11.1838,3.7928,random(127),random(127),120); // monster 1
	AddStaticVehicleEx2(MonsterID[temp],1599.2617,1185.7991,11.1821,1.8203,random(127),random(127),120); // monster 5
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1034.4006,-1330.9377,13.0935,270.1039,random(127),random(127),120); // Turismo @ Donut shop LS
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1531.0492,2214.0872,10.5258,1.6910,random(127),random(127),120); // Turismo @ LV Stadium
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-1657.0857,1213.8079,6.9563,333.2134,random(127),random(127),120); // Turismo @ Otto
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1677.7954,988.8461,10.5270,359.7264,random(127),random(127),120); // Turismo @ Freight
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1742.9058,-1852.8525,13.1205,269.6866,random(127),random(127),120); // Turismo @ Unity Station
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2123.2234,1398.4077,10.5495,0.4960,random(127),random(127),120); // Turismo @ Autobahn
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],214.4668,-77.1353,1.2112,268.9913,random(127),random(127),120); // Turismo @ Blueberry
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2200.0630,-2261.7551,30.3417,140.8351,random(127),random(127),120); // Turismo @ Angel
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-237.8241,2595.5359,62.4100,358.5428,random(127),random(127),120); // Turismo @ Las Paya
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2568.0879,1147.4469,55.4332,157.8778,random(127),random(127),120); // Turismo @ Paradiso
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1613.4060,2203.5298,10.4453,89.9308,random(127),random(127),120); // Bullet @ redsands
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-1649.6761,1207.1116,13.2984,241.2523,random(127),random(127),120); // Bullet @ Otto
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2157.6726,-2394.6985,30.1693,53.6314,0,0,120); // Bullet@Angel pine
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2167.4641,2754.5352,10.4453,89.5337,random(127),random(127),120); // Bullet @ spinyebed
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2246.9897,2034.7515,10.4453,268.8900,random(127),random(127),120); // Bullet @ Strip
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2494.2866,1215.9723,10.4454,91.2244,random(127),random(127),120); // Bullet @ Pilgrim
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],426.3685,-1483.9740,30.2147,310.0384,random(127),random(127),120); // Bullet @ Didier sach
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1235.0172,2592.3040,10.5044,271.0543,random(127),random(127),120); // windsor @ prickle pine
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-1560.6357,2648.0405,55.4220,268.0768,random(127),random(127),120); // Windsor @ ElQ
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1743.0385,-1857.8567,13.0987,271.3056,random(127),random(127),120); // Windsor @ Unity station
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],1841.5848,-1339.5236,13.1530,180.8838,random(127),random(127),120); // Windsor @ LS Skate park
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2253.7324,2518.6660,10.4242,90.8860,random(127),random(127),120); // Windsor @ LV
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2362.4092,96.9266,26.1542,89.6260,random(127),random(127),120); // Windsor @ Montgomery
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2425.9282,518.4675,29.6136,221.0211,random(127),random(127),120); // Windson @ Mint
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2427.0972,2345.9968,4.6599,189.0950,random(127),random(127),120); // Windsor @ Bayside
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2645.7986,1084.3649,10.5044,180.5726,random(127),random(127),120); // Windsor @ LV
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],-2756.6038,-281.1241,6.7235,179.8609,random(127),random(127),120); // windsor @ Aspiva
	AddStaticVehicleEx2(PerformanceCarID[random(sizeof(PerformanceCarID))],2807.8655,2153.0925,10.5039,296.0722,random(127),random(127),120); // Windsor @ creek

	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1227.9393,220.7979,19.3091,334.8094,random(127),random(127),120); // Buffalo @ Montgomery
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1992.3059,2737.0598,10.5749,269.3514,random(127),random(127),120); // Buffalo @ prickle pine
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-2694.1226,98.6517,4.1684,90.3665,random(127),random(127),120); // Buffalo @ Archangels
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1543.9619,16.2290,24.1325,280.4654,random(127),random(127),120); // patriot @ badlands
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2762.7517,-2385.4958,13.6275,179.5539,random(127),random(127),120); // Patriot LS
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2821.8240,2161.7153,10.8135,270.0376,random(127),random(127),120); // Patriot @ LV
	AddStaticVehicleEx2(490,278.4887,2023.5828,17.7687,270.0,random(2),random(2),120); // FBI ranger @ hideout
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1040.4819,1559.7814,33.7171,220.3987,random(127),random(127),120); // Sand kind @ Ronnies
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-361.8922,2235.1990,42.7620,105.1122,random(127),random(127),120); // Sand king @ Ghost town
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-681.7924,947.7386,12.4713,49.0360,random(127),random(127),120); // Sand king @ CIA hideout
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2118.3586,-1145.8730,24.3349,310.6029,random(127),random(127),120); // Slamvan 1 LS
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2684.8809,-2017.0142,13.3116,358.8375,random(127),random(127),120); // Slamvan 2 LS
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1614.8352,2744.5300,10.5843,182.3217,random(127),random(127),120); // Slamvan @ Prickle pine
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-201.0533,1136.8408,19.4286,180.6459,random(127),random(127),120); // Slamvan @ Bone County
	AddStaticVehicleEx2(539,838.8438,-2061.7051,12.2273,357.5047,random(127),random(127),120); // Vortex LS
	AddStaticVehicleEx2(539,-915.4460,2706.7656,41.7272,188.0342,random(127),random(127),120); // Vortex 1 @ Killerfist
	AddStaticVehicleEx2(539,-918.9246,2706.3591,41.7437,188.2234,random(127),random(127),120); // Vortex 2 @ Killerfist
	AddStaticVehicleEx2(539,-922.6368,2705.8784,41.8895,187.5998,random(127),random(127),120); // Vortex 3 @ Killerfist
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1730.7542,1906.5891,10.4506,271.5123,random(127),random(127),120); // Uranus @ Schobbe
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-178.3450,1125.7755,19.3758,90.0378,random(127),random(127),120); // Uranus @ Bone County
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1948.8265,256.9810,35.1003,73.0383,random(127),random(127),120); // Uranus @ Wang
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1742.7960,1886.1082,10.4767,90.2223,random(127),random(127),120); // Jester @ Schobbe
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1949.0223,273.6024,35.1277,104.6659,random(127),random(127),120); // Jester @ Wang
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],768.3416,-1041.9899,23.6023,100.3108,random(127),random(127),120); // Jester @ LS
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1529.3361,1020.2397,10.5256,4.4770,random(127),random(127),120); // Sultan @ Freight depot
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1536.1719,-1672.2961,13.0876,0.8559,0,0,120); // Sultan @ LS PD
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1743.0114,1929.6406,10.5252,90.7420,random(127),random(127),120); // Sultan @ Schobbe
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1958.2225,280.6991,35.1744,33.6856,random(127),random(127),120); // Sultan @ Wang
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1731.0157,1899.3209,10.6346,269.2574,random(127),random(127),120); // Stratum @ Schobbe
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1948.3953,268.0500,35.2853,93.8675,random(127),random(127),120); // Stratum @ Wang
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],737.8689,-582.3646,16.4552,91.3072,random(127),random(127),120); // Stratum @ Dillmore
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-865.6339,1544.5582,22.7894,271.9265,random(127),random(127),120); // Stratum @ LasBar
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1742.2813,1903.5210,10.4804,271.9117,random(127),random(127),120); // Elegy @ Schobbe
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1948.5800,262.6873,35.1269,81.1802,random(127),random(127),120); // Elegy @ Wang
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-83.7083,-1135.5653,0.7378,3.1817,random(127),random(127),120); // Elegy@Flint county
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-2349.3716,-1601.0862,483.4802,260.5231,random(127),random(127),120); // Bandito @ Top Chilliad
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-771.5430,2422.7937,156.9470,89.8932,random(127),random(127),120); // bandito @ desert mountain top
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],878.7225,-26.4802,63.0615,153.7868,random(127),random(127),120); // Bandito @ Barts hideout
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1439.3281,2626.4766,55.6740,271.4410,random(127),random(127),120); // Phoenix @ ElQ
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1539.3438,-2744.7209,48.3753,170.1997,random(127),random(127),120); // Phoenix @ Angel
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2330.0403,123.5360,26.9519,271.6862,random(127),random(127),120); // Phoenix @ Montgomery
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-702.6691,946.0821,12.2167,92.0959,random(127),random(127),120); // Phoenix @ CIA Hideout
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],1556.1260,2750.2173,10.7916,87.5787,random(127),random(127),120); // Hotknife @ prickle pine
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-1950.3011,270.4685,41.0074,51.2248,random(127),random(127),120); // Hotknife @ Wang
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2107.1787,1408.8118,10.7935,179.7704,random(127),random(127),120); // Hotknife @ Autobahn
	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],-2159.2627,929.6685,79.9709,271.2936,random(127),random(127),120); // Hotknife @ Carlton Heights

	temp=random(sizeof(BusID));
	AddStaticVehicleEx2(416,-1527.8376,2525.5271,55.9186,0.7958,random(127),random(127),120); // Ambu El Quebrados
	AddStaticVehicleEx2(416,-2202.1653,-2315.3250,30.7744,319.6757,random(127),random(127),120); // ambu angel pine
	AddStaticVehicleEx2(BusID[temp],1021.3998,-1137.4877,23.7760,90.2755,random(127),random(127),120); // Bus @ LS
	AddStaticVehicleEx2(BusID[temp],1723.3408,1366.5786,10.6335,196.3376,random(127),random(127),120); // Bus @ LV
	AddStaticVehicleEx2(BusID[temp],-2245.1831,-2166.8572,38.6568,216.3015,random(127),random(127),120); // Bus @ base Chilliad
	AddStaticVehicleEx2(BusID[temp],-2291.8906,561.1787,35.1491,269.9930,random(127),random(127),120); // Bus @ SF
	AddStaticVehicleEx2(BusID[temp],-824.8470,1495.3438,19.2425,92.1640,random(127),random(127),120); // Bus @ Tee Pee Motel
	AddStaticVehicleEx2(443,1746.8610,1855.3480,11.4546,89.6751,random(127),random(127),120); // Packer 2
	AddStaticVehicleEx2(443,2176.3645,1421.3015,11.4536,90.4166,random(127),random(127),120); // Packer 1
	temp=random(sizeof(TruckID));
	AddStaticVehicleEx2(TruckID[temp],-1735.4095,151.7544,4.5737,179.1982,random(127),random(127),120); // Roadtrain 1 @ SF harbor
	AddStaticVehicleEx2(TruckID[temp],-1838.2985,-16.5535,16.1320,271.1695,random(127),random(127),120); // Roadtrain 2 @ SF harbor
	AddStaticVehicleEx2(TruckID[temp],2462.3042,-2497.9131,14.6622,225.2595,random(127),random(127),120); // Roadtrain LS
	AddStaticVehicleEx2(573,-17.5697,2328.7917,24.7914,90.0519,random(127),random(127),120); // Dune @ snake farm
	AddStaticVehicleEx2(573,-174.7376,1020.8372,20.3925,91.3845,random(127),random(127),120); // Dune @ bone county
	AddStaticVehicleEx2(573,-1886.2703,-1681.3112,22.3992,181.9548,random(127),random(127),120); // Dune @ Schobbe junkyard
	AddStaticVehicleEx2(573,-2350.1543,-1608.1272,484.2778,262.0942,random(127),random(127),120); // Dune @ top Chilliad
	AddStaticVehicleEx2(573,-359.6227,2229.7527,43.1362,104.2323,random(127),random(127),120); // Dune @ ghost town
	AddStaticVehicleEx2(573,-77.2654,22.7619,3.7590,72.6149,random(127),random(127),120); // Dune @ Blueberry

	AddStaticVehicleEx2(493,-2213.2214,2412.4309,-0.1853,47.3427,random(127),random(127),120); // jetmax 1 @ bayside marina
	AddStaticVehicleEx2(493,-2233.4946,2451.6079,-0.2732,223.4354,random(127),random(127),120); // jetmax 2 @ bayside marina
	AddStaticVehicleEx2(493,2304.0271,540.0773,-0.1799,182.4920,random(127),random(127),120); // Jetmax @ LV marina
	AddStaticVehicleEx2(493,2344.8787,534.0295,-0.2049,178.9311,random(127),random(127),120); // Jetmax 2 @ LV marina
	AddStaticVehicleEx2(493,-420.8095,1167.6893,-0.1736,95.9046,random(127),random(127),120); // jetmax @ bone county
	AddStaticVehicleEx2(493,-651.4309,869.0936,-0.1548,225.7632,random(127),random(127),120); // jetmax @ CIS hideout

	temp=random(sizeof(AircraftID));
	AddStaticVehicleEx2(476,-1161.8104,-149.9118,14.8544,134.5344,random(127),random(127),120); // Rustler @ SF airport
	AddStaticVehicleEx2(AircraftID[temp],1278.6392,1361.0084,9.5294,267.9339,random(127),random(127),120); // Rustler 1 @ LV AP
	AddStaticVehicleEx2(AircraftID[temp],1279.3284,1324.7869,9.5262,268.9922,random(127),random(127),120); // Rustler 2 @ LV AP
	AddStaticVehicleEx2(476,291.0717,2542.5012,17.5235,180.3865,random(127),random(127),120); // Rustler 1 @ abandon ap
	AddStaticVehicleEx2(AircraftID[temp],316.8959,2030.5323,18.3898,90.0,random(127),random(127),120); // Rustler 2 @ hideout
	AddStaticVehicleEx2(AircraftID[temp],-1361.4138,-491.8034,12.6274,206.5253,random(127),random(127),120); // dodo @ SF airport
	AddStaticVehicleEx2(AircraftID[temp],1372.3795,1767.7665,11.2821,266.3863,random(127),random(127),120); // Dodo @ LV AP
	AddStaticVehicleEx2(AircraftID[temp],1731.8376,-2421.7610,14.0084,182.0115,random(127),random(127),120); // Dodo @ LS airport

	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],-1131.1643,-221.8418,14.3275,109.9522,random(127),random(127),120); // maverick 1 @ SF airport
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],1290.8685,-786.7411,96.6371,180.8380,random(127),random(127),120); // Maverick @ madd doggs
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],-1349.9608,-239.1797,14.3248,311.3233,random(127),random(127),120); // Maverick 2 @ SF airport
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],1582.1520,1537.4630,11.0052,43.0080,random(127),random(127),120); // maverick 3 @ LV AP
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],1583.8772,1480.8314,11.0066,124.3766,random(127),random(127),120); // maverick 2 @ LV AP
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],1587.0015,1415.1357,11.0020,39.7032,random(127),random(127),120); // maverick 1 @ LV AP
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],1649.2480,-2425.2854,13.7309,177.1118,random(127),random(127),120); // maverick @ LS airport
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],1718.5201,-2660.2830,13.7229,0.3092,random(127),random(127),120); // maverick 2 @ LS airport
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],2094.3621,2414.1960,74.7542,179.5071,random(127),random(127),120); // maverick @ emerald
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],365.7045,2538.7336,16.8198,179.7558,random(127),random(127),120); // maverick @ abandon ap
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],7.1341,-239.5311,5.6062,358.8553,random(127),random(127),120); // Maverick @ badlands
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],-1679.9808,706.6362,30.7786,89.5697,-1,-1,120); // Pol maverick @ SF pol HQ
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],328.8196,1957.4136,17.8179,90.0,random(127),random(127),120); // pol mav 1 @ hideout
	AddStaticVehicleEx2(HelicopterID[random(sizeof(HelicopterID))],328.8196,1989.5388,17.8104,90.0,random(127),random(127),120); // pol mav 2 @ hideout

	AddStaticVehicleEx2(519,-1438.1233,-532.6832,15.0937,204.8926,random(127),random(127),120); // shamal @ SF airport
	AddStaticVehicleEx2(519,1561.8807,-2416.7908,14.4734,176.3147,random(127),random(127),120); // shamal @ LS airport
	AddStaticVehicleEx2(519,1584.8103,1361.0114,11.7744,143.6167,random(127),random(127),120); // shamal @ LV airport

	AddStaticVehicleEx2(592,1972.5306,-2631.3406,14.7408,0.4393,random(127),random(127),120); // Androm @ LS airport

	AddStaticVehicleEx2(TaxiID[random(sizeof(TaxiID))],2147.3413,-1166.5906,23.8233,270.0,random(127),random(127),120); // Cabbie @ LS
	AddStaticVehicleEx2(TaxiID[random(sizeof(TaxiID))],2146.9727,-1175.4255,23.5997,270.0,random(127),random(127),120); // Cabbie @ LS
	AddStaticVehicleEx2(TaxiID[random(sizeof(TaxiID))],2148.0840,-1180.2740,23.6006,270.0,random(127),random(127),120); // Cabbie @ LS

	AddStaticVehicleEx2(StreetRacerID[random(sizeof(StreetRacerID))],2039.8308,1517.7813,10.4093,178.6906,random(127),random(127),120); //Vehicle 2 @ ship

	AddStaticPickup(371, 15, 1710.3359,1614.3585,10.1191); //parachute
	AddStaticPickup(371, 15, 1964.4523,1917.0341,130.9375); //parachute
	AddStaticPickup(371, 15, 2055.7258,2395.8589,150.4766); //parachute
	AddStaticPickup(371, 15, 2265.0120,1672.3837,94.9219); //parachute
	AddStaticPickup(371, 15, 2265.9739,1623.4060,94.9219); //parachute
	AddStaticPickup(371, 15, 2301.8430,1298.3070,67.4688); //parachute
	AddStaticPickup(371, 15, -2261.2290,-1737.8878,487.4714); // parachute at top chilliad
	AddStaticPickup(1242,2,1643.5042,1673.4307,10.8203); // armour (lv airport)
	AddStaticPickup(1242,2,246.8546,1859.6214,14.3840); // armour (admin weap)
	AddStaticPickup(1240,3,2000.9961,1563.0219,14.9378); //hartje schip

	AddStaticPickup(367,2,2000.5782,1527.2074,14.6172); //Fotocamera
	AddStaticPickup(1274,1,2001.8032,1544.3296,13.5859); //Dollar teken op schip

	AddStaticPickup(1233,1,2024.3776,1544.7959,10.6250); //No parking sign

	AddStaticPickup(1244,1,2009.5000,-2445.0000,14.0000); //Gaspump at LS airport
	AddStaticPickup(1244,1,1337.0000,1493.0000,11.0000); // Gaspump at LV airport
	AddStaticPickup(1244,1,369.1400,2502.0000,17.0000); //Gaspump at Ab airport
	AddStaticPickup(1244,1,-1258.0000,6.5000,15.0000); //Gaspump at SF airport
	AddStaticPickup(1244,1,-1470.0000,160.0000,1.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-1550.0000,185.0000,1.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-1630.0000,205.0000,1.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-2206.0000,2419.0000,1.0000); //Gaspump at Tierra harbour
	AddStaticPickup(1244,1,1618.0000,580.0000,1.0000); //Gaspump at LV harbour 1
	AddStaticPickup(1244,1,2289.3000,522.0000,1.0000); //Gaspump at LV harbour 2
	AddStaticPickup(1244,1,2355.4700,522.0000,1.0000); //Gaspump at LV harbour 2
	AddStaticPickup(1244,1,723.0000,-1667.0000,1.0000); //Gaspump at LS harbour
	AddStaticPickup(1244,1,2009.5000,-2445.0000,16.0000); //Gaspump at LS airport
	AddStaticPickup(1244,1,1337.0000,1493.0000,13.0000); // Gaspump at LV airport
	AddStaticPickup(1244,1,369.1400,2502.0000,19.0000); //Gaspump at Ab airport
	AddStaticPickup(1244,1,-1258.0000,6.5000,17.0000); //Gaspump at SF airport
	AddStaticPickup(1244,1,-1470.0000,160.0000,3.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-1550.0000,185.0000,3.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-1630.0000,205.0000,3.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-2206.0000,2419.0000,3.0000); //Gaspump at Tierra harbour
	AddStaticPickup(1244,1,1618.0000,580.0000,3.0000); //Gaspump at LV harbour 1
	AddStaticPickup(1244,1,2289.3000,522.0000,3.0000); //Gaspump at LV harbour 2
	AddStaticPickup(1244,1,2355.4700,522.0000,3.0000); //Gaspump at LV harbour 2
	AddStaticPickup(1244,1,723.0000,-1667.0000,3.0000); //Gaspump at LS harbour
	AddStaticPickup(1244,1,2009.5000,-2445.0000,18.0000); //Gaspump at LS airport
	AddStaticPickup(1244,1,1337.0000,1493.0000,15.0000); // Gaspump at LV airport
	AddStaticPickup(1244,1,369.1400,2502.0000,21.0000); //Gaspump at Ab airport
	AddStaticPickup(1244,1,-1258.0000,6.5000,19.0000); //Gaspump at SF airport
	AddStaticPickup(1244,1,-1470.0000,160.0000,5.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-1550.0000,185.0000,5.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-1630.0000,205.0000,5.0000); //Gaspump at SF harbour
	AddStaticPickup(1244,1,-2206.0000,2419.0000,5.0000); //Gaspump at Tierra harbour
	AddStaticPickup(1244,1,1618.0000,580.0000,5.0000); //Gaspump at LV harbour 1
	AddStaticPickup(1244,1,2289.3000,522.0000,5.0000); //Gaspump at LV harbour 2
	AddStaticPickup(1244,1,2355.4700,522.0000,5.0000); //Gaspump at LV harbour 2
	AddStaticPickup(1244,1,723.0000,-1667.0000,5.0000); //Gaspump at LS harbour

	AddStaticPickup(1237,1,1005.3213,1292.3312,10.0000); //finish 1
	AddStaticPickup(1237,1,1011.3213,1292.3312,10.0000); //finish 1
	AddStaticPickup(1237,1,-2686.9250,2065.5604,55.3000); //finish 2
	AddStaticPickup(1237,1,-2676.9250,2065.5604,55.3000); //finish 2
	AddStaticPickup(1237,1,-2254.3164,1163.5691,55.0000); //finish 3
	AddStaticPickup(1237,1,-2264.3164,1163.5691,55.0000); //finish 3
	AddStaticPickup(1237,1,-2906.8135,-1173.6417,8.5000); //sprint 1
	AddStaticPickup(1237,1,-2915.6067,-1173.6417,8.5000); //sprint 1
	AddStaticPickup(1237,1,787.8717,-1416.8154,12.5000); //finish 4
	AddStaticPickup(1237,1,803.8717,-1416.8154,12.5000); //finish 4
	AddStaticPickup(1237,1,2875.7048,-691.5962,10.5000); //sprint 2
	AddStaticPickup(1237,1,2885.7048,-691.5962,10.5000); //sprint 2
	AddStaticPickup(1237,1,2895.7048,-691.5962,10.5000); //sprint 2
	AddStaticPickup(1237,1,1848.8054,-1214.8217,19.2880); //finish 5
	AddStaticPickup(1237,1,1190.0000,-192.2028,38.3178); //finish 6
	AddStaticPickup(1237,1,-2606.6000,338.2862,3.5000); //finish 7
	AddStaticPickup(1237,1,-2003.7500,1044.4615,55.2000); //finish 8
	AddStaticPickup(1237,1,-258.5000,-1777.6625,7.4000); //finish 9

	SetTimer("checkpointUpdate", 200, 1);
	SetTimer("PirateShipScoreUpdate", 2001, 1);
	SetTimer("AdminHideout", 4002, 1);
	SetTimer("PropertyScoreUpdate", 60000, 1);
	SetTimer("TimeUpdate",60000, 1);
	SetTimer("MoneyScan", 500, 1);
	SetTimer("HealthScan", 30000, 1);
	SetTimer("AutoOpenCar", 30000, 1);
	SetTimer("TaxiCheck", 30000, 1);
	SetTimer("SaveAllData", 120000, 1);
	SetTimer("SettingsExistsCheck", 5000, 1);
	SetTimer("JailUpdate", 60000, 1); // 1 minute
	SetTimer("TaxPayment", 360000, 1); // 6 minutes
	SetTimer("CasinoUpdate", 1100, 1);
	SetTimer("MoneyUpdate",5000,1);
	SetTimer("BankHackingNewAttempt",1440216,1); //24 minutes - one SA day
	SetTimer("CheckpointReset",5000, 1); //5 seconden
	SetTimer("JailBreakingNewAttempt",1440216,1); //24 minutes - one SA day
	SetTimer("JailBreakingCheckReset",45000, 1); //45 seconden
	SetTimer("HealCountdown", 45000, 1);
	SetTimer("OwnHealScan",30000, 1);
	SetTimer("RussianMatchGame", 1000, 1);
	SetTimer("RussianMatchGame2", 1000, 1);
	SetTimer("EagleMatchGame", 1000, 1);
	SetTimer("ChainMatchGame", 1000, 1);
	SetTimer("MiniMatchGame", 1000, 1);
	SetTimer("ResetDMArrays",5000, 1);
	SetTimer("UpdateSpeed", 250, 1);
	SetTimer("UziMatchGame", 1000, 1);
	SetTimer("MiniGunArena", 4002, 1);
	SetTimer("FillingUp", 2000, 1);
	SetTimer("PetrolConsumption", 5000, 1);
	SetTimer("HealingInAmbu", 5000, 1);
	SetTimer("CancelMedical", 10000, 1);
	SetTimer("DragRace1Game", 1000, 1);
	SetTimer("DragRace2Game", 1000, 1);
	SetTimer("DragRace3Game", 1000, 1);
	SetTimer("DragRace4Game", 1000, 1);
	SetTimer("DragRace5Game", 1000, 1);
	SetTimer("DragRace6Game", 1000, 1);
	SetTimer("DragRace7Game", 1000, 1);
	SetTimer("DragRace8Game", 1000, 1);
	SetTimer("DragRace9Game", 1000, 1);
	SetTimer("SprintRace1Game", 1000, 1);
	SetTimer("SprintRace2Game", 1000, 1);
	SetTimer("ChairLifting", 500, 1);
	SetTimer("CountDown", 1000, 1);
	SetTimer("PizzaScores", 250, 0);
	SetTimer("TaxiScores", 250, 0);
	SetTimer("SprintRace3Game", 1000, 1);
	SetTimer("SprintRace4Game", 1000, 1);
	SetTimer("SprintRace5Game", 1000, 1);
	SetTimer("SprintRace6Game", 1000, 1);
	SetTimer("SprintRace7Game", 1000, 1);
	SetTimer("MotorRace1Game", 1000, 1);
	SetTimer("MotorRace2Game", 1000, 1);
	SetTimer("MotorRace3Game", 1000, 1);
	SetTimer("MotorRace4Game", 1000, 1);
	SetTimer("MotorRace5Game", 1000, 1);
	SetTimer("CircuitRaceTime", 100, 1);
	SetTimer("KickOperation", 500, 1);
	SetTimer("BanOperation", 500, 1);
	SetTimer("PatrolMissionTimer", 10000, 1);
	SetTimer("SelfHealing", 5000, 1);
   	SetTimer("TransferMoney",250,1);
	SetTimer("MinuteRoutine",60000,1);
	SetTimer("RacesCountdown",1000,1);
	SetTimer("SecondRoutine",1000,1);
	SetTimer("TaxiWaiting", 1000,1);

	for(new i=0; i < MAX_PROPERTIES; i++) {
	    propertyCurrentValue[i]=propertyValues[i];
	}

	return 1;
}

public SendPlayerFormattedText(playerid, const str[], define)
{
	new tmps1buf[256];
	format(tmps1buf, sizeof(tmps1buf), str, define);
	SendClientMessage(playerid, 0xFFFF00AA, tmps1buf);
}

public SendAllFormattedText(playerid, const str[], define)
{
	new tmps1buf[256];
	format(tmps1buf, sizeof(tmps1buf), str, define);
	SendClientMessageToAll(0xFFFF00AA, tmps1buf);
}

public SaveFile(playerid)
{
	GetPlayerName(playerid, playername, sizeof(playername));

	if (dini_Exists(udb_encode(playername)) && logged[playerid] == 1) {
		dini_IntSet(udb_encode(playername), "money", GetPlayerMoney(playerid));
       	dini_IntSet(udb_encode(playername), "bank", bank[playerid]);
      	dini_IntSet(udb_encode(playername), "bounty", bounty[playerid]);
      	dini_IntSet(udb_encode(playername), "jailed", jailed[playerid]);
      	dini_IntSet(udb_encode(playername), "jailtime", jailtime[playerid]);
	}
	return 1;
}

public SaveProperties(playerid)
{
	new i,j,k;

	for(k=0; k < MAX_OWNED_PROPERTIES; k++) {
    	propertyArray[playerid][k] = 0;
	}
    j=0;
    for(i=0; i < MAX_PROPERTIES; i++) {
        if(propertyOwner[i] < 999) {
            if(propertyOwner[i]==playerid) {
         		propertyArray[playerid][j] = i;
				j++;
            }
        }
    }

    GetPlayerName(playerid, playername, sizeof(playername));
    format(strings, sizeof(strings), "--- Saved property array of %s (id: %d).", playername, playerid);
	printf(strings);

	return 1;
}


public ResetPlayerArrays(playerid)
{
 	new i,j;
	i = playerid;

	logged[i] = 0;
	OwnPlayerColorChosen[i] = 0;
	OwnPlayerColor[i] = 999;
	bank[i] = 0;
	bounty[i] = 0;
	adminlevel[i] = 0;
	god[i] = 0;
	payment[i] = 0;
	jailed[i] = 0;
	jailtime[i] = 0;
	jailoutbreak[i] = 0;
	muted[i] = 0;
	hideoutwarning[i] = 0;
	gamblelicence[i] = 0;
	currentmoney[i] = 0;
	spawned[i] = 0;
	SpawnTimeout[i] = 0;
	isincasino[i] = 0;
	isprotected[i] = 0;
	query[i] = 255;
	admindived[i] = 0;
	autolock[i]=0;
	PlayerEnteredCheckpoint[i] = 0;
	FirstWellfare[playerid] = 1;
	Killed[i] = 0;
	ForbiddenTuningTimes[i] = 0;
    ForbiddenTuningBool[playerid] = 0;
	Payout[i]=0;
    
    MoneyChecking[i] = 0;
    MoneyTransferAmount[i] = 0;

	Fuelcan[i]=0;
	FuelcanContent[i]=0;

	for(j=0; j < MAX_PROPERTIES; j++) {
		if(propertyOwner[j] == playerid) {
		    propertyOwner[j] = 999;
			if(GetPlayerMoney(playerid)+propertyCurrentValue[j] <= MAX_MONEY) {
			    // TO-DO money scanner update
			    format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d got money back from properties after a array-reset.", propertyCurrentValue[j], GetPlayerMoney(playerid), playerid);
			    StatGivePlayerMoney(playerid, propertyCurrentValue[j], moneyreason);
			}
			ownedtime[propertyShortNames[j]] = 0;
  		}
	}

	for(new k=0; k < MAX_OWNED_PROPERTIES; k++){
		propertyArray[playerid][k] = 0;
	}

	PF[i] = 0;
	QF[i] = 0;
	RF[i] = 0;

	WaitingTime[i] = 0;
	RequestedTaxi[i] = 0;
	WaitingTime2[i] = 0;
	RequestedTaxi2[i] = 0;

	BankHackTime[i] = 0;
	BankHacker[i] = 0;
	BankHackVictim[i] = 0;
	BankHackVictimAttempt[i] = 0;
	BankHackPassword[i] = 0;
	BankHackAttempt[i] = 0;
	BankHackWarning[i] = 0;
	BankHackTimer[i] = 0;

	JailBreakTime[i] = 0;
	JailBreaker[i] = 0;
	JailBreakPassword[i] = 0;
	JailBreakAttempt[i] = 0;
	JailBreakWarning[i] = 0;
	JailBreakTimer[i] = 0;

	TaxiUsedNew[i] = 0;
	TaxiUsedPoor[i] = 0;
	TaxiUsedRich[i] = 0;
	TaxiUpcomingDrive[i] = 0;
	TotalMoney[i] = 0;
	
	Medic[i] = 0;
	OwnHeal[i] = 0;

	eaglematchplayers[i] = 0;
	chainmatchplayer[i] = 0;
	chainmatchplayers[i] = 0;
	minimatchplayer[i] = 0;
	minimatchplayers[i] = 0;
	uzimatchplayer[i] = 0;
	uzimatchplayers[i] = 0;
	deathmatcher1[i] = 0;
	deathmatcher4[i] = 0;
	deathmatcher5[i] = 0;
	deathmatcher6[i] = 0;

	DMplayer[i] = 0;
	
	speedometer[i] = 0;
	speedometeron[i] = 0;
	calculatespeed[i] = 0;
	
	GroupTalkers[i] = 0;
	GroupInvites[i] = 0;
	GroupInviter[i] = 0;

	CarSprayX[i] = 0;
	CarSprayY[i] = 0;
	CarSprayZ[i] = 0;
	CarSprayVehicleid[i] = 0;
	CarSprayCountdown[i] = 0;
	payandspray[i] = 0;
	askedpayandspray[i] = 0;
	readypayandspray[i] = 0;

	askedlowtuner[playerid]=0;
	readylowtuner[playerid]=0;
	lowtunerback[playerid]=0;

	askedstreettuner[playerid]=0;
	readystreettuner[playerid]=0;
	streettunerback[playerid]=0;

	CarXPos[playerid] = 0.00;
	CarYPos[playerid] = 0.00;
	CarZPos[playerid] = 0.00;
	CurrentVehicle[playerid] = 0;
	TotalPetrol[playerid] = 0;
	Tanking[playerid] = 0;
	Teleporting[playerid] = 0;
	VehicleGroup[playerid] = 0;
	FuelmeterOff[playerid] = 0;
	
	spawnloc[playerid] = 0;
	SpawnViewCountdown[playerid] = 0;
	AskedSpawnView1[playerid] = 0;
	AskedSpawnView2[playerid] = 0;
	SpawnViewer[playerid] = 0;
	
	OwnSpawner[playerid] = 0;

	MedicalOfficer[playerid] = 0;
	MedicalOfficerOnMission[playerid] = 0;
	OutOfAmbu[playerid] = 0;
	GetBackInAmbu[playerid] = 0;
	BackInAmbuCounter[playerid] = 0;
	
	EnteredVehicle[playerid] = 0;
	
	PirateMoneyMessageCounter[playerid] = 0;
	
	deathmatcher7[playerid] = 0;
	dragrace1players[playerid] = 0;
	dragracer[playerid]=0;
	askedcardive[playerid]=0;
 	NoReset[playerid]=0;

	DrivebyWarning[playerid] = 0;
 	WeaponCheatWarning[playerid] = 0;
 	
 	Kills[playerid]=0;
 	Suicides[playerid]=0;
 	Deaths[playerid]=0;
 	
 	Fined[playerid]=0;
	OutOfRanger[playerid]=0;
	GetBackInRanger=0;
	if(	HighwayOnMission[playerid] == 1){
	    HighwayMission = 0;
		HighwayOnMission[playerid]=0;
	}
	BackInRangerCounter[playerid]=0;
	
	melee[playerid]=0;
	pistol[playerid]=0;
	pistolammo[playerid]=0;
	shotgun[playerid]=0;
	shotgunammo[playerid]=0;
	smg[playerid]=0;
	smgammo[playerid]=0;
	rifle[playerid]=0;
	rifleammo[playerid]=0;
	gift[playerid]=0;
	DisarmedPlayer[playerid]=0;
	
	Chairlifter1[playerid] = 0;
	Chairliftcounter1[playerid] = 0;
	Chairlifter2[playerid] = 0;
	Chairliftcounter2[playerid] = 0;
	
	PlayerDisarmDelay[playerid] = 0;
	AdminPlayer[playerid] = 0;
	
	PizzaNextCP[playerid] = 0;
	PizzaTimer[playerid] = 0;
	PizzaDelivered[playerid] = 0;
	Pizza[playerid] = 0;
	PizzaExtraTime[playerid] = 0;
	PizzaExtraTimeDisplay[playerid] = 0;
	PizzaReturnTrip[playerid] = 0;
	PizzaTotalTime[playerid] = 0;
	PizzaWaitTime[playerid] = 0;
	PizzaVehicle[playerid] = 0;
	
	Helper[playerid]=0;
	NewPlayer[playerid]=0;
	
	TaxiNextCP[playerid] = 0;
	TaxiTimer[playerid] = 0;
	TaxiDelivered[playerid] = 0;
	TaxiDriver[playerid] = 0;
	TaxiExtraTime[playerid] = 0;
	TaxiExtraTimeDisplay[playerid] = 0;
	TaxiReturnTrip[playerid] = 0;
	TaxiTotalTime[playerid] = 0;
	TaxiWaitTime[playerid] = 0;
	TaxiVehicle[playerid] = 0;
	TaxiDistance[playerid] = 0;
	ApplyTaxi[playerid] = 0;
	NewTaxiDriver[playerid] = 0;
	TransFenderTuner[playerid] = 0;
	ArchangelsTuner[playerid] = 0;

	deathmatcher18[playerid] = 0;
	sprintrace3players[playerid] = 0;
	SprintRace3NextCP[playerid] = 0;
	SprintRace3CPCounter[playerid] = 0;
	deathmatcher19[playerid] = 0;
	sprintrace4players[playerid] = 0;
	SprintRace4NextCP[playerid] = 0;
	SprintRace4CPCounter[playerid] = 0;
	deathmatcher20[playerid] = 0;
	sprintrace5players[playerid] = 0;
	SprintRace5NextCP[playerid] = 0;
	SprintRace5CPCounter[playerid] = 0;
	deathmatcher21[playerid] = 0;
	sprintrace6players[playerid] = 0;
	SprintRace6NextCP[playerid] = 0;
	SprintRace6CPCounter[playerid] = 0;
	deathmatcher22[playerid] = 0;
	sprintrace7players[playerid] = 0;
	SprintRace7NextCP[playerid] = 0;
	SprintRace7CPCounter[playerid] = 0;
	deathmatcher24[playerid] = 0;
	deathmatcher25[playerid] = 0;
	deathmatcher26[playerid] = 0;
	deathmatcher27[playerid] = 0;
	motorrace1players[playerid] = 0;
	MotorRace1NextCP[playerid] = 0;
	MotorRace1CPCounter[playerid] = 0;
	motorrace2players[playerid] = 0;
	MotorRace2NextCP[playerid] = 0;
	MotorRace2CPCounter[playerid] = 0;
	motorrace3players[playerid] = 0;
	MotorRace3NextCP[playerid] = 0;
	MotorRace3CPCounter[playerid] = 0;
	motorrace4players[playerid] = 0;
	MotorRace4NextCP[playerid] = 0;
	MotorRace4CPCounter[playerid] = 0;
	motorrace5players[playerid] = 0;
	MotorRace5NextCP[playerid] = 0;
	MotorRace5CPCounter[playerid] = 0;
	RaceTime[playerid] = 0;
	RaceTiming[playerid] = 0;
	CrossedCheckpoints[playerid] = 0;
	CheckpointsToBeCrossed[playerid] = 0;
	sprintracer[playerid] = 0;
	
	ToBeKicked[playerid] = 0;
	ToBeBanned[playerid] = 0;

	PMSpyOn[playerid] = 0;
	PMListen[playerid] = 0;
	
	WelFare[playerid] = 0;
	
	VisitingPrison[playerid] = 0;
	FloodProtectionTimer[playerid]=0;
	FloodProtectionCounter[playerid]=0;
	
	SuspectedSpeedCheater[i]= 0;
	SuspectedSpeedCheaterTimer[i]=0;

	Transfered[i] = 0;

	player_zone[i] = -1;
	
    for(new l=0; l<MAX_PLAYERS; l++){
        IgnorePlayerlist[i][l] = 0;
    }

 	GetPlayerName(playerid, playername, sizeof(playername));
	format(strings, sizeof(strings), "--- Resetted all arrays of %s (id: %d).", playername, playerid);
	printf(strings);

	return 1;
}

public IsNumeric(const string[])
{
	for (new i = 0, j = strlen(string); i < j; i++) {
	    if (string[i] > '9' || string[i] < '0') {
			return 0;
		}
	}

	return 1;
}

public TaxPayment()
{
    new TotalTax;
    new TaxForMayor;
    new CalculateTax;
    // Do we have a mayor or governor?
    if (propertyOwner[P_LSTOWN] < 999 || propertyOwner[P_SFTOWN] < 999 || propertyOwner[P_LVTOWN] < 999 || propertyOwner[P_SAGOVERN] < 999) {
        CalculateTax = 1;
	}
	for(new i=0; i<MAX_PLAYERS; i++) {
		if(IsPlayerConnected(i) == 1 && logged[i] == 1) {
		    new CurrentMoney2;
		    new TaxingMoney;
		    new Taxdeduct;
		    new TaxPayed;
		    new temp1,temp2,temp3;
		    CurrentMoney2 = GetPlayerMoney(i);
		    if (CurrentMoney2 > TaxLevel3){
		        temp1=CurrentMoney2 - TaxLevel3;
		        temp2=TaxLevel3 - TaxLevel2;
		        temp3=TaxLevel2-TaxFree;
		        Taxdeduct = floatround(temp1 / TaxPercentage3) + floatround(temp2 / TaxPercentage2) + floatround(temp3 / TaxPercentage1);
		        format(moneyreason, sizeof(moneyreason), "* Money decreased for %d by $%d because the player was taxed.", i, Taxdeduct);
		        StatGivePlayerMoney(i, -Taxdeduct, moneyreason);
       		    format(strings, sizeof(strings), "* You were taxed and you had to pay $%d.", Taxdeduct);
				SendClientMessage(i, COLOR_SYSTEM_PW, strings);
				TaxPayed++;
				if (CalculateTax == 1) {
				    TotalTax = TotalTax + Taxdeduct;
				}
			}
			if (CurrentMoney2 > TaxLevel2 && TaxPayed == 0 ){
		        temp2=TaxLevel3 - TaxLevel2;
		        temp3=TaxLevel2-TaxFree;
		        Taxdeduct = floatround(temp2 / TaxPercentage2) + floatround(temp3 / TaxPercentage1);
		        format(moneyreason, sizeof(moneyreason), "* Money decreased for %d by $%d because the player was taxed.", i, Taxdeduct);
		        StatGivePlayerMoney(i, -Taxdeduct, moneyreason);
       		    format(strings, sizeof(strings), "* You were taxed and you had to pay $%d.", Taxdeduct);
				SendClientMessage(i, COLOR_SYSTEM_PW, strings);
				TaxPayed++;
				if (CalculateTax == 1) {
				    TotalTax = TotalTax + Taxdeduct;
				}
			}
			if (CurrentMoney2 > TaxFree && TaxPayed == 0 ){
		        TaxingMoney = CurrentMoney2 - TaxFree;
		        Taxdeduct = floatround(TaxingMoney / TaxPercentage1);
		        format(moneyreason, sizeof(moneyreason), "* Money decreased for %d by $%d because the player was taxed.", i, Taxdeduct);
		        StatGivePlayerMoney(i, -Taxdeduct, moneyreason);
       		    format(strings, sizeof(strings), "* You were taxed and you had to pay $%d.", Taxdeduct);
				SendClientMessage(i, COLOR_SYSTEM_PW, strings);
				if (CalculateTax == 1) {
				    TotalTax = TotalTax + Taxdeduct;
				}
			}
		}

	}

	if (CalculateTax == 1) {
		new mayor;
		new property;
	    for (new i=0;i<4;i++){
	        if(i==0) {property = P_LSTOWN;}
	        if(i==1) {property = P_SFTOWN;}
	        if(i==2) {property = P_LVTOWN;}
	        if(i==3) {property = P_SAGOVERN;}
			mayor=propertyOwner[property];
			if (mayor < 999){
		        if (jailed[mayor] == 0){
				    // The mayor gets 20% of the total tax, governor gets 30%
	    		    TaxForMayor = floatround(TotalTax / TaxPercentage2);
	    		    if(i==3) {TaxForMayor = floatround(TaxForMayor * 1.45);}
	        		format(moneyreason, sizeof(moneyreason), "* Money increased for %d by $%d because the mayor received his cut of the tax.", propertyOwner[property], TaxForMayor);
	        		StatGivePlayerMoney(propertyOwner[property], TaxForMayor, moneyreason);
	  	    		format(strings, sizeof(strings), "* You received out of taxing San Andreas $%d.", TaxForMayor);
					SendClientMessage(propertyOwner[property], COLOR_SYSTEM_PW, strings);
				}
			}
		}
	}
	return 1;
}

public MoneyUpdate(){
	new workspace;
	new workscore[MAX_PLAYERS];
	
	for(new i=0;i<MAX_PLAYERS;i++){
		if(IsPlayerConnected(i)){
			workspace=floatround((GetPlayerMoney(i)/200000),floatround_tozero);
			workscore[i]=workscore[i]+workspace;
			workspace=floatround((Kills[i]/2),floatround_tozero);
			workscore[i]=workscore[i]+workspace;
			workspace=floatround((Deaths[i]/5),floatround_tozero);
			workscore[i]=workscore[i]-workspace;
			workscore[i]=workscore[i]-Suicides[i];
			SetPlayerScore(i,workscore[i]);
		}
	}
}

public BankHackingNewAttempt(){
	for(new i=0;i<MAX_PLAYERS;i++){
		if(IsPlayerConnected(i)){
			if(BankHackAttempt[i] > 0) {
			    BankHackAttempt[i]--;
				if(BankHackAttempt[i] == 0){
					SendClientMessage(i, COLOR_SYSTEM_PM , "* Your trail has gone cold, you can hack the bank again.");
				}
			}
			if(BankHackVictimAttempt[i] > 0) {
			    BankHackVictimAttempt[i]--;
				if(BankHackVictimAttempt[i] == 0){
					SendClientMessage(i, COLOR_SYSTEM_PM , "* The bank has closed the investigation, they found no trace of the hacker.");
				}
			}
		}
	}
}

public JailBreakingNewAttempt(){
	for(new i=0;i<MAX_PLAYERS;i++){
		if(IsPlayerConnected(i)){
			if(JailBreakAttempt[i] > 0) {
			    JailBreakAttempt[i]--;
				if(JailBreakAttempt[i] == 0){
					SendClientMessage(i, COLOR_SYSTEM_PM , "* Your trail has gone cold, you can hack the bank again.");
				}
			}
		}
	}
}

public CheckpointReset(){
	for(new i=0;i<MAX_PLAYERS;i++){
		if(IsPlayerConnected(i)){
		    if(PlayerEnteredCheckpoint[i] > 0) PlayerEnteredCheckpoint[i]--;
		}
	}
}

public MedicCountdown(){

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i) && logged[i] == 1)){
			if(Medic[i]>0){
			    Medic[i]--;
			} 
		}
	}
}

public HealCountdown(){
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i) && logged[i] == 1)){
			if(OwnHeal[i]>0){
			    Medic[i]--;
			}
		}
	}
}

public OwnHealScan(){
	new Float:health;
	new CurrentHealth;

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i) && logged[i] == 1)){
			GetPlayerHealth(i, health);
			CurrentHealth=floatround(health);
			if((propertyOwner[P_ANGELMED] == i) && (propertyOwner[P_ELQMED] == i)){
				if ( CurrentHealth < 99 ){
				    if (CurrentHealth > 80 ){
				        SetPlayerHealth(i, 99.0);
					} else {
					    SetPlayerHealth(i, health+20.0);
					}
				}
			} else {
			    if(propertyOwner[P_ANGELMED] == i){
					if ( CurrentHealth < 99 ){
					    if (CurrentHealth > 92 ){
					        SetPlayerHealth(i, 99.0);
						} else {
						    SetPlayerHealth(i, health+7.0);
						}
					}
				}
				if(propertyOwner[P_ANGELMED] == i){
					if ( CurrentHealth < 99 ){
					    if (CurrentHealth > 92 ){
					        SetPlayerHealth(i, 99.0);
						} else {
						    SetPlayerHealth(i, health+7.0);
						}
					}
				}
			}
		}
	}
	return 1;
}

public EagleMatchGame(){
	new deathmatchplayer;
	new Float:X1=-1309.1630;
	new Float:Y1=2460.2312;
	new Float:Z1=87.5328;
	new Float:X2=-1282.8746;
	new Float:Y2=2549.0989;
	new Float:Z2=85.5925;
	
    if(eaglematchstarted == 0){
        return 1;
	} else {
	    if((eaglecountdownseconds > 0) || (eaglecountdownseconds2>0)){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (eaglematchplayers[i] == 1)){
		    deathmatchplayer++;
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(eaglematchplayers[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to fight you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 100000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				eaglematchplayers[i]=0;
				eaglematch[0]=0;
				eaglematchstarted=0;
				DMplayer[i]=0;
				playerseaglematch=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (eaglematchplayers[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the DM since you are jailed.");
				eaglematchplayers[i]=0;
				eaglematch[i]=0;
				DMplayer[i]=0;
				playerseaglematch=playerseaglematch-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X1,Y1,Z1);
					PlayerPlaySound(i,1057,X1,Y1,Z1);
					format(strings, sizeof(strings), "~w~Deathmatch started");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1252.4963,-1329.7220,2570.1003,2425.7915);
					deathmatcher1[i]=1;
					eaglematchplayers[i]=0;
					eaglematchinprogress=1;
					eaglecountdownseconds2=5;
					TogglePlayerControllable(i,0);
				} else {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X2,Y2,Z2);
					PlayerPlaySound(i,1057,X2,Y2,Z2);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1252.4963,-1329.7220,2570.1003,2425.7915);
					deathmatcher1[i]=1;
					eaglematchplayers[i]=0;
					eaglematchinprogress=1;
					TogglePlayerControllable(i,0);
				}
			}
		}
	}
	
	if(playerseaglematch == 1){
		for(new k=0;k<MAX_PLAYERS;k++){
		    if(deathmatcher1[k] == 1){
				GetPlayerName(k,playername,sizeof(playername));
				format(strings, sizeof(strings), "~w~%s has won the desert eagle death match",playername);
				GameTextForAll(strings,3000,4);
				SendClientMessage(k,COLOR_SYSTEM_PM, "You won the minigame! Congratulations.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the eagle death match.", k, 20000, GetPlayerMoney(k));
				StatGivePlayerMoney(k, 20100, strings);
			    SetPlayerWorldBounds(k,5000.0000,-53000.0000,5000.0000,-5000.0000);
				SpawnPlayer(k);
				eaglematchstarted=0;
				eaglematchinprogress=0;
				NoReset[k]=1;
			}
		}
	}
	new eagleplayers;
	for(new m=0;m<MAX_PLAYERS;m++){
	    if(deathmatcher1[m] == 1){
			eagleplayers++;
		}
	}
	if(eagleplayers==0){
		format(strings, sizeof(strings), "~w~the desert eagle standoff has ended in a tie",playername);
		GameTextForAll(strings,3000,4);
		eaglematchstarted=0;
		eaglematchinprogress=0;
	}

	return 1;
}

public ChainCountdown()
{
    if(chainmatchstarted == 1){
		if(chaincountdownseconds > 0) {
		    chaincountdownseconds--;
			if(chaincountdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(chainmatchplayers[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~Chainsaw massacre starts in~n~~r~%d", chaincountdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(chaincountdownseconds == 20){
				    if(chainmatch[3] == 0){
						format(strings, sizeof(strings), "Chainsaw massacre starts in %d seconds, %d seats available. Type /chainmatch to join", chaincountdownseconds,4-playerschainmatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(chaincountdownseconds == 10){
				    if(chainmatch[3] == 0){
						format(strings, sizeof(strings), "Chainsaw massacre starts in %d seconds, %d seats available. Type /chainmatch to join", chaincountdownseconds,4-playerschainmatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(chaincountdownseconds == 5){
				    if(chainmatch[3] == 0){
						format(strings, sizeof(strings), "Chainsaw massacre starts in %d seconds, %d seats available. Type /chainmatch to join", chaincountdownseconds,4-playerschainmatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(chainmatchplayers[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerschainmatch--;
					chainmatchprice=chainmatchprice-10000;
					if(playerschainmatch == 0){
						format(strings, sizeof(strings), "Chain saw massacre has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						chainmatchstarted=0;
						chainmatchinprogress=0;
						chaincountdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (chainmatchinprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(chainmatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerschainmatch--;
					}
				}
			}
		}
		return 1;
	}

  	return 1;
}

public ChainMatchGame(){
	new deathmatchplayer;
	new Float:X1=1893.0850;
	new Float:Y1=-1307.0752;
	new Float:Z1=14.5004;
	new Float:X2=1870.5754;
	new Float:Y2=-1324.2369;
	new Float:Z2=14.5004;
	new Float:X3=1893.0850;
	new Float:Y3=-1324.2369;
	new Float:Z3=14.5004;
	new Float:X4=1870.5754;
	new Float:Y4=-1307.0752;
	new Float:Z4=14.5004;

    if(chainmatchstarted == 0){
        return 1;
	} else {
	    if(chaincountdownseconds>0 || chaincountdownseconds2 > 0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (chainmatchplayers[i] == 1)){
		    deathmatchplayer++;
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(chainmatchplayers[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to fight you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 100000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				chainmatchplayers[i]=0;
				chainmatch[0]=0;
				chainmatchstarted=0;
				DMplayer[i]=0;
				playerschainmatch=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (chainmatchplayers[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the DM since you are jailed.");
				chainmatchplayers[i]=0;
				chainmatch[i]=0;
				DMplayer[i]=0;
				playerschainmatch=playerschainmatch-1;
			} else {
			    if (deathmatchplayer == 1) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X1,Y1,Z1);
					PlayerPlaySound(i,1057,X1,Y1,Z1);
					format(strings, sizeof(strings), "~w~Deathmatch started");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,1930.7277,1870.0850,-1260.8850,-1337.0752);
					deathmatcher4[i]=1;
					chainmatchplayers[i]=0;
					chainmatchinprogress=1;
					TogglePlayerControllable(i,0);
					chaincountdownseconds2=5;
				}
				if (deathmatchplayer == 2) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X2,Y2,Z2);
					PlayerPlaySound(i,1057,X2,Y2,Z2);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,1930.7277,1870.0850,-1260.8850,-1337.0752);
					deathmatcher4[i]=1;
					chainmatchplayers[i]=0;
					chainmatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 3) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X3,Y3,Z3);
					PlayerPlaySound(i,1057,X3,Y3,Z3);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,1930.7277,1870.0850,-1260.8850,-1337.0752);
					deathmatcher4[i]=1;
					chainmatchplayers[i]=0;
					chainmatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 4) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X4,Y4,Z4);
					PlayerPlaySound(i,1057,X4,Y4,Z4);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,1930.7277,1870.0850,-1260.8850,-1337.0752);
					deathmatcher4[i]=1;
					chainmatchplayers[i]=0;
					chainmatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
			}
		}
	}
	if(playerschainmatch == 1){
		for(new k=0;k<MAX_PLAYERS;k++){
		    if(deathmatcher4[k] == 1){
				GetPlayerName(k,playername,sizeof(playername));
				format(strings, sizeof(strings), "~w~%s has won the chainsaw massacre",playername);
				GameTextForAll(strings,3000,4);
				SendClientMessage(k,COLOR_SYSTEM_PM, "You won the minigame! Congratulations.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the chain DM.", k, chainmatchprice, GetPlayerMoney(k));
				StatGivePlayerMoney(k, chainmatchprice+100, strings);
			    SetPlayerWorldBounds(k,5000.0000,-53000.0000,5000.0000,-5000.0000);
				SpawnPlayer(k);
				chainmatchstarted=0;
				chainmatchinprogress=0;
				NoReset[k]=1;
			}
		}
	}
	new chainplayers;
	for(new m=0;m<MAX_PLAYERS;m++){
	    if(deathmatcher4[m] == 1){
			chainplayers++;
		}
	}
	if(chainplayers==0){
		format(strings, sizeof(strings), "~w~the chainsaw massacre has ended in a tie",playername);
		GameTextForAll(strings,3000,4);
		chainmatchstarted=0;
		chainmatchinprogress=0;
		chainmatchprice=0;
	}

	return 1;
}

public MiniMatchGame(){
	new deathmatchplayer;
	new Float:X1=-1273.4841;
	new Float:Y1=500.8097;
	new Float:Z1=18.2344;
	new Float:X2=-1291.2842;
	new Float:Y2=491.4969;
	new Float:Z2=11.1953;
	new Float:X3=-1381.6671;
	new Float:Y3=508.8520;
	new Float:Z3=3.0391;
	new Float:X4=-1447.0375;
	new Float:Y4=494.2693;
	new Float:Z4=18.2845;
	new Float:X5=-1438.8260;
	new Float:Y5=491.8917;
	new Float:Z5=11.1953;
	new Float:X6=-1428.0055;
	new Float:Y6=511.4443;
	new Float:Z6=3.0391;

    if(minimatchstarted == 0){
        return 1;
	} else {
	    if(minicountdownseconds>0 || minicountdownseconds2 > 0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (minimatchplayers[i] == 1)){
		    deathmatchplayer++;
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(minimatchplayers[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to fight you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 100000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				minimatchplayers[i]=0;
				minimatch[0]=0;
				minimatchstarted=0;
				DMplayer[i]=0;
				playersminimatch=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (minimatchplayers[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the DM since you are jailed.");
				minimatchplayers[i]=0;
				DMplayer[i]=0;
				playersminimatch=playersminimatch-1;
			} else {
			    if (deathmatchplayer == 1) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X1,Y1,Z1);
					PlayerPlaySound(i,1057,X1,Y1,Z1);
					format(strings, sizeof(strings), "~w~Deathmatch started");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1257.1309,-1464.8488,516.0317,486.5935);
					deathmatcher5[i]=1;
					minimatchplayers[i]=0;
					minimatchinprogress=1;
					TogglePlayerControllable(i,0);
					minicountdownseconds2=5;
				}
				if (deathmatchplayer == 2) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X2,Y2,Z2);
					PlayerPlaySound(i,1057,X2,Y2,Z2);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1257.1309,-1464.8488,516.0317,486.5935);
					deathmatcher5[i]=1;
					minimatchplayers[i]=0;
					minimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 3) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X3,Y3,Z3);
					PlayerPlaySound(i,1057,X3,Y3,Z3);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1257.1309,-1464.8488,516.0317,486.5935);
					deathmatcher5[i]=1;
					minimatchplayers[i]=0;
					minimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 4) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X4,Y4,Z4);
					ResetPlayerWeapons(i);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1257.1309,-1464.8488,516.0317,486.5935);
					deathmatcher5[i]=1;
					minimatchplayers[i]=0;
					minimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 5) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X5,Y5,Z5);
					PlayerPlaySound(i,1057,X5,Y5,Z5);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1257.1309,-1464.8488,516.0317,486.5935);
					deathmatcher5[i]=1;
					minimatchplayers[i]=0;
					minimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 6) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X6,Y6,Z6);
					PlayerPlaySound(i,1057,X6,Y6,Z6);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,-1257.1309,-1464.8488,516.0317,486.5935);
					deathmatcher5[i]=1;
					minimatchplayers[i]=0;
					minimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
			}
		}
	}
	if(playersminimatch == 1){
		for(new k=0;k<MAX_PLAYERS;k++){
		    if(deathmatcher5[k] == 1){
				GetPlayerName(k,playername,sizeof(playername));
				format(strings, sizeof(strings), "~w~%s has won the minigun madness",playername);
				GameTextForAll(strings,3000,4);
				SendClientMessage(k,COLOR_SYSTEM_PM, "You won the minigame! Congratulations.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the mini DM.", k, minimatchprice, GetPlayerMoney(k));
				StatGivePlayerMoney(k, minimatchprice+100, strings);
			    SetPlayerWorldBounds(k,5000.0000,-53000.0000,5000.0000,-5000.0000);
				SpawnPlayer(k);
				minimatchstarted=0;
				minimatchinprogress=0;
				NoReset[k]=1;
			}
		}
	}
	new miniplayers;
	for(new m=0;m<MAX_PLAYERS;m++){
	    if(deathmatcher5[m] == 1){
			miniplayers++;
		}
	}
	if(miniplayers==0){
		format(strings, sizeof(strings), "~w~the minigun madness has ended in a tie",playername);
		GameTextForAll(strings,3000,4);
		minimatchstarted=0;
		minimatchinprogress=0;
		minimatchprice=0;
	}

	return 1;
}

public UziMatchGame(){
	new deathmatchplayer;
	new Float:X1=2519.6021;
	new Float:Y1=2719.1504;
	new Float:Z1=10.3857;
	new Float:X2=2650.3533;
	new Float:Y2=2765.1250;
	new Float:Z2=10.3907;
	new Float:X3=2614.8311;
	new Float:Y3=2842.7075;
	new Float:Z3=23.8222;
	new Float:X4=2506.1750;
	new Float:Y4=2842.7075;
	new Float:Z4=10.3816;
	new Float:X5=2594.1895;
	new Float:Y5=2847.0010;
	new Float:Z5=10.3925;
	new Float:X6=2589.9390;
	new Float:Y6=2708.4341;
	new Float:Z6=10.3867;

    if(uzimatchstarted == 0){
        return 1;
	} else {
	    if(uzicountdownseconds>0 || uzicountdownseconds2 > 0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (uzimatchplayers[i] == 1)){
		    deathmatchplayer++;
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(uzimatchplayers[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to fight you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 10000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				uzimatchplayers[i]=0;
				uzimatch[0]=0;
				uzimatchstarted=0;
				DMplayer[i]=0;
				playersuzimatch=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (uzimatchplayers[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the DM since you are jailed.");
				uzimatchplayers[i]=0;
				DMplayer[i]=0;
				playersuzimatch=playersuzimatch-1;
			} else {
			    if (deathmatchplayer == 1) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X1,Y1,Z1);
					PlayerPlaySound(i,1057,X1,Y1,Z1);
					format(strings, sizeof(strings), "~w~Deathmatch started");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,2759.015,2480.2678,2865.1790,2611.7549);
					deathmatcher6[i]=1;
					uzimatchplayers[i]=0;
					uzimatchinprogress=1;
					TogglePlayerControllable(i,0);
					uzicountdownseconds2=5;
				}
				if (deathmatchplayer == 2) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X2,Y2,Z2);
					PlayerPlaySound(i,1057,X2,Y2,Z2);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,2759.015,2480.2678,2865.1790,2611.7549);
					deathmatcher6[i]=1;
					uzimatchplayers[i]=0;
					uzimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 3) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X3,Y3,Z3);
					PlayerPlaySound(i,1057,X3,Y3,Z3);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,2759.015,2480.2678,2865.1790,2611.7549);
					deathmatcher6[i]=1;
					uzimatchplayers[i]=0;
					uzimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 4) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X4,Y4,Z4);
					PlayerPlaySound(i,1057,X4,Y4,Z4);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,2759.015,2480.2678,2865.1790,2611.7549);
					deathmatcher6[i]=1;
					uzimatchplayers[i]=0;
					uzimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 5) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X5,Y5,Z5);
					PlayerPlaySound(i,1057,X5,Y5,Z5);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,2759.015,2480.2678,2865.1790,2611.7549);
					deathmatcher6[i]=1;
					uzimatchplayers[i]=0;
					uzimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
				if (deathmatchplayer == 6) {
					DisarmedPlayer[i] = 0;
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X6,Y6,Z6);
					PlayerPlaySound(i,1057,X6,Y6,Z6);
					format(strings, sizeof(strings), "~w~Deathmatch started!");
					GameTextForPlayer(i,strings,3000,4);
					SetPlayerWorldBounds(i,2759.015,2480.2678,2865.1790,2611.7549);
					deathmatcher6[i]=1;
					uzimatchplayers[i]=0;
					uzimatchinprogress=1;
					TogglePlayerControllable(i,0);
				}
			}
		}
	}
	if(playersuzimatch == 1){
		for(new k=0;k<MAX_PLAYERS;k++){
		    if(deathmatcher6[k] == 1){
				GetPlayerName(k,playername,sizeof(playername));
				format(strings, sizeof(strings), "~w~%s has won the crazy uzis deathmatch",playername);
				GameTextForAll(strings,3000,4);
				SendClientMessage(k,COLOR_SYSTEM_PM, "You won the uzigame! Congratulations.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the uzi DM.", k, uzimatchprice, GetPlayerMoney(k));
				StatGivePlayerMoney(k, uzimatchprice+100, strings);
			    SetPlayerWorldBounds(k,5000.0000,-53000.0000,5000.0000,-5000.0000);
				SpawnPlayer(k);
				uzimatchstarted=0;
				uzimatchinprogress=0;
				NoReset[k]=1;
			}
		}
	}
	new uziplayers;
	for(new m=0;m<MAX_PLAYERS;m++){
	    if(deathmatcher6[m] == 1){
			uziplayers++;
		}
	}
	if(uziplayers==0){
		format(strings, sizeof(strings), "~w~the crazy uzis deathmatch has ended in a tie",playername);
		GameTextForAll(strings,3000,4);
		uzimatchstarted=0;
		uzimatchinprogress=0;
		uzimatchprice=0;
	}

	return 1;
}

public RussianMatchGame(){
	new deathmatchplayer;
	new Float:X1=-423.7149;
	new Float:Y1=2506.6741;
	new Float:Z1=124.3047;
	new Float:A1=90.0;
	new Float:X2=-429.6586;
	new Float:Y2=2505.9395;
	new Float:Z2=124.3047;
	new Float:A2=270.0;

    if(russianmatchstarted == 0){
        return 1;
	} else {
	    if(russiancountdownseconds > 0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (russianmatchplayers[i] == 1)){
		    deathmatchplayer++;
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(russianmatchplayers[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to challange you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 100000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				russianmatchplayers[i]=0;
				russianmatch[0]=0;
				russianmatchstarted=0;
				DMplayer[i]=0;
				playersrussianmatch=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (russianmatchplayers[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the roulette since you are jailed.");
				russianmatchplayers[i]=0;
				russianmatch[i]=0;
				DMplayer[i]=0;
				playersrussianmatch=playersrussianmatch-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					DisarmedPlayer[i] = 0;
					TogglePlayerControllable(i,0);
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X1,Y1,Z1);
					SetPlayerFacingAngle(i,A1);
					SetCameraBehindPlayer(i);
					SetPlayerCameraLookAt(i,X2,Y2,Z2);
					PlayerPlaySound(i,1057,X1,Y1,Z1);
					format(strings, sizeof(strings), "~w~Russian roulette started");
					GameTextForPlayer(i,strings,3000,4);
					deathmatcher23[i]=1;
					russianmatchplayers[i]=0;
					russianmatchinprogress=1;
					russiancountdownseconds2=5;
					russianroulettecounter=0;
					RouletteCurrentPlayer=random(2);
					russianrouletteplayer0=i;
					spinning = 0;
				} else {
					DisarmedPlayer[i] = 0;
					TogglePlayerControllable(i,0);
		   			SetPlayerInterior(i, 0);
					SetPlayerPos(i,X2,Y2,Z2);
					SetPlayerFacingAngle(i,A2);
					SetCameraBehindPlayer(i);
					SetPlayerCameraLookAt(i,X1,Y1,Z1);
					PlayerPlaySound(i,1057,X2,Y2,Z2);
					format(strings, sizeof(strings), "~w~Russian roulette started!");
					GameTextForPlayer(i,strings,3000,4);
					deathmatcher23[i]=1;
					russianmatchplayers[i]=0;
					russianmatchinprogress=1;
					russianrouletteplayer1=i;
				}
			}
		}
	}

	return 1;
}

public RussianMatchGame2(){
	if(russianmatchinprogress == 1){
	    if(russiancountdownseconds2 > 0){
	        if(russiancountdownseconds2 == 5){
				for(new playerid; playerid < MAX_PLAYERS; playerid++){
					if(deathmatcher23[playerid] == 1){
					    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* The Russian roulette will start in 5 seconds.");
					    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You will see the representation of the bullet(s) in the pistols chamber:");
					    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* [_][_][_][_][O][_]");
					    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* When there is a bullet at the sixth position of the chamber when the trigger is pulled,");
					    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* the bullet will be fired and you will loose the Russian Roulette challange.");
					    SendClientMessage(playerid, COLOR_SYSTEM_PM , "* If it is not there, you will live for another round.");
					}
				}
	        }
	        russiancountdownseconds2--;
	    } else {
	        if(spinning == 0){
				russianroulettecounter++;
			    if(RouletteCurrentPlayer == 1){
			        CurrentRoulettePlayer=russianrouletteplayer0;
	                RouletteCurrentPlayer = 0;
			    } else {
			        CurrentRoulettePlayer=russianrouletteplayer1;
	                RouletteCurrentPlayer = 1;
			    }
				spincycle=random(6);
		        spintime=random(12)+spincycle;
				spinning =1;
				RussianTimer=SetTimer("RussianMatchGameText",250,1);
			} else {
			    if(spintime == spincycle){
			        KillTimer(RussianTimer);
			        spintime%=6;
			        if(RussianRouletteChoice ==1 ){
				        solution=RussianRoulette1End[spintime];
				    }
			        if(RussianRouletteChoice ==2 ){
				        solution=RussianRoulette2End[spintime];
				    }
			        if(RussianRouletteChoice ==3 ){
				        solution=RussianRoulette3End[spintime];
				    }
					if(solution == 1){
						new winner, looser;
						new winnername[MAX_PLAYER_NAME], loosername[MAX_PLAYER_NAME];
						looser=CurrentRoulettePlayer;
						if(RouletteCurrentPlayer == 0){
						    winner=russianrouletteplayer1;
						} else {
						    winner=russianrouletteplayer0;
						}
						PlayerPlaySound(looser,1148,X250[looser],Y250[looser],Z250[looser]);
						PlayerPlaySound(winner,1148,X250[winner],Y250[winner],Z250[winner]);
						GetPlayerName(winner, winnername, sizeof(winnername));
						GetPlayerName(looser, loosername, sizeof(loosername));
						format(strings, sizeof(strings), "* You blew out your brains, %s has won the Russian Roulette.", winnername);
						SendClientMessage(looser, COLOR_SYSTEM_PM, strings);
						format(strings, sizeof(strings), "* %s has blew out his or her brains, you have won the Russian Roulette and gets $50.000 .", loosername);
						SendClientMessage(winner, COLOR_SYSTEM_PM, strings);
						format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because he joined a deathmatch.", winner, 50000, GetPlayerMoney(winner));
						StatGivePlayerMoney(winner, 50000, strings);
						format(strings, sizeof(strings), "* %s has won the russian roulette.", winnername);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						RussianRouletteChoice=0;
						DMplayer[winner]=1;
						DMplayer[looser]=1;
						deathmatcher23[winner]=0;
						deathmatcher23[looser]=0;
						russianmatch[0]=0;
						russianmatch[1]=0;
						russiancountdownseconds=0;
						russiancountdownseconds2=0;
						russianmatchstarted=0;
						playersrussianmatch=0;
						russianmatchinprogress=0;
						spintime=0;
						TogglePlayerControllable(winner, 1);
						TogglePlayerControllable(looser, 1);
						NoReset[winner]=1;
						NoReset[looser]=1;
						SpawnPlayer(winner);
						SpawnPlayer(looser);
					} else {
					    new otherplayer;
					    new othername[MAX_PLAYER_NAME], currentname[MAX_PLAYER_NAME];
					    //Missed, another round
						PlayerPlaySound(CurrentRoulettePlayer,1095,X250[CurrentRoulettePlayer],Y250[CurrentRoulettePlayer],Z250[CurrentRoulettePlayer]);
						SendClientMessage(CurrentRoulettePlayer, COLOR_SYSTEM_PM, "* The chamber was empty when you fired the gun. You continue to the next round.");
						if(RouletteCurrentPlayer == 0){
						    otherplayer=russianrouletteplayer1;
						} else {
						    otherplayer=russianrouletteplayer0;
						}
						GetPlayerName(CurrentRoulettePlayer,currentname, sizeof(currentname));
						GetPlayerName(otherplayer, othername, sizeof(othername));
						format(strings, sizeof(strings), "* The gun is now in the hands of %s.", othername);
						SendClientMessage(CurrentRoulettePlayer, COLOR_SYSTEM_PM, strings);
						format(strings, sizeof(strings), "* %s survived the round, it is your turn.", currentname);
						SendClientMessage(otherplayer, COLOR_SYSTEM_PM, strings);
						spinning = 0;
					}
				}
			}
		}
	}
	return 1;
}

public RussianMatchGameText(){
	new temp;
	if(spinning == 1){
	    if(spintime > spincycle){
			temp = spincycle;
			temp%=6;
	        if(RussianRouletteChoice ==1 ){
		        SendClientMessage(CurrentRoulettePlayer, COLOR_STEELBLUE, RussianRoulette1[temp]);
				PlayerPlaySound(CurrentRoulettePlayer,1083,X250[CurrentRoulettePlayer],Y250[CurrentRoulettePlayer],Z250[CurrentRoulettePlayer]);
		    }
	        if(RussianRouletteChoice ==2 ){
		        SendClientMessage(CurrentRoulettePlayer, COLOR_STEELBLUE, RussianRoulette2[temp]);
				PlayerPlaySound(CurrentRoulettePlayer,1083,X250[CurrentRoulettePlayer],Y250[CurrentRoulettePlayer],Z250[CurrentRoulettePlayer]);
		    }
	        if(RussianRouletteChoice ==3 ){
		        SendClientMessage(CurrentRoulettePlayer, COLOR_STEELBLUE, RussianRoulette3[temp]);
				PlayerPlaySound(CurrentRoulettePlayer,1083,X250[CurrentRoulettePlayer],Y250[CurrentRoulettePlayer],Z250[CurrentRoulettePlayer]);
		    }
			spincycle++;
		}
	}
	return 1;
}

public DragRace1Game(){
	new deathmatchplayer;
	new DragRacer1[2];
	new Float:X1=1009.7179;
	new Float:Y1=2460.6667;
	new Float:Z1=12.8037;
	new Float:A1=180.0000;
	new Float:X2=1004.8646;
	new Float:Y2=2460.6667;
	new Float:Z2=12.8037;
	new Float:A2=180.0000;

    if(dragrace1started == 0){
        return 1;
	} else {
	    if(dragrace1countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace1players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace1players[i]=0;
				dragrace1[0]=0;
				dragrace1started=0;
				DMplayer[i]=0;
				playersdragrace1=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace1players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 10000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				dragrace1players[i]=0;
				dragrace1[0]=0;
				dragrace1started=0;
				DMplayer[i]=0;
				playersdragrace1=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace1players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace1players[i]=0;
				dragrace1[i]=0;
				DMplayer[i]=0;
				playersdragrace1=playersdragrace1-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					dragracer[i]=1;
					deathmatcher7[i]=1;
					dragrace1racer[0]=i;
					dragrace1players[i]=0;
					dragrace1inprogress=1;
					Teleporting[i]=1;
  					DragRacer1[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer1[0], A1);
					SetVehiclePos(DragRacer1[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher7[i]=1;
					dragracer[i]=1;
					dragrace1racer[1]=i;
					dragrace1players[i]=0;
					dragrace1inprogress=1;
					Teleporting[i]=1;
  					DragRacer1[1] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer1[1], A2);
					SetVehiclePos(DragRacer1[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 60 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRaceCountdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace1Finishing(){
	new Float:X1=997.5690;
	new Float:Y1=1212.0000;
	new Float:X2=1009.7179;
	new Float:Y2=1292.6252;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace1started == 0){
   		KillTimer(DragRace1Finish);
		return 1;
	}
	
	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace1racer[i])){
			j=dragrace1racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				PY[i]=Y250[j];
				winner++;
				winnerID=dragrace1racer[i];
			}
		}
	}
	DragRace1TimeLimit++;
	if(DragRace1TimeLimit == 240){
		DMplayer[dragrace1racer[0]]=0;
		DMplayer[dragrace1racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 1 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace1started=0;
		dragrace1inprogress=0;
		dragrace1[dragrace1racer[0]]=0;
		dragrace1players[dragrace1racer[0]]=0;
		dragrace1[dragrace1racer[1]]=0;
		dragrace1players[dragrace1racer[1]]=0;
		dragrace1racer[0]=0;
		dragrace1racer[1]=0;
		playersdragrace1=0;
		KillTimer(DragRace1Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] < PY[1]){
				winnerID=dragrace1racer[0];
			} else {
				winnerID=dragrace1racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 1",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 1! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 1.", winnerID, 25000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 20000, strings);
		DMplayer[dragrace1racer[0]]=0;
		DMplayer[dragrace1racer[1]]=0;
		playersdragrace1=0;
		dragrace1started=0;
		dragrace1inprogress=0;
		dragrace1[dragrace1racer[0]]=0;
		dragrace1players[dragrace1racer[0]]=0;
		dragrace1[dragrace1racer[1]]=0;
		dragrace1players[dragrace1racer[1]]=0;
		Fined[dragrace1racer[0]]=2;
		Fined[dragrace1racer[1]]=2;
		dragrace1racer[0]=0;
		dragrace1racer[1]=0;
		winner=0;
		KillTimer(DragRace1Finish);
	}
	return 1;
}

public DragRace2Game(){
	new deathmatchplayer;
	new DragRacer2[4];
	new Float:X1=-1879.2714;
	new Float:Y1=1081.2523;
	new Float:Z1=46.0000;
	new Float:A1=90.0000;
	new Float:X2=-1879.2714;
	new Float:Y2=1072.9692;
	new Float:Z2=46.0000;
	new Float:A2=90.0000;
	new Float:X3=-1879.2714;
	new Float:Y3=1059.2705;
	new Float:Z3=46.0000;
	new Float:A3=90.0000;
	new Float:X4=-1879.2714;
	new Float:Y4=1050.6895;
	new Float:Z4=46.0000;
	new Float:A4=90.0000;

	if(dragrace2started == 0){
        return 1;
	} else {
	    if(dragrace2countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace2players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace2players[i]=0;
				dragrace2[0]=0;
				dragrace2started=0;
				DMplayer[i]=0;
				playersdragrace2=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace2players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 10000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				dragrace2players[i]=0;
				dragrace2[0]=0;
				dragrace2started=0;
				DMplayer[i]=0;
				playersdragrace2=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace2players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace2players[i]=0;
				dragrace2[i]=0;
				DMplayer[i]=0;
				playersdragrace2=playersdragrace2-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					dragracer[i]=1;
					deathmatcher8[i]=1;
					dragrace2racer[0]=i;
					dragrace2players[i]=0;
					dragrace2inprogress=1;
					Teleporting[i]=1;
  					DragRacer2[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer2[0], A1);
					SetVehiclePos(DragRacer2[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 2) {
					deathmatcher8[i]=1;
					dragrace2racer[1]=i;
					dragrace2players[i]=0;
					dragracer[i]=1;
					dragrace2inprogress=1;
					Teleporting[i]=1;
  					DragRacer2[1] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer2[1], A2);
					SetVehiclePos(DragRacer2[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 3) {
					deathmatcher8[i]=1;
					dragrace2racer[2]=i;
					dragrace2players[i]=0;
					dragrace2inprogress=1;
					dragracer[i]=1;
					Teleporting[i]=1;
  					DragRacer2[2] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer2[2], A3);
					SetVehiclePos(DragRacer2[2], X3,Y3,Z3);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X3;
					CarYPos[i] = Y3;
					CarZPos[i] = Z3;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 3) {
					deathmatcher8[i]=1;
					dragrace2racer[3]=i;
					dragracer[i]=1;
					dragrace2players[i]=0;
					dragrace2inprogress=1;
					Teleporting[i]=1;
  					DragRacer2[3] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer2[3], A4);
					SetVehiclePos(DragRacer2[3], X4,Y4,Z4);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X4;
					CarYPos[i] = Y4;
					CarZPos[i] = Z4;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 90 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace2Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace2Finishing(){
	new Float:X1=-2696.9250;
	new Float:Y1=2065.9478;
	new Float:X2=-2664.5718;
	new Float:Y2=2183.2534;
	new Float:PY[4];
	new winner, winnerI, winnerID;
	new winnerIDs[4];
	new j;

    if(dragrace2started == 0){
   		KillTimer(DragRace2Finish);
		return 1;
	}

	for(new i=0;i<4;i++){
		if(IsPlayerConnected(dragrace2racer[i])){
            j=dragrace2racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				PY[i]=Y250[j];
				winnerID=dragrace2racer[i];
				winnerIDs[i]=dragrace2racer[i];
			}
		}
	}
	DragRace2TimeLimit++;
	if(DragRace2TimeLimit == 360){
		DMplayer[dragrace2racer[0]]=0;
		DMplayer[dragrace2racer[1]]=0;
		DMplayer[dragrace2racer[2]]=0;
		DMplayer[dragrace2racer[3]]=0;
		format(strings, sizeof(strings), "~w~The dragracers in the drag race type 2 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace2started=0;
		dragrace2inprogress=0;
		dragrace2[dragrace2racer[0]]=0;
		dragrace2players[dragrace2racer[0]]=0;
		dragrace2[dragrace2racer[1]]=0;
		dragrace2players[dragrace2racer[1]]=0;
		dragrace2[dragrace2racer[2]]=0;
		dragrace2players[dragrace2racer[2]]=0;
		dragrace2[dragrace2racer[3]]=0;
		dragrace2players[dragrace2racer[3]]=0;
		Fined[dragrace2racer[0]]=2;
		Fined[dragrace2racer[1]]=2;
		Fined[dragrace2racer[2]]=2;
		Fined[dragrace2racer[3]]=2;
		dragrace2racer[0]=0;
		dragrace2racer[1]=0;
		dragrace2racer[2]=0;
		dragrace2racer[3]=0;
		playersdragrace2=0;
		KillTimer(DragRace2Finish);
		return 1;
	}
	if(winner > 0){
		if(winner > 1){
			for (new i=0;i<4;i++){
				if(winnerIDs[i] != 0){
					if(i==0){
						winnerID=dragrace2racer[0];
						winnerI=0;
					} else {
						if(PY[winnerI] < PY[i]){
							winnerI=i;
						}
					}
				}
			}
			winnerID=dragrace2racer[winnerI];
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 2",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 2! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 2.", winnerID, dragrace2money, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, dragrace2money, strings);
		DMplayer[dragrace2racer[0]]=0;
		DMplayer[dragrace2racer[1]]=0;
		DMplayer[dragrace2racer[2]]=0;
		DMplayer[dragrace2racer[3]]=0;
		dragrace2started=0;
		dragrace2inprogress=0;
		dragrace2money=0;
		dragrace2[dragrace2racer[0]]=0;
		dragrace2players[dragrace2racer[0]]=0;
		dragrace2[dragrace2racer[1]]=0;
		dragrace2players[dragrace2racer[1]]=0;
		dragrace2[dragrace2racer[2]]=0;
		dragrace2players[dragrace2racer[2]]=0;
		dragrace2[dragrace2racer[3]]=0;
		dragrace2players[dragrace2racer[3]]=0;
		dragrace2racer[0]=0;
		dragrace2racer[1]=0;
		dragrace2racer[2]=0;
		dragrace2racer[3]=0;
		winner=0;
		KillTimer(DragRace2Finish);
	}
	return 1;
}


public DragRace3Game(){
	new deathmatchplayer;
	new DragRacer3[2];
	new Float:X1=-2264.9717;
	new Float:Y1=520.9683;
	new Float:Z1=37.2698;
	new Float:A1=0.0000;
	new Float:X2=-2257.4617;
	new Float:Y2=521.2600;
	new Float:Z2=37.3414;
	new Float:A2=0.0000;

    if(dragrace3started == 0){
        return 1;
	} else {
	    if(dragrace3countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace3players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace3players[i]=0;
				dragrace3[0]=0;
				dragrace3started=0;
				DMplayer[i]=0;
				playersdragrace3=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace3players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 250000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 20000, strings);
				dragrace3players[i]=0;
				dragrace3[0]=0;
				dragrace3started=0;
				DMplayer[i]=0;
				playersdragrace3=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace3players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace3players[i]=0;
				dragrace3[i]=0;
				DMplayer[i]=0;
				playersdragrace3=playersdragrace3-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					dragracer[i]=1;
					deathmatcher9[i]=1;
					dragrace3racer[0]=i;
					dragrace3players[i]=0;
					dragrace3inprogress=1;
					Teleporting[i]=1;
  					DragRacer3[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer3[0], A1);
					SetVehiclePos(DragRacer3[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher9[i]=1;
					dragracer[i]=1;
					dragrace3racer[1]=i;
					dragrace3players[i]=0;
					dragrace3inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					DragRacer3[1] = GetPlayerVehicleID(i);
					SetVehicleZAngle(DragRacer3[1], A2);
					SetVehiclePos(DragRacer3[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 60 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace3Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace3Finishing(){
	new Float:X1=-2279.3164;
	new Float:Y1=1163.5691;
	new Float:X2=-2244.6379;
	new Float:Y2=1275.4343;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace3started == 0){
   		KillTimer(DragRace3Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace3racer[i])){
			j=dragrace3racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				PY[i]=Y250[dragrace3racer[i]];
				winner++;
				winnerID=dragrace3racer[i];
			}
		}
	}
	DragRace3TimeLimit++;
	if(DragRace3TimeLimit == 240){
		DMplayer[dragrace3racer[0]]=0;
		DMplayer[dragrace3racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 3 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace3started=0;
		dragrace3inprogress=0;
		dragrace3[dragrace3racer[0]]=0;
		dragrace3players[dragrace3racer[0]]=0;
		dragrace3[dragrace3racer[1]]=0;
		dragrace3players[dragrace3racer[1]]=0;
		dragrace3racer[0]=0;
		dragrace3racer[1]=0;
		playersdragrace3=0;
		KillTimer(DragRace3Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] > PY[1]){
				winnerID=dragrace3racer[0];
			} else {
				winnerID=dragrace3racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 3",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 3! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 3.", winnerID, 40000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 40000, strings);
		DMplayer[dragrace3racer[0]]=0;
		DMplayer[dragrace3racer[1]]=0;
		playersdragrace3=0;
		dragrace3started=0;
		dragrace3inprogress=0;
		dragrace3[dragrace3racer[0]]=0;
		dragrace3players[dragrace3racer[0]]=0;
		dragrace3[dragrace3racer[1]]=0;
		dragrace3players[dragrace3racer[1]]=0;
		Fined[dragrace3racer[0]]=2;
		Fined[dragrace3racer[1]]=2;
		dragrace3racer[0]=0;
		dragrace3racer[1]=0;
		winner=0;
		KillTimer(DragRace3Finish);
	}
	return 1;
}

public DragRace4Game(){
	new deathmatchplayer;
	new DragRacer4[2];
	new Float:X1=679.1389;
	new Float:Y1=-491.6703;
	new Float:Z1=17.7564;
	new Float:A1=180.0000;
	new Float:X2=684.1595;
	new Float:Y2=-491.6703;
	new Float:Z2=17.7564;
	new Float:A2=180.0000;

    if(dragrace4started == 0){
        return 1;
	} else {
	    if(dragrace4countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace4players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace4players[i]=0;
				dragrace4[i]=0;
				DMplayer[i]=0;
				playersdragrace4=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace4players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 20000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 20000, strings);
				dragrace4players[i]=0;
				dragrace4[i]=0;
				dragrace4started=0;
				DMplayer[i]=0;
				playersdragrace4=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace4players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace4players[i]=0;
				dragrace4[i]=0;
				DMplayer[i]=0;
				playersdragrace4=playersdragrace4-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					dragracer[i]=1;
					deathmatcher11[i]=1;
					dragrace4racer[0]=i;
					dragrace4players[i]=0;
					dragrace4inprogress=1;
					Teleporting[i]=1;
  					DragRacer4[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer4[0], A1);
					SetVehiclePos(DragRacer4[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher11[i]=1;
					dragracer[i]=1;
					dragrace4racer[1]=i;
					dragrace4players[i]=0;
					dragrace4inprogress=1;
					Teleporting[i]=1;
  					DragRacer4[1] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer4[1], A2);
					SetVehiclePos(DragRacer4[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 60 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace4Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace4Finishing(){
	new Float:X1=784.0168;
	new Float:Y1=-1491.6017;
	new Float:X2=806.4824;
	new Float:Y2=-1416.8154;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace4started == 0){
   		KillTimer(DragRace4Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace4racer[i])){
			j=dragrace4racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				PY[i]=Y250[dragrace4racer[i]];
				winnerID=dragrace4racer[i];
			}
		}
	}
	DragRace4TimeLimit++;
	if(DragRace4TimeLimit == 240){
		DMplayer[dragrace4racer[0]]=0;
		DMplayer[dragrace4racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 4 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace4started=0;
		dragrace4inprogress=0;
		dragrace4[dragrace4racer[0]]=0;
		dragrace4players[dragrace4racer[0]]=0;
		dragrace4[dragrace4racer[1]]=0;
		dragrace4players[dragrace4racer[1]]=0;
		dragrace4racer[0]=0;
		dragrace4racer[1]=0;
		playersdragrace4=0;
		KillTimer(DragRace4Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] < PY[1]){
				winnerID=dragrace4racer[0];
			} else {
				winnerID=dragrace4racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 4",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 4! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 4.", winnerID, 40000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 40000, strings);
		DMplayer[dragrace4racer[0]]=0;
		DMplayer[dragrace4racer[1]]=0;
		playersdragrace4=0;
		dragrace4started=0;
		dragrace4inprogress=0;
		dragrace4[dragrace4racer[0]]=0;
		dragrace4players[dragrace4racer[0]]=0;
		dragrace4[dragrace4racer[1]]=0;
		dragrace4players[dragrace4racer[1]]=0;
		Fined[dragrace4racer[0]]=2;
		Fined[dragrace4racer[1]]=2;
		dragrace4racer[0]=0;
		dragrace4racer[1]=0;
		winner=0;
		KillTimer(DragRace4Finish);
	}
	return 1;
}

public DragRace5Game(){
	new deathmatchplayer;
	new DragRacer5[2];
	new Float:X1=1819.0382;
	new Float:Y1=-1930.8861;
	new Float:Z1=15.1491;
	new Float:A1=0.0000;
	new Float:X2=1824.2957;
	new Float:Y2=-1930.8861;
	new Float:Z2=15.1491;
	new Float:A2=0.0000;

    if(dragrace5started == 0){
        return 1;
	} else {
	    if(dragrace5countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace5players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace5players[i]=0;
				dragrace5[i]=0;
				DMplayer[i]=0;
				playersdragrace5=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace5players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 20000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				dragrace5players[i]=0;
				dragrace5[i]=0;
				dragrace5started=0;
				DMplayer[i]=0;
				playersdragrace5=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace5players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace5players[i]=0;
				dragrace5[i]=0;
				DMplayer[i]=0;
				playersdragrace5=playersdragrace5-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					dragracer[i]=1;
					deathmatcher13[i]=1;
					dragrace5racer[0]=i;
					dragrace5players[i]=0;
					dragrace5inprogress=1;
					Teleporting[i]=1;
  					DragRacer5[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer5[0], A1);
					SetVehiclePos(DragRacer5[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher13[i]=1;
					dragracer[i]=1;
					dragrace5racer[1]=i;
					dragrace5players[i]=0;
					dragrace5inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					DragRacer5[1] = GetPlayerVehicleID(i);
					SetVehicleZAngle(DragRacer5[1], A2);
					SetVehiclePos(DragRacer5[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 60 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace5Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace5Finishing(){
	new Float:X1=1837.8054;
	new Float:Y1=-1214.8217;
	new Float:X2=1859.3768;
	new Float:Y2=-1174.0293;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace5started == 0){
   		KillTimer(DragRace5Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace5racer[i])){
			j=dragrace5racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=dragrace5racer[i];
				PY[i]=Y250[dragrace5racer[i]];
			}
		}
	}
	DragRace5TimeLimit++;
	if(DragRace5TimeLimit == 240){
		DMplayer[dragrace5racer[0]]=0;
		DMplayer[dragrace5racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 5 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace5started=0;
		dragrace5inprogress=0;
		dragrace5[dragrace5racer[0]]=0;
		dragrace5players[dragrace5racer[0]]=0;
		dragrace5[dragrace5racer[1]]=0;
		dragrace5players[dragrace5racer[1]]=0;
		dragrace5racer[0]=0;
		dragrace5racer[1]=0;
		playersdragrace5=0;
		KillTimer(DragRace5Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] > PY[1]){
				winnerID=dragrace5racer[0];
			} else {
				winnerID=dragrace5racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 5",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 5! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 5.", winnerID, 20000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 20000, strings);
		DMplayer[dragrace5racer[0]]=0;
		DMplayer[dragrace5racer[1]]=0;
		playersdragrace5=0;
		dragrace5started=0;
		dragrace5inprogress=0;
		dragrace5[dragrace5racer[0]]=0;
		dragrace5players[dragrace5racer[0]]=0;
		dragrace5[dragrace5racer[1]]=0;
		dragrace5players[dragrace5racer[1]]=0;
		Fined[dragrace5racer[0]]=2;
		Fined[dragrace5racer[1]]=2;
		dragrace5racer[0]=0;
		dragrace5racer[1]=0;
		winner=0;
		KillTimer(DragRace5Finish);
	}
	return 1;
}

public DragRace6Game(){
	new deathmatchplayer;
	new DragRacer6[2];
	new Float:X1=1165.1360;
	new Float:Y1=-1129.1439;
	new Float:Z1=25.5042;
	new Float:A1=0.0000;
	new Float:X2=1159.9572;
	new Float:Y2=-1129.1439;
	new Float:Z2=25.5042;
	new Float:A2=0.0000;

    if(dragrace6started == 0){
        return 1;
	} else {
	    if(dragrace6countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace6players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace6players[i]=0;
				dragrace6[i]=0;
				DMplayer[i]=0;
				playersdragrace6=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace6players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 20000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 20000, strings);
				dragrace6players[i]=0;
				dragrace6[i]=0;
				dragrace6started=0;
				DMplayer[i]=0;
				playersdragrace6=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace6players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace6players[i]=0;
				dragrace6[i]=0;
				DMplayer[i]=0;
				playersdragrace6=playersdragrace6-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					dragracer[i]=1;
					deathmatcher14[i]=1;
					dragrace6racer[0]=i;
					dragrace6players[i]=0;
					dragrace6inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					DragRacer6[0] = GetPlayerVehicleID(i);
					SetVehicleZAngle(DragRacer6[0], A1);
					SetVehiclePos(DragRacer6[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher14[i]=1;
					dragracer[i]=1;
					dragrace6racer[1]=i;
					dragrace6players[i]=0;
					dragrace6inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					DragRacer6[1] = GetPlayerVehicleID(i);
					SetVehicleZAngle(DragRacer6[1], A2);
					SetVehiclePos(DragRacer6[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 60 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace6Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace6Finishing(){
	new Float:X1=1170.2024;
	new Float:Y1=-195.2028;
	new Float:X2=1198.9762;
	new Float:Y2=-151.5631;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace6started == 0){
   		KillTimer(DragRace6Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace6racer[i])){
			j=dragrace6racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=dragrace6racer[i];
				PY[i]=Y250[dragrace6racer[i]];
			}
		}
	}
	DragRace6TimeLimit++;
	if(DragRace6TimeLimit == 240){
		DMplayer[dragrace6racer[0]]=0;
		DMplayer[dragrace6racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 6 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace6started=0;
		dragrace6inprogress=0;
		dragrace6[dragrace6racer[0]]=0;
		dragrace6players[dragrace6racer[0]]=0;
		dragrace6[dragrace6racer[1]]=0;
		dragrace6players[dragrace6racer[1]]=0;
		dragrace6racer[0]=0;
		dragrace6racer[1]=0;
		playersdragrace6=0;
		KillTimer(DragRace6Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] > PY[1]){
				winnerID=dragrace6racer[0];
			} else {
				winnerID=dragrace6racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 6",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 6! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 6.", winnerID, 40000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 40000, strings);
		DMplayer[dragrace6racer[0]]=0;
		DMplayer[dragrace6racer[1]]=0;
		playersdragrace6=0;
		dragrace6started=0;
		dragrace6inprogress=0;
		dragrace6[dragrace6racer[0]]=0;
		dragrace6players[dragrace6racer[0]]=0;
		dragrace6[dragrace6racer[1]]=0;
		dragrace6players[dragrace6racer[1]]=0;
		Fined[dragrace6racer[0]]=2;
		Fined[dragrace6racer[1]]=2;
		dragrace6racer[0]=0;
		dragrace6racer[1]=0;
		winner=0;
		KillTimer(DragRace6Finish);
	}
	return 1;
}

public DragRace7Game(){
	new deathmatchplayer;
	new DragRacer7[2];
	new Float:X1=-2609.2876;
	new Float:Y1=1012.5627;
	new Float:Z1=79.9333;
	new Float:A1=180.0000;
	new Float:X2=-2604.3220;
	new Float:Y2=1012.5627;
	new Float:Z2=79.9333;
	new Float:A2=180.0000;

    if(dragrace7started == 0){
        return 1;
	} else {
	    if(dragrace7countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace7players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace7players[i]=0;
				dragrace7[i]=0;
				DMplayer[i]=0;
				playersdragrace7=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace7players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 20000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 20000, strings);
				dragrace7players[i]=0;
				dragrace7[i]=0;
				dragrace7started=0;
				DMplayer[i]=0;
				playersdragrace7=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace7players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace7players[i]=0;
				dragrace7[i]=0;
				DMplayer[i]=0;
				playersdragrace7=playersdragrace7-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher15[i]=1;
					dragracer[i]=1;
					dragrace7racer[0]=i;
					dragrace7players[i]=0;
					dragrace7inprogress=1;
					Teleporting[i]=1;
  					DragRacer7[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer7[0], A1);
					SetVehiclePos(DragRacer7[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher15[i]=1;
					dragrace7racer[1]=i;
					dragracer[i]=1;
					dragrace7players[i]=0;
					dragrace7inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					DragRacer7[1] = GetPlayerVehicleID(i);
					SetVehicleZAngle(DragRacer7[1], A2);
					SetVehiclePos(DragRacer7[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 60 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace7Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace7Finishing(){
	new Float:X1=-2638.8162;
	new Float:Y1=281.0594;
	new Float:X2=-2602.0991;
	new Float:Y2=338.3713;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace7started == 0){
   		KillTimer(DragRace7Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace7racer[i])){
			j=dragrace7racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=dragrace7racer[i];
				PY[i]=Y250[dragrace7racer[i]];
			}
		}
	}
	DragRace7TimeLimit++;
	if(DragRace7TimeLimit == 240){
		DMplayer[dragrace7racer[0]]=0;
		DMplayer[dragrace7racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 7 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace7started=0;
		dragrace7inprogress=0;
		dragrace7[dragrace7racer[0]]=0;
		dragrace7players[dragrace7racer[0]]=0;
		dragrace7[dragrace7racer[1]]=0;
		dragrace7players[dragrace7racer[1]]=0;
		dragrace7racer[0]=0;
		dragrace7racer[1]=0;
		playersdragrace7=0;
		KillTimer(DragRace7Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] < PY[1]){
				winnerID=dragrace7racer[0];
			} else {
				winnerID=dragrace7racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 7",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 7! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 7.", winnerID, 40000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 40000, strings);
		DMplayer[dragrace7racer[0]]=0;
		DMplayer[dragrace7racer[1]]=0;
		playersdragrace7=0;
		dragrace7started=0;
		dragrace7inprogress=0;
		dragrace7[dragrace7racer[0]]=0;
		dragrace7players[dragrace7racer[0]]=0;
		dragrace7[dragrace7racer[1]]=0;
		dragrace7players[dragrace7racer[1]]=0;
		Fined[dragrace7racer[0]]=2;
		Fined[dragrace7racer[1]]=2;
		dragrace7racer[0]=0;
		dragrace7racer[1]=0;
		winner=0;
		KillTimer(DragRace7Finish);
	}
	return 1;
}

public DragRace8Game(){
	new deathmatchplayer;
	new DragRacer8[2];
	new Float:X1=-2002.8276;
	new Float:Y1=-283.2482;
	new Float:Z1=37.1065;
	new Float:A1=0.0000;
	new Float:X2=-2008.1270;
	new Float:Y2=-283.2482;
	new Float:Z2=37.1065;
	new Float:A2=0.0000;

    if(dragrace8started == 0){
        return 1;
	} else {
	    if(dragrace8countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace8players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace8players[i]=0;
				dragrace8[i]=0;
				DMplayer[i]=0;
				playersdragrace8=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace8players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 20000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 20000, strings);
				dragrace8players[i]=0;
				dragrace8[i]=0;
				dragrace8started=0;
				DMplayer[i]=0;
				playersdragrace8=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace8players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace8players[i]=0;
				dragrace8[i]=0;
				DMplayer[i]=0;
				playersdragrace8=playersdragrace8-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher16[i]=1;
					dragrace8racer[0]=i;
					dragrace8players[i]=0;
					dragracer[i]=1;
					dragrace8inprogress=1;
					Teleporting[i]=1;
  					DragRacer8[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer8[0], A1);
					SetVehiclePos(DragRacer8[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher16[i]=1;
					dragrace8racer[1]=i;
					dragrace8players[i]=0;
					dragracer[i]=1;
					dragrace8inprogress=1;
					Teleporting[i]=1;
  					DragRacer8[1] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer8[1], A2);
					SetVehiclePos(DragRacer8[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 90 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace8Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace8Finishing(){
	new Float:X1=-2015.7571;
	new Float:Y1=1044.4615;
	new Float:X2=-1994.2445;
	new Float:Y2=1088.7952;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace8started == 0){
   		KillTimer(DragRace8Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace8racer[i])){
			j=dragrace8racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=dragrace8racer[i];
				PY[i]=Y250[dragrace8racer[i]];
			}
		}
	}
	DragRace8TimeLimit++;
	if(DragRace8TimeLimit == 360){
		DMplayer[dragrace8racer[0]]=0;
		DMplayer[dragrace8racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 8 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace8started=0;
		dragrace8inprogress=0;
		dragrace8[dragrace8racer[0]]=0;
		dragrace8players[dragrace8racer[0]]=0;
		dragrace8[dragrace8racer[1]]=0;
		dragrace8players[dragrace8racer[1]]=0;
		dragrace8racer[0]=0;
		dragrace8racer[1]=0;
		playersdragrace8=0;
		KillTimer(DragRace8Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] > PY[1]){
				winnerID=dragrace8racer[0];
			} else {
				winnerID=dragrace8racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 8",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 8! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 8.", winnerID, 40000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 40000, strings);
		DMplayer[dragrace8racer[0]]=0;
		DMplayer[dragrace8racer[1]]=0;
		playersdragrace8=0;
		dragrace8started=0;
		dragrace8inprogress=0;
		dragrace8[dragrace8racer[0]]=0;
		dragrace8players[dragrace8racer[0]]=0;
		dragrace8[dragrace8racer[1]]=0;
		dragrace8players[dragrace8racer[1]]=0;
		Fined[dragrace8racer[0]]=2;
		Fined[dragrace8racer[1]]=2;
		dragrace8racer[0]=0;
		dragrace8racer[1]=0;
		winner=0;
		KillTimer(DragRace8Finish);
	}
	return 1;
}

public DragRace9Game(){
	new deathmatchplayer;
	new DragRacer9[2];
	new Float:X1=-988.4318;
	new Float:Y1=-1952.6912;
	new Float:Z1=79.5779;
	new Float:A1=156.0000;
	new Float:X2=-983.7258;
	new Float:Y2=-1957.1552;
	new Float:Z2=79.5779;
	new Float:A2=156.0000;

    if(dragrace9started == 0){
        return 1;
	} else {
	    if(dragrace9countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace9players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				dragrace9players[i]=0;
				dragrace9[i]=0;
				DMplayer[i]=0;
				playersdragrace9=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(dragrace9players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 40000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 40000, strings);
				dragrace9players[i]=0;
				dragrace9[i]=0;
				dragrace9started=0;
				DMplayer[i]=0;
				playersdragrace9=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (dragrace9players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				dragrace9players[i]=0;
				dragrace9[i]=0;
				DMplayer[i]=0;
				playersdragrace9=playersdragrace9-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher17[i]=1;
					dragrace9racer[0]=i;
					dragracer[i]=1;
					dragrace9players[i]=0;
					dragrace9inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					DragRacer9[0] = GetPlayerVehicleID(i);
					SetVehicleZAngle(DragRacer9[0], A1);
					SetVehiclePos(DragRacer9[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				} else {
					deathmatcher17[i]=1;
					dragrace9racer[1]=i;
					dragrace9players[i]=0;
					dragrace9inprogress=1;
					Teleporting[i]=1;
  					DragRacer9[1] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a dragrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(DragRacer9[1], A2);
					dragracer[i]=1;
					SetVehiclePos(DragRacer9[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 150 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				DragRace9Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public DragRace9Finishing(){
	new Float:X1=-264.1964;
	new Float:Y1=-1777.6625;
	new Float:X2=-234.4587;
	new Float:Y2=-1669.7213;
	new Float:PY[2];
	new winner;
	new winnerID;
	new j;

    if(dragrace9started == 0){
   		KillTimer(DragRace9Finish);
		return 1;
	}

	for(new i=0;i<2;i++){
		if(IsPlayerConnected(dragrace9racer[i])){
			j=dragrace9racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=dragrace9racer[i];
				PY[i]=Y250[dragrace9racer[i]];
			}
		}
	}
	DragRace9TimeLimit++;
	if(DragRace9TimeLimit == 600){
		DMplayer[dragrace9racer[0]]=0;
		DMplayer[dragrace9racer[1]]=0;
		format(strings, sizeof(strings), "~w~Both dragracers in the drag race type 9 have been disqualified");
		GameTextForAll(strings,3000,4);
		dragrace9started=0;
		dragrace9inprogress=0;
		dragrace9[dragrace9racer[0]]=0;
		dragrace9players[dragrace9racer[0]]=0;
		dragrace9[dragrace9racer[1]]=0;
		dragrace9players[dragrace9racer[1]]=0;
		dragrace9racer[0]=0;
		dragrace9racer[1]=0;
		playersdragrace9=0;
		KillTimer(DragRace9Finish);
		return 1;
	}
	if(winner > 0){
		if(winner == 2){
			if(PY[0] > PY[1]){
				winnerID=dragrace9racer[0];
			} else {
				winnerID=dragrace9racer[1];
			}
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the drag race type 9",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the drag race type 9! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the drag race type 9.", winnerID, 40000, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, 80000, strings);
		DMplayer[dragrace9racer[0]]=0;
		DMplayer[dragrace9racer[1]]=0;
		playersdragrace9=0;
		dragrace9started=0;
		dragrace9inprogress=0;
		dragrace9[dragrace9racer[0]]=0;
		dragrace9players[dragrace9racer[0]]=0;
		dragrace9[dragrace9racer[1]]=0;
		dragrace9players[dragrace9racer[1]]=0;
		Fined[dragrace9racer[0]]=2;
		Fined[dragrace9racer[1]]=2;
		dragrace9racer[0]=0;
		dragrace9racer[1]=0;
		winner=0;
		KillTimer(DragRace9Finish);
	}
	return 1;
}

public SprintRace1Game(){
	new deathmatchplayer;
	new SprintRacer1[4];
	new Float:X1=-377.0689;
	new Float:Y1=-1947.6345;
	new Float:Z1=29.0000;
	new Float:A1=185.3052;
	new Float:X2=-371.4791;
	new Float:Y2=-1946.7373;
	new Float:Z2=29.0000;
	new Float:A2=186.0000;
	new Float:X3=-346.0887;
	new Float:Y3=-1955.1447;
	new Float:Z3=27.0000;
	new Float:A3=186.0000;
	new Float:X4=-340.5396;
	new Float:Y4=-1958.8878;
	new Float:Z4=27.0000;
	new Float:A4=186.0000;

	if(sprintrace1started == 0){
        return 1;
	} else {
	    if(sprintrace1countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace1players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace1players[i]=0;
				sprintrace1[0]=0;
				sprintrace1started=0;
				DMplayer[i]=0;
				playerssprintrace1=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace1players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 10000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				sprintrace1players[i]=0;
				sprintrace1[0]=0;
				sprintrace1started=0;
				DMplayer[i]=0;
				playerssprintrace1=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace1players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace1players[i]=0;
				sprintrace1[i]=0;
				DMplayer[i]=0;
				playerssprintrace1=playerssprintrace1-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher10[i]=1;
					sprintrace1racer[0]=i;
					sprintrace1players[i]=0;
					dragracer[i]=1;
					sprintrace1inprogress=1;
					Teleporting[i]=1;
  					SprintRacer1[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(SprintRacer1[0], A1);
					SetVehiclePos(SprintRacer1[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 2) {
					deathmatcher10[i]=1;
					sprintrace1racer[1]=i;
					sprintrace1players[i]=0;
					dragracer[i]=1;
					sprintrace1inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					SprintRacer1[1] = GetPlayerVehicleID(i);
					SetVehicleZAngle(SprintRacer1[1], A2);
					SetVehiclePos(SprintRacer1[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 3) {
					deathmatcher10[i]=1;
					sprintrace1racer[2]=i;
					dragracer[i]=1;
					sprintrace1players[i]=0;
					sprintrace1inprogress=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					SprintRacer1[2] = GetPlayerVehicleID(i);
					SetVehicleZAngle(SprintRacer1[2], A3);
					SetVehiclePos(SprintRacer1[2], X3,Y3,Z3);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X3;
					CarYPos[i] = Y3;
					CarZPos[i] = Z3;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 3) {
					deathmatcher10[i]=1;
					sprintrace1racer[3]=i;
					sprintrace1players[i]=0;
					sprintrace1inprogress=1;
					dragracer[i]=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					SprintRacer1[3] = GetPlayerVehicleID(i);
					SetVehicleZAngle(SprintRacer1[3], A4);
					SetVehiclePos(SprintRacer1[3], X4,Y4,Z4);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X4;
					CarYPos[i] = Y4;
					CarZPos[i] = Z4;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 180 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace1Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public SprintRace1Finishing(){
	new Float:X1=-2924.1328;
	new Float:Y1=-1178.6417;
	new Float:X2=-2879.6067;
	new Float:Y2=-916.2167;
	new Float:PY[4];
	new winner, winnerI, winnerID;
	new winnerIDs[4];
	new j;

    if(sprintrace1started == 0){
   		KillTimer(SprintRace1Finish);
		return 1;
	}

	for(new i=0;i<4;i++){
		if(IsPlayerConnected(sprintrace1racer[i])){
			j=sprintrace1racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=sprintrace1racer[i];
				winnerIDs[i]=sprintrace1racer[i];
				PY[i]=Y250[sprintrace1racer[i]];
			}
		}
	}
	SprintRace1TimeLimit++;
	if(SprintRace1TimeLimit == 720){
		DMplayer[sprintrace1racer[0]]=0;
		DMplayer[sprintrace1racer[1]]=0;
		DMplayer[sprintrace1racer[2]]=0;
		DMplayer[sprintrace1racer[3]]=0;
		format(strings, sizeof(strings), "~w~The racers in the Sprint race type 1 have been disqualified");
		GameTextForAll(strings,3000,4);
		sprintrace1started=0;
		sprintrace1inprogress=0;
		sprintrace1[sprintrace1racer[0]]=0;
		sprintrace1players[sprintrace1racer[0]]=0;
		sprintrace1[sprintrace1racer[1]]=0;
		sprintrace1players[sprintrace1racer[1]]=0;
		sprintrace1[sprintrace1racer[2]]=0;
		sprintrace1players[sprintrace1racer[2]]=0;
		sprintrace1[sprintrace1racer[3]]=0;
		sprintrace1players[sprintrace1racer[3]]=0;
		sprintrace1racer[0]=0;
		sprintrace1racer[1]=0;
		sprintrace1racer[2]=0;
		sprintrace1racer[3]=0;
		playerssprintrace1=0;
		KillTimer(SprintRace1Finish);
		return 1;
	}
	if(winner > 0){
		if(winner > 1){
			for (new i=0;i<4;i++){
				if(winnerIDs[i] != 0){
					if(i==0){
						winnerID=sprintrace1racer[0];
						winnerI=0;
					} else {
						if(PY[winnerI] < PY[i]){
							winnerI=i;
						}
					}
				}
			}
			winnerID=sprintrace1racer[winnerI];
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the sprint race type 1",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the sprint race type 1! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the Sprint race type 1.", winnerID, sprintrace1money, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, sprintrace1money, strings);
		DMplayer[sprintrace1racer[0]]=0;
		DMplayer[sprintrace1racer[1]]=0;
		DMplayer[sprintrace1racer[2]]=0;
		DMplayer[sprintrace1racer[3]]=0;
		sprintrace1started=0;
		sprintrace1inprogress=0;
		sprintrace1money=0;
		sprintrace1[sprintrace1racer[0]]=0;
		sprintrace1players[sprintrace1racer[0]]=0;
		sprintrace1[sprintrace1racer[1]]=0;
		sprintrace1players[sprintrace1racer[1]]=0;
		sprintrace1[sprintrace1racer[2]]=0;
		sprintrace1players[sprintrace1racer[2]]=0;
		sprintrace1[sprintrace1racer[3]]=0;
		sprintrace1players[sprintrace1racer[3]]=0;
		Fined[sprintrace1racer[0]]=2;
		Fined[sprintrace1racer[1]]=2;
		Fined[sprintrace1racer[2]]=2;
		Fined[sprintrace1racer[3]]=2;
		sprintrace1racer[0]=0;
		sprintrace1racer[1]=0;
		sprintrace1racer[2]=0;
		sprintrace1racer[3]=0;
		winner=0;
		KillTimer(SprintRace1Finish);
	}
	return 1;
}

public SprintRace2Game(){
	new deathmatchplayer;
	new SprintRacer2[4];
	new Float:X1=1612.5697;
	new Float:Y1=-1227.8788;
	new Float:Z1=52.0517;
	new Float:A1=175.3052;
	new Float:X2=1619.9017;
	new Float:Y2=-1229.3073;
	new Float:Z2=52.0000;
	new Float:A2=176.0000;
	new Float:X3=1628.3948;
	new Float:Y3=-1230.5404;
	new Float:Z3=52.0000;
	new Float:A3=176.0000;
	new Float:X4=1635.7826;
	new Float:Y4=-1231.3625;
	new Float:Z4=52.0000;
	new Float:A4=176.0000;

	if(sprintrace2started == 0){
        return 1;
	} else {
	    if(sprintrace2countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace2players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace2players[i]=0;
				sprintrace2[0]=0;
				sprintrace2started=0;
				DMplayer[i]=0;
				playerssprintrace2=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace2players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 10000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 10000, strings);
				sprintrace2players[i]=0;
				sprintrace2[0]=0;
				sprintrace2started=0;
				DMplayer[i]=0;
				playerssprintrace2=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace2players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace2players[i]=0;
				sprintrace2[i]=0;
				DMplayer[i]=0;
				playerssprintrace2=playerssprintrace2-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher12[i]=1;
					sprintrace2racer[0]=i;
					sprintrace2players[i]=0;
					dragracer[i]=1;
					sprintrace2inprogress=1;
					Teleporting[i]=1;
  					SprintRacer2[0] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(SprintRacer2[0], A1);
					SetVehiclePos(SprintRacer2[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 2) {
					deathmatcher12[i]=1;
					sprintrace2racer[1]=i;
					sprintrace2players[i]=0;
					sprintrace2inprogress=1;
					dragracer[i]=1;
					Teleporting[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
  					SprintRacer2[1] = GetPlayerVehicleID(i);
					SetVehicleZAngle(SprintRacer2[1], A2);
					SetVehiclePos(SprintRacer2[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 3) {
					deathmatcher12[i]=1;
					sprintrace2racer[2]=i;
					sprintrace2players[i]=0;
					sprintrace2inprogress=1;
					Teleporting[i]=1;
 					dragracer[i]=1;
 					SprintRacer2[2] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(SprintRacer2[2], A3);
					SetVehiclePos(SprintRacer2[2], X3,Y3,Z3);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X3;
					CarYPos[i] = Y3;
					CarZPos[i] = Z3;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
	   		    if (deathmatchplayer == 3) {
					deathmatcher12[i]=1;
					sprintrace2racer[3]=i;
					sprintrace2players[i]=0;
					sprintrace2inprogress=1;
					Teleporting[i]=1;
  					SprintRacer2[3] = GetPlayerVehicleID(i);
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprint race, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(SprintRacer2[3], A4);
					dragracer[i]=1;
					SetVehiclePos(SprintRacer2[3], X4,Y4,Z4);
					SetCameraBehindPlayer(i);
					CarXPos[i] = X4;
					CarYPos[i] = Y4;
					CarZPos[i] = Z4;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Race to the end of this road and cross the finishline first to win.");
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* If you don't finish within 180 seconds, you are disqualified.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace2Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public SprintRace2Finishing(){
	new Float:X1=2867.7048;
	new Float:Y1=-691.5962;
	new Float:X2=2905.1367;
	new Float:Y2=-538.2972;
	new Float:PY[4];
	new winner, winnerI, winnerID;
	new winnerIDs[4];
	new j;

    if(sprintrace2started == 0){
   		KillTimer(SprintRace2Finish);
		return 1;
	}

	for(new i=0;i<4;i++){
		if(IsPlayerConnected(sprintrace2racer[i])){
			j=sprintrace2racer[i];
			if(X250[j] >= X1 && X250[j] <= X2 && Y250[j] >= Y1 && Y250[j] <= Y2) {
				winner++;
				winnerID=sprintrace2racer[i];
				winnerIDs[i]=sprintrace2racer[i];
				PY[i]=Y250[sprintrace2racer[i]];
			}
		}
	}
	SprintRace2TimeLimit++;
	if(SprintRace2TimeLimit == 720){
		DMplayer[sprintrace2racer[0]]=0;
		DMplayer[sprintrace2racer[1]]=0;
		DMplayer[sprintrace2racer[2]]=0;
		DMplayer[sprintrace2racer[3]]=0;
		format(strings, sizeof(strings), "~w~The racers in the Sprint race type 2 have been disqualified");
		GameTextForAll(strings,3000,4);
		sprintrace2started=0;
		sprintrace2inprogress=0;
		sprintrace2[sprintrace2racer[0]]=0;
		sprintrace2players[sprintrace2racer[0]]=0;
		sprintrace2[sprintrace2racer[1]]=0;
		sprintrace2players[sprintrace2racer[1]]=0;
		sprintrace2[sprintrace2racer[2]]=0;
		sprintrace2players[sprintrace2racer[2]]=0;
		sprintrace2[sprintrace2racer[3]]=0;
		sprintrace2players[sprintrace2racer[3]]=0;
		Fined[sprintrace2racer[0]]=2;
		Fined[sprintrace2racer[1]]=2;
		Fined[sprintrace2racer[2]]=2;
		Fined[sprintrace2racer[3]]=2;
		sprintrace2racer[0]=0;
		sprintrace2racer[1]=0;
		sprintrace2racer[2]=0;
		sprintrace2racer[3]=0;
		playerssprintrace2=0;
		KillTimer(SprintRace2Finish);
		return 1;
	}
	if(winner > 0){
		if(winner > 1){
			for (new i=0;i<4;i++){
				if(winnerIDs[i] != 0){
					if(i==0){
						winnerID=sprintrace2racer[0];
						winnerI=0;
					} else {
						if(PY[winnerI] < PY[i]){
							winnerI=i;
						}
					}
				}
			}
			winnerID=sprintrace2racer[winnerI];
		}
		GetPlayerName(winnerID,playername,sizeof(playername));
		format(strings, sizeof(strings), "* %s has won the sprint race type 2",playername);
		SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
		SendClientMessage(winnerID,COLOR_SYSTEM_PM, "You won the sprint race type 2! Congratulations.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the Sprint race type 2.", winnerID, sprintrace2money, GetPlayerMoney(winnerID));
		StatGivePlayerMoney(winnerID, sprintrace2money, strings);
		DMplayer[sprintrace2racer[0]]=0;
		DMplayer[sprintrace2racer[1]]=0;
		DMplayer[sprintrace2racer[2]]=0;
		DMplayer[sprintrace2racer[3]]=0;
		sprintrace2started=0;
		sprintrace2inprogress=0;
		sprintrace2money=0;
		sprintrace2[sprintrace2racer[0]]=0;
		sprintrace2players[sprintrace2racer[0]]=0;
		sprintrace2[sprintrace2racer[1]]=0;
		sprintrace2players[sprintrace2racer[1]]=0;
		sprintrace2[sprintrace2racer[2]]=0;
		sprintrace2players[sprintrace2racer[2]]=0;
		sprintrace2[sprintrace2racer[3]]=0;
		sprintrace2players[sprintrace2racer[3]]=0;
		sprintrace2racer[0]=0;
		sprintrace2racer[1]=0;
		sprintrace2racer[2]=0;
		sprintrace2racer[3]=0;
		winner=0;
		KillTimer(SprintRace2Finish);
	}
	return 1;
}

public ResetDMArrays() {

	if(eaglematchinprogress == 0 && eaglematchstarted == 0){
		eaglematch[0] = 0;
		eaglematch[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher1[i] = 0;
			eaglematchplayers[i] = 0;
		}
		eaglecountdownseconds = 0;
		eaglecountdownseconds2 = 0;
		playerseaglematch = 0;
	}

	if(chainmatchinprogress == 0 && chainmatchstarted == 0){
		chainmatch[0] = 0;
		chainmatch[1] = 0;
		chainmatch[2] = 0;
		chainmatch[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher4[i]=0;
			chainmatchplayer[i]=0;
			chainmatchplayers[i]=0;
		}
		playerschainmatch=0;
		chaincountdownseconds=0;
		chaincountdownseconds2=0;
		chainmatchprice=0;
	}

	if(minimatchinprogress == 0 && minimatchstarted == 0){
		minimatch[0] = 0;
		minimatch[1] = 0;
		minimatch[2] = 0;
		minimatch[3] = 0;
		minimatch[4] = 0;
		minimatch[5] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher5[i]=0;
			minimatchplayer[i]=0;
			minimatchplayers[i]=0;
		}
		playersminimatch=0;
		minicountdownseconds=0;
		minicountdownseconds2=0;
		minimatchprice=0;
	}

	if(uzimatchinprogress == 0 && uzimatchstarted == 0){
		uzimatch[0] = 0;
		uzimatch[1] = 0;
		uzimatch[2] = 0;
		uzimatch[3] = 0;
		uzimatch[4] = 0;
		uzimatch[5] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher6[i]=0;
			uzimatchplayer[i]=0;
			uzimatchplayers[i]=0;
		}
		playersuzimatch=0;
		uzicountdownseconds=0;
		uzicountdownseconds2=0;
		uzimatchprice=0;
	}

	if(dragrace1inprogress == 0 && dragrace1started == 0){
		dragrace1[0] = 0;
		dragrace1[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher7[i] = 0;
			dragrace1players[i] = 0;
		}
		dragrace1countdownseconds = 0;
		playersdragrace1 = 0;
		dragrace1racer[0]=0;
		dragrace1racer[1]=0;
		KillTimer(DragRace1Finish);
	}

	if(dragrace2inprogress == 0 && dragrace2started == 0){
		dragrace2[0] = 0;
		dragrace2[1] = 0;
		dragrace2[2] = 0;
		dragrace2[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher8[i] = 0;
			dragrace2players[i] = 0;
		}
		dragrace2countdownseconds = 0;
		playersdragrace2 = 0;
		dragrace2racer[0]=0;
		dragrace2racer[1]=0;
		dragrace2racer[2]=0;
		dragrace2racer[3]=0;
		KillTimer(DragRace2Finish);
	}

	if(dragrace3inprogress == 0 && dragrace3started == 0){
		dragrace3[0] = 0;
		dragrace3[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher9[i] = 0;
			dragrace3players[i] = 0;
		}
		dragrace3countdownseconds = 0;
		playersdragrace3 = 0;
		dragrace3racer[0]=0;
		dragrace3racer[1]=0;
		KillTimer(DragRace3Finish);
	}

	if(dragrace4inprogress == 0 && dragrace4started == 0){
		dragrace4[0] = 0;
		dragrace4[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher11[i] = 0;
			dragrace4players[i] = 0;
		}
		dragrace4countdownseconds = 0;
		playersdragrace4 = 0;
		dragrace4racer[0]=0;
		dragrace4racer[1]=0;
		KillTimer(DragRace4Finish);
	}

	if(dragrace5inprogress == 0 && dragrace5started == 0){
		dragrace5[0] = 0;
		dragrace5[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher13[i] = 0;
			dragrace5players[i] = 0;
		}
		dragrace5countdownseconds = 0;
		playersdragrace5 = 0;
		dragrace5racer[0]=0;
		dragrace5racer[1]=0;
		KillTimer(DragRace5Finish);
	}

	if(dragrace6inprogress == 0 && dragrace6started == 0){
		dragrace6[0] = 0;
		dragrace6[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher14[i] = 0;
			dragrace6players[i] = 0;
		}
		dragrace6countdownseconds = 0;
		playersdragrace6 = 0;
		dragrace6racer[0]=0;
		dragrace6racer[1]=0;
		KillTimer(DragRace6Finish);
	}

	if(dragrace7inprogress == 0 && dragrace7started == 0){
		dragrace7[0] = 0;
		dragrace7[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher15[i] = 0;
			dragrace7players[i] = 0;
		}
		dragrace7countdownseconds = 0;
		playersdragrace7 = 0;
		dragrace7racer[0]=0;
		dragrace7racer[1]=0;
		KillTimer(DragRace7Finish);
	}

	if(dragrace8inprogress == 0 && dragrace8started == 0){
		dragrace8[0] = 0;
		dragrace8[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher16[i] = 0;
			dragrace8players[i] = 0;
		}
		dragrace8countdownseconds = 0;
		playersdragrace8 = 0;
		dragrace8racer[0]=0;
		dragrace8racer[1]=0;
		KillTimer(DragRace8Finish);
	}

	if(dragrace9inprogress == 0 && dragrace9started == 0){
		dragrace9[0] = 0;
		dragrace9[1] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher17[i] = 0;
			dragrace9players[i] = 0;
		}
		dragrace9countdownseconds = 0;
		playersdragrace9 = 0;
		dragrace9racer[0]=0;
		dragrace9racer[1]=0;
		KillTimer(DragRace9Finish);
	}

	if(sprintrace1inprogress == 0 && sprintrace1started == 0){
		sprintrace1[0] = 0;
		sprintrace1[1] = 0;
		sprintrace1[2] = 0;
		sprintrace1[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher10[i] = 0;
			sprintrace1players[i] = 0;
		}
		sprintrace1countdownseconds = 0;
		playerssprintrace1 = 0;
		sprintrace1racer[0]=0;
		sprintrace1racer[1]=0;
		sprintrace1racer[2]=0;
		sprintrace1racer[3]=0;
		KillTimer(SprintRace1Finish);
	}

	if(sprintrace2inprogress == 0 && sprintrace2started == 0){
		sprintrace2[0] = 0;
		sprintrace2[1] = 0;
		sprintrace2[2] = 0;
		sprintrace2[3] = 0;
		for(new i=0;i<MAX_PLAYERS;i++){
			deathmatcher12[i] = 0;
			sprintrace2players[i] = 0;
		}
		sprintrace2countdownseconds = 0;
		playerssprintrace2 = 0;
		sprintrace2racer[0]=0;
		sprintrace2racer[1]=0;
		sprintrace2racer[2]=0;
		sprintrace2racer[3]=0;
		KillTimer(SprintRace2Finish);
	}
}


public UpdateSpeed(){
	new VehicleID, vehiclemod3;
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
			GetPlayerPos(i,X250[i],Y250[i],Z250[i]);
			if(PlayerSec==0){
				Xsec[i]=X250[i];
				Ysec[i]=Y250[i];
				Zsec[i]=Z250[i];
				if(logged[i] == 0 && spawned[i] == 1 && SpawnTimeout[i] > 0){
				    SpawnTimeout[i]--;
				} else {
					if(logged[i] == 0 && Z250[i] < 400.0 && spawned[i] == 1 && SpawnTimeout[i] == 0){
		   			    KickMsg(i, -1, "Cheater detected: spawned in world without login in.");
					}
				}
				if(jailed[i] == 1 && Z250[i] < 995.0 && spawned[i] == 1) {
					if(jailoutbreak[i] == 0 ){
						SetPlayerInterior(i,10);
						SetPlayerPos(i,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
						if(jailcelcounter < 3) {
						    jailcelcounter++;
						} else {
						    jailcelcounter=0;
						}
						jailoutbreak[i] = 1;
					} else {
	 	  			    KickMsg(i, -1, "Possible cheater detected: breaking out of the jail.");
					}
				}
			}
		}
	}
	for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
	    if(IsPlayerConnected(playerid)){
			if(IsPlayerInAnyVehicle(playerid) && IsPlayerDriver(playerid)) {
				if(X250[playerid] >= adTransfender[0] && X250[playerid] <= adTransfender[2] && Y250[playerid] >= adTransfender[1] && Y250[playerid] <= adTransfender[3]&& Z250[playerid] > 999.9) {
				    TransFenderTuner[playerid] = 1;
				    VehicleID=GetPlayerVehicleID(playerid);
		    		vehiclemod3=VehicleModels[VehicleID];
				    for(new ForbidID = 0; ForbidID < sizeof(ForbiddenTuningVehicles); ForbidID++){
				        if(vehiclemod3 == ForbiddenTuningVehicles[ForbidID] && ForbiddenTuningBool[playerid] == 0){
				            ForbiddenTuningBool[playerid] = 1;
				            ForbiddenTuning(playerid,VehicleID);
				        }
				    }
				}
				if(X250[playerid] >= adArchangels[0] && X250[playerid] <= adArchangels[2] && Y250[playerid] >= adArchangels[1] && Y250[playerid] <= adArchangels[3]&& Z250[playerid] > 997.6) {
				    ArchangelsTuner[playerid] = 1;
				}
				if(X250[playerid] >= adLowrider[0] && X250[playerid] <= adLowrider[2] && Y250[playerid] >= adLowrider[1] && Y250[playerid] <= adLowrider[3]&& Z250[playerid] > 997.6) {
				    LowriderTuner[playerid] = 1;
				}
			    if(TransFenderTuner[playerid] == 1){
					if(X250[playerid] >= adTransfenderLV[0] && X250[playerid] <= adTransfenderLV[2] && Y250[playerid] >= adTransfenderLV[1] && Y250[playerid] <= adTransfenderLV[3]&& Z250[playerid] < 50.0) {
						TransFenderTuner[playerid] = 0;
						SetVehiclePos(GetPlayerVehicleID(playerid),adOutsideFenderLV[TransFenderLVCounter][0],adOutsideFenderLV[TransFenderLVCounter][1],adOutsideFenderLV[TransFenderLVCounter][2]);
						SetVehicleZAngle(GetPlayerVehicleID(playerid),90.0);
						TransFenderLVCounter++;
						if(TransFenderLVCounter == 4) TransFenderLVCounter = 0;
					}
					if(X250[playerid] >= adTransfenderSF[0] && X250[playerid] <= adTransfenderSF[2] && Y250[playerid] >= adTransfenderSF[1] && Y250[playerid] <= adTransfenderSF[3]&& Z250[playerid] < 50.0) {
						TransFenderTuner[playerid] = 0;
						SetVehiclePos(GetPlayerVehicleID(playerid),adOutsideFenderSF[TransFenderSFCounter][0],adOutsideFenderSF[TransFenderSFCounter][1],adOutsideFenderSF[TransFenderSFCounter][2]);
						SetVehicleZAngle(GetPlayerVehicleID(playerid),45.0);
						TransFenderSFCounter++;
						if(TransFenderSFCounter == 4) TransFenderSFCounter = 0;
					}
					if(X250[playerid] >= adTransfenderLS[0] && X250[playerid] <= adTransfenderLS[2] && Y250[playerid] >= adTransfenderLS[1] && Y250[playerid] <= adTransfenderLS[3]&& Z250[playerid] < 50.0) {
						TransFenderTuner[playerid] = 0;
						SetVehiclePos(GetPlayerVehicleID(playerid),adOutsideFenderLS[TransFenderLSCounter][0],adOutsideFenderLS[TransFenderLSCounter][1],adOutsideFenderLS[TransFenderLSCounter][2]);
						SetVehicleZAngle(GetPlayerVehicleID(playerid),0.0);
						TransFenderLSCounter++;
						if(TransFenderLSCounter == 4) TransFenderLSCounter = 0;
					}
				}
			    if(ArchangelsTuner[playerid] == 1){
					if(X250[playerid] >= adArchangelsOut[0] && X250[playerid] <= adArchangelsOut[2] && Y250[playerid] >= adArchangelsOut[1] && Y250[playerid] <= adArchangelsOut[3]&& Z250[playerid] < 50.0) {
						ArchangelsTuner[playerid] = 0;
						SetVehiclePos(GetPlayerVehicleID(playerid),adOutsideArchangels[ArchangelsCounter][0],adOutsideArchangels[ArchangelsCounter][1],adOutsideArchangels[ArchangelsCounter][2]);
						SetVehicleZAngle(GetPlayerVehicleID(playerid),0.0);
						ArchangelsCounter++;
						if(ArchangelsCounter == 5) ArchangelsCounter = 0;
					}
				}
			    if(LowriderTuner[playerid] == 1){
					if(X250[playerid] >= adLowriderOut[0] && X250[playerid] <= adLowriderOut[2] && Y250[playerid] >= adLowriderOut[1] && Y250[playerid] <= adLowriderOut[3]&& Z250[playerid] < 50.0) {
						LowriderTuner[playerid] = 0;
						SetVehiclePos(GetPlayerVehicleID(playerid),adOutsideLowrider[LowriderCounter][0],adOutsideLowrider[LowriderCounter][1],adOutsideLowrider[LowriderCounter][2]);
						SetVehicleZAngle(GetPlayerVehicleID(playerid),90.0);
						LowriderCounter++;
						if(LowriderCounter == 4) LowriderCounter = 0;
					}
				}
			}
	    }
	}
	PlayerSec++;
	if(PlayerSec == 4) {

		new Float:distance,value, property, temp;
	    new CurrentID, PetrolInTank, playerid, MessageColor[3];
		new DisplayMeters = 1;
		new GameTime[32];
		new PizzaTime[32];
		new TaxiTime[32];
		new RaceTimeHUD[32];
		new ExtraTime[12];
		new pizzaminutes[MAX_PLAYERS];
		new pizzaseconds[MAX_PLAYERS];
		new Taximinutes[MAX_PLAYERS];
		new Taxiseconds[MAX_PLAYERS];
		new Raceminutes[MAX_PLAYERS];
		new Raceseconds[MAX_PLAYERS];
		new VehicleClosed[16];
		new PlayerInZone;
		new Float:Ztemp;

		PlayerSec=0;
		if(GameHours < 10){
		    format(GameTime,sizeof(GameTime),"%s 0%d",DaysOfTheWeek[DayOTWeek],GameHours);
		} else {
		    format(GameTime,sizeof(GameTime),"%s %d",DaysOfTheWeek[DayOTWeek],GameHours);
		}
		if(GameMinutes < 10){
		    format(GameTime,sizeof(GameTime),"%s:0%d",GameTime,GameMinutes);
		} else {
		    format(GameTime,sizeof(GameTime),"%s:%d",GameTime,GameMinutes);
		}
		for(new i=0; i<MAX_PLAYERS; i++){
			if(IsPlayerConnected(i)){
			    if(logged[i] == 1 && spawned[i] == 1 && JailBreaker[i] == 0 && BankHacker[i] == 0){
					PlayerInZone=player_zone[i];
					if(IsPlayerInAnyVehicle(i)){
						if(Pizza[i] == 0 && TaxiDriver[i] == 0){
							if(sprintracer[i]==1 || motorracer[i]==1){
							    //HUD voor sprintrace3 - 7
								DisplayMeters = 1;
								if(countdownseconds != 0 || dragracer[i]!=0){
									DisplayMeters = 0;
								}
								playerid=i;
								temp=RaceTime[playerid];
								Raceminutes[i]=floatround((temp/600), floatround_tozero);
								temp=(temp-(Raceminutes[i]*600));
								Raceseconds[i]=floatround((temp/10), floatround_tozero);
								if(Raceseconds[i] > 9){
									format(RaceTimeHUD,sizeof(RaceTimeHUD), "%d:%d", Raceminutes[i],Raceseconds[i]);
								} else {
									format(RaceTimeHUD,sizeof(RaceTimeHUD), "%d:0%d", Raceminutes[i],Raceseconds[i]);
								}
							    CurrentID=GetPlayerVehicleID(playerid);
								VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
								if(VehicleGroup[playerid] != 10){
									PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
									if(PetrolInTank >= 75) { format(MessageColor,sizeof(MessageColor),"~b~");}
									if(PetrolInTank >= 41 && PetrolInTank <= 74) {format(MessageColor,sizeof(MessageColor),"~g~");}
									if(PetrolInTank >= 26 && PetrolInTank <= 40) {format(MessageColor,sizeof(MessageColor),"~w~");}
									if(PetrolInTank >= 11 && PetrolInTank <= 25) {format(MessageColor,sizeof(MessageColor),"~y~");}
									if(PetrolInTank <= 10) {format(MessageColor,sizeof(MessageColor),"~r~");}
								} else {
								    PetrolInTank=0;
									format(MessageColor,sizeof(MessageColor),"~p~");
								}
								distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
								value = floatround(distance * 3600);
								value=floatround(value/1000);
								PlayersSpeed[i]=value;
								if(value > 325) value=0;
								if(DisplayMeters == 1 && SpyPlayer[i]==0){
									if(SpeedMode){
										format(strings,sizeof(strings),"~b~%d MPH",floatround(value/1600));
										GameTextForPlayer(i, strings, 2000, 1);
									} else {
									    if(value == 0){
											format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~p~%s%d/%d~n~~w~%d %sKPH~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],floatround(value),HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
										}
									    if(value > 0 && value < 121){
											format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~p~%s%d/%d~n~~g~%d %sKPH~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],floatround(value),HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
										}
									    if(value > 120 && value < 141){
											format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~p~%s%d/%d~n~~y~%d %sKPH~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],floatround(value),HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
										}
									    if(value > 140 && value < 181){
											format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~p~%s%d/%d~n~~r~%d %sKPH~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],floatround(value),HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
										}
									    if(value > 180){
											format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~p~%s%d/%d~n~~p~%d %sKPH~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],floatround(value),HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
										}
										if(EnteredVehicle[i] == 1){
											EnteredVehicle[i] = 0;
											format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~p~%s%d/%d~n~~b~0 %sKPH~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
											GameTextForPlayer(i, strings, 1500, 5);
										} else {
											GameTextForPlayer(i, strings, 1500, 5);
										}
									}
								} else {
									if(DisplayMeters == 1 && speedometer[i] == 1 && speedometeron[i] == 1 && SpyPlayer[i]==0 && calculatespeed[i] == 0){
										format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~n~~p~%s%d/%d~n~~b~0 %sKPH~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],HUDColorCodes[HUDColor[i]],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
										GameTextForPlayer(i, strings, 1500, 5);
									} else {
									    if(speedometer[i] == 0 || speedometeron[i] == 0){
					           				if(DisplayMeters == 1 && FuelmeterOff[i] == 0 && SpyPlayer[playerid]==0){
												playerid=i;
											    CurrentID=GetPlayerVehicleID(playerid);
												VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
												if(VehicleGroup[playerid] != 10){
													PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
												} else {
												    PetrolInTank=0;
												}
												if(PetrolInTank >= 75) { format(MessageColor,sizeof(MessageColor),"~b~");}
												if(PetrolInTank >= 41 && PetrolInTank <= 74) {format(MessageColor,sizeof(MessageColor),"~g~");}
												if(PetrolInTank >= 26 && PetrolInTank <= 40) {format(MessageColor,sizeof(MessageColor),"~w~");}
												if(PetrolInTank >= 11 && PetrolInTank <= 25) {format(MessageColor,sizeof(MessageColor),"~y~");}
												if(PetrolInTank <= 10) {format(MessageColor,sizeof(MessageColor),"~r~");}
												format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~n~~p~%s%d/%d~n~~w~%sfuel: %s%d%%~r~%s~n~%s",HUDColorCodes[HUDColor[i]],CrossedCheckpoints[i],CheckpointsToBeCrossed[i],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],RaceTimeHUD);
												GameTextForPlayer(i, strings, 1500, 5);
											}
										}
									}
								}
							} else {
							    //Normale HUD
								DisplayMeters = 1;
								if(countdownseconds != 0 || dragracer[i]!=0){
									DisplayMeters = 0;
								}
								playerid=i;
							    CurrentID=GetPlayerVehicleID(i);
								VehicleGroup[i]=WhichVehicleGroup(CurrentID);
								if(VehicleGroup[i] != 10){
									PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
									if(PetrolInTank >= 75) { format(MessageColor,sizeof(MessageColor),"~b~");}
									if(PetrolInTank >= 41 && PetrolInTank <= 74) {format(MessageColor,sizeof(MessageColor),"~g~");}
									if(PetrolInTank >= 26 && PetrolInTank <= 40) {format(MessageColor,sizeof(MessageColor),"~w~");}
									if(PetrolInTank >= 11 && PetrolInTank <= 25) {format(MessageColor,sizeof(MessageColor),"~y~");}
									if(PetrolInTank <= 10) {format(MessageColor,sizeof(MessageColor),"~r~");}
								} else {
								    PetrolInTank=0;
									format(MessageColor,sizeof(MessageColor),"~p~");
								}
								distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
								value = floatround(distance * 3600);
								value=floatround(value/1000);
								PlayersSpeed[i]=value;
								if(IsPlayerDriver(i)){
									VehicleID=GetPlayerVehicleID(i);
								    if(autolock[i] == 1 && manuallock[VehicleID] == 0){
									    if(PlayersSpeed[i] > 20){
											for(new j=0;j<MAX_PLAYERS;j++) if(j != i) {
												SetVehicleParamsForPlayer(VehicleID, j, 0, 1);
											}
											manuallock[VehicleID] = 1;
										}
									}
								}
							 	if(manuallock[VehicleID] == 1){
							        format(VehicleClosed, sizeof(VehicleClosed), "~r~closed");
							    } else {
							        format(VehicleClosed, sizeof(VehicleClosed), "~g~open");
							    }
								if(value > VehicleMaxSpeed[VehicleGroup[i]] && !IsAdmin(i) && Teleporting[i] == 0){
								    SuspectedSpeedCheater[i]++;
								    SuspectedSpeedCheaterTimer[i]=2;
								    if(SuspectedSpeedCheater[i] > 4){
									    new SuspectedCheaterName[MAX_PLAYER_NAME];
									    new vehiclemod,vehiclemod2;
									    GetPlayerName(i,SuspectedCheaterName,sizeof(SuspectedCheaterName));
										vehiclemod=VehicleModels[VehicleID];
										vehiclemod2=vehiclemod-400;
										format(strings, sizeof(strings), "* Suspected speed cheater: %s (id %d) in %s doing %d KPH", SuspectedCheaterName, i, vehicleNames[vehiclemod2], value);
										for(new k = 0; k < MAX_PLAYERS; k++) {
									    	if(IsPlayerConnected(k) && IsAdmin(k)) {
												SendClientMessage(k, COLOR_RULES, strings);
											}
										}
										SuspectedSpeedCheater[i]=0;
									}
								} else {
								    if(SuspectedSpeedCheaterTimer[i] > 0){
								        SuspectedSpeedCheaterTimer[i]--;
								    } else {
								        if(SuspectedSpeedCheater[i] > 0){
								            SuspectedSpeedCheater[i]--;
								        }
								    }
								}
								if(VehicleGroup[i] == 5){
									if(Zsec[i] > 10.0 && value > 50){
									    SuspectedSpeedCheater[i]++;
									    SuspectedSpeedCheaterTimer[i]=2;
									    if(SuspectedSpeedCheater[i] > 4){
										    new SuspectedCheaterName[MAX_PLAYER_NAME];
										    new vehiclemod,vehiclemod2;
										    GetPlayerName(i,SuspectedCheaterName,sizeof(SuspectedCheaterName));
											vehiclemod=VehicleModels[VehicleID];
											vehiclemod2=vehiclemod-400;
											format(strings, sizeof(strings), "* Suspected flying-cheater: %s (id %d) in %s at %.0f meter doing %d KPH", SuspectedCheaterName, i, vehicleNames[vehiclemod2], Zsec[i], value);
											for(new k = 0; k < MAX_PLAYERS; k++) {
										    	if(IsPlayerConnected(k) && IsAdmin(k)) {
													SendClientMessage(k, COLOR_RULES, strings);
												}
											}
											SuspectedSpeedCheater[i]=0;
										}
									} else {
									    if(SuspectedSpeedCheaterTimer[i] > 0){
									        SuspectedSpeedCheaterTimer[i]--;
									    } else {
									        if(SuspectedSpeedCheater[i] > 0){
									            SuspectedSpeedCheater[i]--;
									        }
									    }
									}
								}
								if(value > 350) value=0;
								if(DisplayMeters == 1 && SpyPlayer[i]==0 && calculatespeed[i] == 1){
									if(SpeedMode){
										format(strings,sizeof(strings),"~b~%d MPH",floatround(value/1600));
										GameTextForPlayer(i, strings, 2000, 1);
									} else {
									    if(value == 0){
											format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~w~%d ~w~%sKPH~n~fuel: %s%d%% ~w~%sdoors: %s~n~~r~%s%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],floatround(value),HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],VehicleClosed,HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
										}
									    if(value > 0 && value < 121){
											format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~g~%d ~w~%sKPH~n~fuel: %s%d%% ~w~%sdoors: %s~n~~r~%s%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],floatround(value),HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],VehicleClosed,HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
										}
									    if(value > 120 && value < 141){
											format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~y~%d ~w~%sKPH~n~fuel: %s%d%% ~w~%sdoors: %s~n~~r~%s%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],floatround(value),HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],VehicleClosed,HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
										}
									    if(value > 140 && value < 181){
											format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~r~%d ~w~%sKPH~n~fuel: %s%d%% ~w~%sdoors: %s~n~~r~%s%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],floatround(value),HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],VehicleClosed,HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
										}
									    if(value > 180){
											format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~p~%d ~w~%sKPH~n~fuel: %s%d%% ~w~%sdoors: %s~n~~r~%s%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],floatround(value),HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],VehicleClosed,HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
										}
										if(EnteredVehicle[i] == 1){
											EnteredVehicle[i] = 0;
											format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~b~0 ~w~%sKPH~n~fuel: %s%d%% ~w~%sdoors: %s~n~~r~%s%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],HUDColorCodes[HUDColor[i]],MessageColor,PetrolInTank,HUDColorCodes[HUDColor[i]],VehicleClosed,HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
											GameTextForPlayer(i, strings, 1500, 5);
										} else {
											GameTextForPlayer(i, strings, 1500, 5);
										}
									}
								} else {
									if(DisplayMeters == 1 && SpyPlayer[i]==0 && calculatespeed[i] == 0){
										format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~n~~b~0 KPH~n~~w~fuel: %s%d%%~r~~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],MessageColor,PetrolInTank,GameTime);
										GameTextForPlayer(i, strings, 1500, 5);
									} else {
									    if(speedometer[i] == 0 || speedometeron[i] == 0){
					           				if(DisplayMeters == 1 && FuelmeterOff[i] == 0 && SpyPlayer[playerid]==0){
												playerid=i;
											    CurrentID=GetPlayerVehicleID(playerid);
												VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
												if(VehicleGroup[playerid] != 10){
													PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
												} else {
												    PetrolInTank=0;
												}
												if(PetrolInTank >= 75) { format(MessageColor,sizeof(MessageColor),"~b~");}
												if(PetrolInTank >= 41 && PetrolInTank <= 74) {format(MessageColor,sizeof(MessageColor),"~g~");}
												if(PetrolInTank >= 26 && PetrolInTank <= 40) {format(MessageColor,sizeof(MessageColor),"~w~");}
												if(PetrolInTank >= 11 && PetrolInTank <= 25) {format(MessageColor,sizeof(MessageColor),"~y~");}
												if(PetrolInTank <= 10) {format(MessageColor,sizeof(MessageColor),"~r~");}
												format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~n~~n~~w~fuel: %s%d%%~r~~n~%s",MessageColor,PetrolInTank,GameTime);
												GameTextForPlayer(i, strings, 1500, 5);
											}
										}
									}
								}
							}
							XLast[i]=Xsec[i];
							YLast[i]=Ysec[i];
							ZLast[i]=Zsec[i];
							calculatespeed[i]=1;
						} else {
							if(Pizza[i] == 1){
								//Pizza HUD
								playerid=i;
					   			pizzaminutes[playerid]=floatround((PizzaTotalTime[playerid]/60),floatround_tozero);
		   						pizzaseconds[playerid]=PizzaTotalTime[playerid] - (pizzaminutes[playerid] * 60);
								if(pizzaseconds[playerid] > 9){
									format(PizzaTime,sizeof(PizzaTime), "jobtime: %d:%d", pizzaminutes[playerid],pizzaseconds[playerid]);
								} else {
									format(PizzaTime,sizeof(PizzaTime), "jobtime: %d:0%d", pizzaminutes[playerid],pizzaseconds[playerid]);
								}
								if(PizzaExtraTime[playerid] > 0 && PizzaExtraTimeDisplay[playerid] > 0){
								    format(ExtraTime, sizeof(ExtraTime),"~p~+ %d sec",PizzaExtraTime[playerid]);
								    if(PizzaExtraTimeDisplay[playerid] == 0)PizzaExtraTime[playerid] = 0;
								    PizzaExtraTimeDisplay[playerid]--;
								}
								PizzaTotalTime[playerid]--;
		                    	if(PizzaTimer[playerid] > 0) PizzaTimer[playerid]--;
							    CurrentID=GetPlayerVehicleID(playerid);
								VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
								property=PropertyCheckpointSelection(PizzaNextCP[playerid]);
								if(VehicleGroup[playerid] != 10){
									PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
									if(PetrolInTank >= 75) { format(MessageColor,sizeof(MessageColor),"~b~");}
									if(PetrolInTank >= 41 && PetrolInTank <= 74) {format(MessageColor,sizeof(MessageColor),"~g~");}
									if(PetrolInTank >= 26 && PetrolInTank <= 40) {format(MessageColor,sizeof(MessageColor),"~w~");}
									if(PetrolInTank >= 11 && PetrolInTank <= 25) {format(MessageColor,sizeof(MessageColor),"~y~");}
									if(PetrolInTank <= 10) {format(MessageColor,sizeof(MessageColor),"~r~");}
								} else {
								    PetrolInTank=0;
									format(MessageColor,sizeof(MessageColor),"~p~");
								}
								distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
								value = floatround(distance * 3600);
								value=floatround(value/1000);
								PlayersSpeed[i]=value;

								if(value > 325) value=0;
								if(SpeedMode){
									format(strings,sizeof(strings),"~b~%d MPH",floatround(value/1600));
									GameTextForPlayer(i, strings, 2000, 1);
								} else {
								    if(value == 0){
										format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~y~Next stop:~n~%s~n~~w~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,propertyNames[property],floatround(value),MessageColor,PetrolInTank,PizzaTime);
									}
								    if(value > 0 && value < 121){
										format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~y~Next stop:~n~%s~n~~g~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,propertyNames[property],floatround(value),MessageColor,PetrolInTank,PizzaTime);
									}
								    if(value > 120 && value < 141){
										format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~y~Next stop:~n~%s~n~~y~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,propertyNames[property],floatround(value),MessageColor,PetrolInTank,PizzaTime);
									}
								    if(value > 140 && value < 181){
										format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~y~Next stop:~n~%s~n~~r~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,propertyNames[property],floatround(value),MessageColor,PetrolInTank,PizzaTime);
									}
								    if(value > 180){
										format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~y~Next stop:~n~%s~n~~p~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,propertyNames[property],floatround(value),MessageColor,PetrolInTank,PizzaTime);
									}
									if(EnteredVehicle[i] == 1){
										EnteredVehicle[i] = 0;
										format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~y~Next stop:~n~%s~n~~b~0 KPH ~w~fuel: %s%d%%~r~~n~%s",propertyNames[property],MessageColor,PetrolInTank,PizzaTime);
										GameTextForPlayer(i, strings, 1500, 5);
									} else {
										GameTextForPlayer(i, strings, 1500, 5);
									}
								}
								XLast[i]=Xsec[i];
								YLast[i]=Ysec[i];
								ZLast[i]=Zsec[i];
								calculatespeed[i]=1;
							} else {
							    if(NewTaxiDriver[i] == 0){
									//Taxi HUD
									playerid=i;
						   			Taximinutes[i]=floatround((TaxiTotalTime[i]/60),floatround_tozero);
			   						Taxiseconds[i]=TaxiTotalTime[playerid] - (Taximinutes[playerid] * 60);
									if(Taxiseconds[i] > 9){
										format(TaxiTime,sizeof(TaxiTime), "jobtime: %d:%d", Taximinutes[i],Taxiseconds[i]);
									} else {
										format(TaxiTime,sizeof(TaxiTime), "jobtime: %d:0%d", Taximinutes[i],Taxiseconds[i]);
									}
									if(TaxiExtraTime[i] > 0 && TaxiExtraTimeDisplay[playerid] > 0){
									    format(ExtraTime, sizeof(ExtraTime),"~p~+ %d sec",TaxiExtraTime[i]);
									    if(TaxiExtraTimeDisplay[i] == 0)TaxiExtraTime[i] = 0;
									    TaxiExtraTimeDisplay[i]--;
									}
									TaxiTotalTime[i]--;
			                    	if(TaxiTimer[i] > 0) TaxiTimer[i]--;
								    CurrentID=GetPlayerVehicleID(i);
									VehicleGroup[i]=WhichVehicleGroup(CurrentID);
									if(VehicleGroup[i] != 10){
										PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[i]]));
										if(PetrolInTank >= 75) { format(MessageColor,sizeof(MessageColor),"~b~");}
										if(PetrolInTank >= 41 && PetrolInTank <= 74) {format(MessageColor,sizeof(MessageColor),"~g~");}
										if(PetrolInTank >= 26 && PetrolInTank <= 40) {format(MessageColor,sizeof(MessageColor),"~w~");}
										if(PetrolInTank >= 11 && PetrolInTank <= 25) {format(MessageColor,sizeof(MessageColor),"~y~");}
										if(PetrolInTank <= 10) {format(MessageColor,sizeof(MessageColor),"~r~");}
									} else {
									    PetrolInTank=0;
										format(MessageColor,sizeof(MessageColor),"~p~");
									}
									distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
									value = floatround(distance * 3600);
									value=floatround(value/1000);
									PlayersSpeed[i]=value;

									if(value > 325) value=0;
									if(SpeedMode){
										format(strings,sizeof(strings),"~b~%d MPH",floatround(value/1600));
										GameTextForPlayer(i, strings, 2000, 1);
									} else {
									    if(value == 0){
											format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~g~Next stop:~n~%s~n~~w~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,TaxiCheckpointDescriptions[TaxiNextCP[i]],floatround(value),MessageColor,PetrolInTank,TaxiTime);
										}
									    if(value > 0 && value < 121){
											format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~g~Next stop:~n~%s~n~~g~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,TaxiCheckpointDescriptions[TaxiNextCP[i]],floatround(value),MessageColor,PetrolInTank,TaxiTime);
										}
									    if(value > 120 && value < 141){
											format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~g~Next stop:~n~%s~n~~y~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,TaxiCheckpointDescriptions[TaxiNextCP[i]],floatround(value),MessageColor,PetrolInTank,TaxiTime);
										}
									    if(value > 140 && value < 181){
											format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~g~Next stop:~n~%s~n~~r~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,TaxiCheckpointDescriptions[TaxiNextCP[i]],floatround(value),MessageColor,PetrolInTank,TaxiTime);
										}
									    if(value > 180){
											format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~g~Next stop:~n~%s~n~~p~%d KPH ~w~fuel: %s%d%%~r~~n~%s",ExtraTime,TaxiCheckpointDescriptions[TaxiNextCP[i]],floatround(value),MessageColor,PetrolInTank,TaxiTime);
										}
										if(EnteredVehicle[i] == 1){
											EnteredVehicle[i] = 0;
											format(strings,sizeof(strings),"%s~n~~n~~n~~n~~n~~g~Next stop:~n~%s~n~~b~0 KPH ~w~fuel: %s%d%%~r~~n~%s",TaxiCheckpointDescriptions[TaxiNextCP[i]],MessageColor,PetrolInTank,TaxiTime);
											GameTextForPlayer(i, strings, 1500, 5);
										} else {
											GameTextForPlayer(i, strings, 1500, 5);
										}
									}
									XLast[i]=Xsec[i];
									YLast[i]=Ysec[i];
									ZLast[i]=Zsec[i];
									calculatespeed[i]=1;
								}
							}
						}
					} else {
					    if(Pizza[i] == 0 && TaxiDriver[i] == 0){
							if(countdownseconds != 0 || dragracer[i]!=0){
								DisplayMeters = 0;
							}
						    if(isincasino[i] == 1) {
								format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~n~~n~~n~~r~%s%s",GameTextForPlayers1[i],GameTextForPlayers2[i],HUDColorCodes[HUDColor[i]],GameTime);
							} else {
								format(strings,sizeof(strings),"%s~n~%s~n~~n~~n~~n~~n~~r~%s~n~%s~n~%s",GameTextForPlayers1[i],GameTextForPlayers2[i],HUDColorCodes[HUDColor[i]],GameTime,zones[PlayerInZone][zone_name]);
							}
							if(DisplayMeters == 1){
								GameTextForPlayer(i, strings, 1000, 5);
							}
							distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
							value = floatround(distance * 3600);
							value=floatround(value/1000);
							Ztemp=floatsub(ZLast[i],4.0);
							if(value > 50 &&
							 !IsAdmin(i) &&
							 Zsec[i] >= Ztemp &&
							 Killed[i] == 0 &&
							 Chairlifter1[i] == 0 &&
							 Chairlifter2[i] == 0 &&
							 Teleporting[i] == 0){
								SuspectedSpeedCheater[i]++;
								SuspectedSpeedCheaterTimer[i]=2;
							    if(SuspectedSpeedCheater[i] > 4){
								    new SuspectedCheaterName[MAX_PLAYER_NAME];
								    GetPlayerName(i,SuspectedCheaterName,sizeof(SuspectedCheaterName));
									format(strings, sizeof(strings), "* Suspected speed cheater: %s (id %d) is doing %d KPH on foot at %0.f meters", SuspectedCheaterName, i, value, Zsec[i]);
									for(new k = 0; k < MAX_PLAYERS; k++) {
								    	if(IsPlayerConnected(k) && IsAdmin(k)) {
											SendClientMessage(k, COLOR_RULES, strings);
										}
									}
								}
							} else {
							    if(SuspectedSpeedCheaterTimer[i] > 0){
							        SuspectedSpeedCheaterTimer[i]--;
							    } else {
							        if(SuspectedSpeedCheater[i] > 0){
							            SuspectedSpeedCheater[i]--;
							        }
							    }
							}
							PlayersSpeed[i]=value;
							XLast[i]=Xsec[i];
							YLast[i]=Ysec[i];
							ZLast[i]=Zsec[i];
							calculatespeed[i]=1;
						} else {
							if(Pizza[i] != 0){
								playerid=i;
					   			pizzaminutes[playerid]=floatround((PizzaTotalTime[playerid]/60),floatround_tozero);
		   						pizzaseconds[playerid]=PizzaTotalTime[playerid] - (pizzaminutes[playerid] * 60);
								if(pizzaseconds[playerid] > 9){
									format(PizzaTime,sizeof(PizzaTime), "jobtime: %d:%d", pizzaminutes[playerid],pizzaseconds[playerid]);
								} else {
									format(PizzaTime,sizeof(PizzaTime), "jobtime: %d:0%d", pizzaminutes[playerid],pizzaseconds[playerid]);
								}
								PizzaTotalTime[playerid]--;
		                    	if(PizzaTimer[playerid] > 0) PizzaTimer[playerid]--;
								format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~n~~r~Get back on the~n~bike!~r~~n~%s",PizzaTime);
								GameTextForPlayer(i, strings, 1500, 5);
								distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
								value = floatround(distance * 3600);
								value=floatround(value/1000);
								PlayersSpeed[i]=value;
								XLast[i]=Xsec[i];
								YLast[i]=Ysec[i];
								ZLast[i]=Zsec[i];
								calculatespeed[i]=1;
							} else {
								playerid=i;
					   			Taximinutes[playerid]=floatround((TaxiTotalTime[playerid]/60),floatround_tozero);
		   						Taxiseconds[playerid]=TaxiTotalTime[playerid] - (Taximinutes[playerid] * 60);
								if(Taxiseconds[playerid] > 9){
									format(TaxiTime,sizeof(TaxiTime), "jobtime: %d:%d", Taximinutes[playerid],Taxiseconds[playerid]);
								} else {
									format(TaxiTime,sizeof(TaxiTime), "jobtime: %d:0%d", Taximinutes[playerid],Taxiseconds[playerid]);
								}
								TaxiTotalTime[playerid]--;
		                    	if(TaxiTimer[playerid] > 0) TaxiTimer[playerid]--;
								format(strings,sizeof(strings),"~n~~n~~n~~n~~n~~n~~r~Get back in the~n~car!~r~~n~%s",TaxiTime);
								GameTextForPlayer(i, strings, 1500, 5);
								distance = floatsqroot(floatpower(floatabs(floatsub(Xsec[i],XLast[i])),2)+floatpower(floatabs(floatsub(Ysec[i],YLast[i])),2)+floatpower(floatabs(floatsub(Zsec[i],ZLast[i])),2));
								value = floatround(distance * 3600);
								value=floatround(value/1000);
								PlayersSpeed[i]=value;
								XLast[i]=Xsec[i];
								YLast[i]=Ysec[i];
								ZLast[i]=Zsec[i];
								calculatespeed[i]=1;
							}
						}
					}
					if(GameTextForPlayersCounter[i] > 0){
					    GameTextForPlayersCounter[i]--;
						if(GameTextForPlayersCounter[i] == 0){
			    			format(GameTextForPlayers1[i], 36, "");
			    			format(GameTextForPlayers2[i], 36, "");
						}
					}
				}
			}
		}
		GameMinutes++;
	}
	return 1;
}

public IsPlayerDriver(playerid)
{
	if(GetPlayerState(playerid) == PLAYER_STATE_DRIVER){
	return 1;
                   	}
	return 0;
}

public MiniGunArena()
{
    new Float:adMiniGun[4] = {-1464.8488,486.5935,-1257.1309,516.0317};

	for(new i=0; i<MAX_PLAYERS; i++) {
		if (IsPlayerConnected(i)) {
		    if(isPlayerInArea(i,adMiniGun)) {
		        if(deathmatcher5[i]==0){
			        format(GameTextForPlayers1[i], 36, "~w~YOU ARE IN THE MINIGUN AREA");
			        format(GameTextForPlayers2[i], 36, "Leave now or be ~r~KILLED!");
					GameTextForPlayersCounter[i]=10;
					minigunwarning[i]++;
					if(minigunwarning[i] > 5) {
						SetPlayerHealth(i,0);
	                    format(moneyreason, sizeof(moneyreason), "* Money reset to $0 (old: $%d), because player-id %d was in the minigun area.", GetPlayerMoney(i), i);
						StatGivePlayerMoney(i, -GetPlayerMoney(i), moneyreason);
						minigunwarning[i] = 0;
					}
				}
			}
 		}
  	}

 	return 1;
}

public PetrolConsumption(){
	new Float:Consumption[MAX_PLAYERS];
	new Float:Distance;
	new CurrentID;
	new PetrolInTank;
	new removing;

	for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
      	if (IsPlayerConnected(playerid)) {
			if(IsPlayerInAnyVehicle(playerid)){
				if(IsPlayerDriver(playerid)){
				    if(Teleporting[playerid] == 0){
					    if(GetPlayerVehicleID(playerid) == CurrentVehicle[playerid]){
							CurrentID = CurrentVehicle[playerid];
					        //Player is driving in vehicle, not stepped just in
							if(Zsec[playerid] < 980.000){
								VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
								if ((Xsec[playerid] != CarXPos[playerid]) ||
								    (Ysec[playerid] != CarYPos[playerid]) ||
								    (Zsec[playerid] != CarZPos[playerid])){
				   	    			Distance = floatround(floatsqroot(floatpower(floatabs(floatsub(Xsec[playerid],CarXPos[playerid])),2)+floatpower(floatabs(floatsub(Ysec[playerid],CarYPos[playerid])),2)+floatpower(floatabs(floatsub(Zsec[playerid],CarZPos[playerid])),2)));
									Distance = Distance / 50;
									Consumption[playerid]= floatdiv(Distance,KilometerPerLiter[VehicleGroup[playerid]]);
									VehiclePetrol[CurrentID] = floatsub(VehiclePetrol[CurrentID],Consumption[playerid]);
									PetrolInTank=floatround(floatdiv(floatmul(VehiclePetrol[CurrentID],100),PetrolTank[VehicleGroup[playerid]]));
									if(PetrolInTank <= 1){
									    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* The petrol tank of your car is empty, you'll have to walk from here.");
										VehiclePetrol[CurrentID] = 0.0;
										RemovePlayerFromVehicle(playerid);
										removing = 1;
										RemovedFromCar[playerid]=1;
									}
									if(PetrolInTank > 1 && PetrolInTank <= 10){
										if(VehicleTankWarning[CurrentID] != 4){
											format(strings,sizeof(strings),"* Your petroltank is %d %% full, you really need to refill!",PetrolInTank);
										    SendClientMessage(playerid,COLOR_RED,strings);
										    VehicleTankWarning[CurrentID] = 4;
										}
									}
									if(PetrolInTank > 10 && PetrolInTank <= 25){
										if(VehicleTankWarning[CurrentID] != 3){
											format(strings,sizeof(strings),"* Your petroltank is %d %% full, start looking for a gasstation!",PetrolInTank);
										    SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
										    VehicleTankWarning[CurrentID] = 3;
										}
									}
									if(PetrolInTank > 25 && PetrolInTank <= 50){
										if(VehicleTankWarning[CurrentID] != 2){
											format(strings,sizeof(strings),"* Your petroltank is %d %% full.",PetrolInTank);
										    SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
										    VehicleTankWarning[CurrentID] = 2;
										}
									}
									if(PetrolInTank > 50 && PetrolInTank <= 75){
										if(VehicleTankWarning[CurrentID] != 1){
											format(strings,sizeof(strings),"* Your petroltank is %d %% full.",PetrolInTank);
										    SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
										    VehicleTankWarning[CurrentID] = 1;
										}
									}
									CarXPos[playerid] = Xsec[playerid];
									CarYPos[playerid] = Ysec[playerid];
									CarZPos[playerid] = Zsec[playerid];
								}
							}
						} else {
							CarXPos[playerid] = Xsec[playerid];
							CarYPos[playerid] = Ysec[playerid];
							CarZPos[playerid] = Zsec[playerid];
							CurrentVehicle[playerid] = GetPlayerVehicleID(playerid);
							CurrentID = CurrentVehicle[playerid];
							VehicleTankWarning[CurrentID]=0;
						}
					}
				}
			}
		}
	}
	
	if(removing == 1){
		for (new car=0; car<MAX_CARS;car++){
		    if (VehiclePetrol[car] == 0.0){
			    for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
			      	if (IsPlayerConnected(playerid)) {
						if(IsPlayerInVehicle(playerid,car)){
						    if(RemovedFromCar[playerid] == 1){
						        RemovedFromCar[playerid]=0;
						    } else {
							    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Your driver failed to keep the petrol tank filled. You'll have to walk from here.");
								RemovePlayerFromVehicle(playerid);
							}
						}
					}
				}
			}
		}
	}
	return 1;
}

public FillingUp(){
	new CurrentID;
	new FreeInTank;
	
	for(new playerid=0;playerid<MAX_PLAYERS;playerid++){
	    if(Tanking[playerid] == 1){
			if(IsPlayerInAnyVehicle(playerid)){
				if(IsPlayerDriver(playerid)){
			        if(IsVehicleAtStation(playerid) == 999){
					    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Sorry sir, you our fuel lines are not that long that we can reach you anymore.");
						format(strings,sizeof(strings),"* You purchased %d liters. Have a nice day.",TotalPetrol[playerid]);
					    SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
						TogglePlayerControllable(playerid,1);
						Tanking[playerid] = 0;
    		            TotalPetrol[playerid] = 0;
					} else {
						CurrentID = CurrentVehicle[playerid];
						VehicleGroup[playerid]=WhichVehicleGroup(CurrentID);
						FreeInTank=floatround(floatsub(PetrolTank[VehicleGroup[playerid]],VehiclePetrol[CurrentID]));
						if(FreeInTank < 5 ){
						    if(GetPlayerMoney(playerid) > 249) {
						        TotalPetrol[playerid]=TotalPetrol[playerid] + floatround(floatsub(PetrolTank[VehicleGroup[playerid]],VehiclePetrol[CurrentID]));
								VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[playerid]];
								PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
								format(strings, sizeof(strings), "* Money decreased by $%d (old: $%d), because player-id %d refilled his car", 50, GetPlayerMoney(playerid), playerid);
								StatGivePlayerMoney(playerid, -250, strings);
								format(strings, sizeof(strings), "* The tank of your vehicle is full, you have tanked %d liters. Have a nice day.",TotalPetrol[playerid]);
							    SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
								TogglePlayerControllable(playerid,1);
								Tanking[playerid] = 0;
			                    TotalPetrol[playerid] = 0;
							} else {
							    format(strings,sizeof(strings),"* Sorry sir, you cannot afford anymore petrol. You purchased %d liters. Have a nice day.",TotalPetrol[playerid]);
								SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
								TogglePlayerControllable(playerid,1);
								Tanking[playerid] = 0;
			                    TotalPetrol[playerid] = 0;
	        		        }
						} else {
						    if(GetPlayerMoney(playerid) > 249) {
						        TotalPetrol[playerid]=TotalPetrol[playerid] + 5;
								PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
								format(strings, sizeof(strings), "* Money decreased by $%d (old: $%d), because player-id %d refilled his car", 50, GetPlayerMoney(playerid), playerid);
								StatGivePlayerMoney(playerid, -250, strings);
								VehiclePetrol[CurrentID]=floatadd(VehiclePetrol[CurrentID],5.0);
								format(strings,sizeof(strings),"* Currenty tanked: %d liters.",TotalPetrol[playerid]);
							    SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
							} else {
								format(strings,sizeof(strings),"* Sorry sir, you cannot afford anymore petrol. You purchased %d liters. Have a nice day.",TotalPetrol[playerid]);
							    SendClientMessage(playerid,COLOR_SYSTEM_PW,strings);
								TogglePlayerControllable(playerid,1);
								Tanking[playerid] = 0;
			                    TotalPetrol[playerid] = 0;
							}
						}
					}
				} else {
				    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You need to be the driver to be able to fill the tank.");
					TogglePlayerControllable(playerid,1);
					Tanking[playerid] = 0;
   		            TotalPetrol[playerid] = 0;
				}
			} else {
			    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* You need to be in a vehicle to be able to fill the tank.");
				TogglePlayerControllable(playerid,1);
				Tanking[playerid] = 0;
 	            TotalPetrol[playerid] = 0;
			}
		}
	}
	return 1;
}

public OnPlayerEnterVehicle(playerid,vehicleid){
	if(IsPlayerConnected(playerid)){
		new checkid, delivered;
		new Float:PetrolCheck;
		CarXPos[playerid] = X250[playerid];
		CarYPos[playerid] = Y250[playerid];
		CarZPos[playerid] = Z250[playerid];

		checkid=vehicleid - 1;
		VehicleGroup[playerid]=WhichVehicleGroup(vehicleid);
		PetrolCheck=floatround(floatdiv(floatmul(VehiclePetrol[vehicleid],100),PetrolTank[VehicleGroup[playerid]]));
	    if ((X250[playerid] > CarLocation[checkid][0]) &&
	       	(X250[playerid] < CarLocation[checkid][2]) &&
	 	   	(Y250[playerid] > CarLocation[checkid][1]) &&
	   		(Y250[playerid] < CarLocation[checkid][3])){
			if(PetrolCheck < 85){
				VehiclePetrol[vehicleid]=PetrolTank[VehicleGroup[playerid]];
	    	}
	    } else {
			if(PetrolCheck < 10 ){
			    if(Fuelcan[playerid] == 1){
			        if(FuelcanContent[playerid] == 1){
			            //filling up the tank with 10 liters
					    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* The petrol tank of this car is (almost) emtpy, refilling it with the content of your fuel can.");
					    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* Note that it is only 10 liters, please visit a fuelstation rightaway!");
					    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* If you do so, also refill your fuelcan with /fillupcan .");
						VehiclePetrol[vehicleid]=floatadd(VehiclePetrol[vehicleid],10);
						FuelcanContent[playerid]=0;
			        }
				}
			}
		}
		
		if(VehiclePetrol[vehicleid] < 1.00){
		    if(Fuelcan[playerid] == 1){
			    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* The petrol tank of this car and your emergency fuel tank are empty, it can't go anywhere.");
			} else {
			    SendClientMessage(playerid,COLOR_SYSTEM_PW,"* The petrol tank of this car is empty, it can't go anywhere.");
			}
		}

		if(Pizza[playerid] == 1){
		    if(vehicleid != PizzaVehicle[playerid]){
				PizzaVehicle[playerid] = 999;
				delivered=PizzaDelivered[playerid];
				format(strings, sizeof(strings),"* You should have kept your original bike. Luigi has fired you despite delivering %d pizza's", delivered);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
				TotalPizzas(playerid, delivered);
				Pizza[playerid] = 0;
			    PizzaNextCP[playerid] = 0;
			}
		}

		if(TaxiDriver[playerid] == 1){
		    if(vehicleid != TaxiVehicle[playerid]){
				TaxiVehicle[playerid] = 999;
				delivered=TaxiDelivered[playerid];
				format(strings, sizeof(strings),"* You should have kept your original taxi. Mickey has fired you despite completing %d taxiruns", delivered);
				SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
				TotalTaxis(playerid, delivered);
				TaxiDriver[playerid] = 0;
			    TaxiNextCP[playerid] = 0;
			}
		}

		EnteredVehicle[playerid]=1;

		if(OutOfAmbu[playerid] == 1){
		    if(vehicleid <= 200 || vehicleid >= 203){
				BackInAmbuCounter[playerid] = 0;
		        format(GameTextForPlayers1[playerid], 36, "~w~Medical mission is over");
		        format(GameTextForPlayers2[playerid], 36, "");
				GameTextForPlayersCounter[playerid]=5;
				MedicalOfficerOnMission[playerid]=0;
				OutOfAmbu[playerid]=0;
				KillTimer(GetBackInAmbu[playerid]);
				if(AmbuHealing[0] == playerid) AmbuHealing[0]=999;
				if(AmbuHealing[1] == playerid) AmbuHealing[1]=999;
				return 1;
			} else {
	            if(vehicleid == 201){
					medicalreward[0]=2500;
					medicalreward[1]=2500;
					AmbuHealing[0]=playerid;
					AmbuHealing[1]=999;
					OutOfAmbu[playerid]=0;
					KillTimer(GetBackInAmbu[playerid]);
					return 1;
				}
	            if(vehicleid == 202){
					medicalreward[1]=2500;
					medicalreward[0]=2500;
					AmbuHealing[1]=playerid;
					AmbuHealing[0]=999;
					OutOfAmbu[playerid]=0;
					KillTimer(GetBackInAmbu[playerid]);
					return 1;
				}
			}
		}

		if(OutOfRanger[playerid] == 1){
		    if(vehicleid == 99){
				BackInRangerCounter[playerid] = 0;
				KillTimer(GetBackInRanger);
			} else {
				BackInRangerCounter[playerid] = 0;
		        format(GameTextForPlayers1[playerid], 36, "~w~Highway patrol mission is over");
		        format(GameTextForPlayers2[playerid], 36, "");
				GameTextForPlayersCounter[playerid]=5;
				GetPlayerName(playerid,playername,sizeof(playername));
				format(strings, sizeof(strings),"* Player %s has ended the highway patrol mission, you can roam freely over the highways without getting a ticket.",playername);
				SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
				HighwayOnMission[playerid]=0;
				OutOfRanger[playerid]=0;
				HighwayMission = 0;
				SetPlayerColor(playerid,playerColors[playerid]);
				KillTimer(GetBackInRanger);
			}
		}
		if(TaxiDriver[playerid] == 0){
			if(vehicleid == 251 || vehicleid == 252 || vehicleid == 253){
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* The taxi's are only for employees of the SA Taxi Company.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Type /taxidriver to apply for the job, or type /notaxidriver if you do not want to drive taxi's around.");
				SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You have 20 seconds to apply for the job, after that you will be kicked out of the vehicle.");
				NewTaxiDriver[playerid] = 20;
				ApplyTaxi[playerid] = 1;
			}
		}
	}
	return 1;
}

public SpyCam()
{
	for (new i=0;i<MAX_PLAYERS;i++)
	{
		if(SpyPlayer[i]==1 && IsPlayerConnected(SpyPlayerOn[i]))
		{
		new Float:SPOHP, SPONM[256], tmps1msg[256];
		GetPlayerHealth(SpyPlayerOn[i],SPOHP);
		GetPlayerName(SpyPlayerOn[i],SPONM,sizeof(SPONM));
		format(tmps1msg, sizeof(tmps1msg), "~r~Name: %s~n~~g~Health: %.0f~n~~w~/spyoff To exit spy mode",SPONM,SPOHP);
		GameTextForPlayer(i,tmps1msg,750,6);
//		GetPlayerPos(SpyPlayerOn[i],X250[i],Y250[i],Z250[i]);
		if(IsPlayerInAnyVehicle(i)){
			SetPlayerCameraPos(i,X250[SpyPlayerOn[i]]+10,Y250[SpyPlayerOn[i]]+10,Z250[SpyPlayerOn[i]]+10);
		} else {
			SetPlayerCameraPos(i,X250[SpyPlayerOn[i]]+5,Y250[SpyPlayerOn[i]]+5,Z250[SpyPlayerOn[i]]+5);
		}
		SetPlayerCameraLookAt(i,X250[SpyPlayerOn[i]],Y250[SpyPlayerOn[i]],Z250[SpyPlayerOn[i]]);
		}
	}
}

public IsPlayerInInterior(playerid){
	if(IsPlayerConnected(playerid)){
		if(Z250[playerid] > 900 && !IsPlayerInAnyVehicle(playerid)){
			return 1;
		}
	}
	return 0;
}

public WhichVehicleGroup(VehicleID){
	if(VehicleID <= 61){
	    //Bikes
	    return 0;
	}
  	if(VehicleID >= 62 && VehicleID <= 100){
  	    //Normal cars
	    return 1;
	}
  	if(VehicleID >= 101 && VehicleID <= 154){
  	    //Performance cars
  	    return 2;
  	}
  	if((VehicleID >= 155 && VehicleID <= 200) || VehicleID == 254){
  	    //Street racers
  	    return 3;
 	}
 	if(VehicleID >= 201 && VehicleID <= 218){
 	    //Busses & truckes
	    return 4;
 	}
  	if(VehicleID >= 219 && VehicleID <= 224){
  	    //Boats
  	    return 5;
  	}
  	if(VehicleID >= 225 && VehicleID <= 232){
  	    //Props
  	    return 6;
  	}
  	if(VehicleID >= 232 && VehicleID <= 246){
  	    //Heli's
  	    return 7;
  	}
  	if(VehicleID >= 247 && VehicleID <= 249){
  	    //Jets
  	    return 8;
  	}
  	if(VehicleID == 250){
  	    //Androm
  	    return 9;
 	}
  	if(VehicleID >= 251 && VehicleID <= 253){
  	    //Cab
  	    return 11;
  	}
	return 1;
}

public SpyStat()
{
	new vehiclemod, vehiclemod2, PlayerInZone;
	for (new i=0;i<MAX_PLAYERS;i++)
	{
		if(SpyPlayer[i]==1 && IsPlayerConnected(SpyPlayerOn[i]) && IsPlayerConnected(i)){
	  		new Float:SPOHP, SPONM[256], tmps1msg[256], VehicleID, spyedon;
			spyedon=SpyPlayerOn[i];
			GetPlayerHealth(spyedon,SPOHP);
			GetPlayerName(spyedon,SPONM,sizeof(SPONM));
			PlayerInZone=player_zone[spyedon];
			if(IsPlayerInAnyVehicle(spyedon)){
				if(GetPlayerState(spyedon) == PLAYER_STATE_DRIVER) {
					VehicleID=GetPlayerVehicleID(spyedon);
					vehiclemod=VehicleModels[VehicleID];
					vehiclemod2=vehiclemod-400;
					format(tmps1msg, sizeof(tmps1msg), "~r~%s ~w~Health: %.0f~n~~b~dri %s ~w~at ~y~%.0f m~n~~p~speed %d~n~%s",SPONM,SPOHP,vehicleNames[vehiclemod2],Z250[spyedon],PlayersSpeed[spyedon],zones[PlayerInZone][zone_name]);
				} else {
					VehicleID=GetPlayerVehicleID(spyedon);
					vehiclemod=VehicleModels[VehicleID];
					vehiclemod2=vehiclemod-400;
					format(tmps1msg, sizeof(tmps1msg), "~r~%s ~w~Health: %.0f~n~~g~pas %s ~w~at~y~ %.0f m~n~~p~speed %d~n~%s",SPONM,SPOHP,vehicleNames[vehiclemod2],Z250[spyedon],PlayersSpeed[spyedon],zones[PlayerInZone][zone_name]);
				}
			} else {
				format(tmps1msg, sizeof(tmps1msg), "~r~%s ~n~~w~Health: %.0f~n~~p~foot ~w~at~y~ %.0f m~n~~p~speed %d~n~%s",SPONM,SPOHP,Z250[spyedon],PlayersSpeed[spyedon],zones[PlayerInZone][zone_name]);
			}
			GameTextForPlayer(i,tmps1msg,500,4);
		}
		if(SpyPlayer[i]==1 && !IsPlayerConnected(SpyPlayerOn[i])){
			SpyPlayer[i]=0;
			KillTimer(SpyTimer[i]);
			SendClientMessage(i,COLOR_YELLOW,"Spystat has been terminated, player is no longer connected!");
		}
		if(SpyPlayer[i]==1 && !IsPlayerConnected(i)){
			SpyPlayer[i]=0;
			KillTimer(SpyTimer[i]);
		}
	}
}

public OnPlayerExitVehicle(playerid,vehicleid){
	if(MedicalOfficerOnMission[playerid] == 1){
		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You have 30 seconds to return to an ambulance, or the medical mission is over.");
		BackInAmbuCounter[playerid] = 31;
		OutOfAmbu[playerid] = 1;
		GetBackInAmbu[playerid] = SetTimer("BackInAmbu",1000,1);
	}
	if(HighwayOnMission[playerid] == 1){
		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You have 30 seconds to return to your patrol vehicle, or the highway patrol mission is over.");
		BackInRangerCounter[playerid] = 31;
		OutOfRanger[playerid] = 1;
		GetBackInRanger = SetTimer("BackInRanger",1000,1);
	}
	if(vehicleid >= 97 && vehicleid <= 100){
		SpawnedPlayer[playerid]=1;
		DisarmedPlayer[playerid] = 0;
		DisplayMessage[playerid] = 1;
		PlayerDisarmDelay[playerid] = 3;
	}
	if(Pizza[playerid] == 1){
		SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Get back on your original vehicle, or you will loose your job as courier.");
	}
	return 1;
}

public BackInAmbu(){
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
			if(MedicalOfficerOnMission[i] == 1 && OutOfAmbu[i] == 1){
				BackInAmbuCounter[i] --;
				if(BackInAmbuCounter[i] == 0){
		        	GameTextForPlayer(i,"~w~Medical mission is over",5000,4);
			        format(GameTextForPlayers1[i], 36, "~w~Medical mission is over");
			        format(GameTextForPlayers2[i], 36, "");
					GameTextForPlayersCounter[i]=5;
					GetPlayerName(i,playername,sizeof(playername));
					format(strings, sizeof(strings),"* Player %s has ended the medical mission, you can no longe call him/her.",playername);
					SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
					MedicalOfficerOnMission[i]=0;
					OutOfAmbu[i]=0;
				    KillTimer(GetBackInAmbu[i]);
				} else {
					PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
					format(strings, sizeof(strings), "~w~You have %d~n~to get back in an ambulance", BackInAmbuCounter[i]);
					GameTextForPlayer(i,strings,3000,4);
				}
			}
		}
	}
}

public BackInRanger(){
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
			if(HighwayOnMission[i] == 1 && OutOfRanger[i] == 1){
				BackInRangerCounter[i]--;
				if(BackInRangerCounter[i] < 1){
			        format(GameTextForPlayers1[i], 36, "~w~Highway patrol mission is over");
			        format(GameTextForPlayers2[i], 36, "");
					GameTextForPlayersCounter[i]=5;
					GetPlayerName(i,playername,sizeof(playername));
					format(strings, sizeof(strings),"* Player %s has ended the highway patrol mission, you can roam freely over the highways without getting a ticket.",playername);
					SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
					HighwayOnMission[i]=0;
					OutOfRanger[i]=0;
					HighwayMission = 0;
					SetPlayerColor(i,playerColors[i]);
				    KillTimer(GetBackInRanger);
				} else {
					PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
					format(strings, sizeof(strings), "~w~You have %d~n~to get back in your patrol vehicle", BackInRangerCounter[i]);
					GameTextForPlayer(i,strings,3000,4);
				}
			}
		}
	}
}

public HealingInAmbu(){
	new Float:health;
	new CurrentHealth;
	
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
	        if((IsPlayerInAnyVehicle(i)) && (GetPlayerState(i) != PLAYER_STATE_DRIVER)){
	            if(IsPlayerInVehicle(i,201)){
	                if(AmbuHealing[0]!=999){
		                TogglePlayerControllable(i,0);
						GetPlayerHealth(i, health);
						CurrentHealth=floatround(health);
						if ( CurrentHealth < 100 ){
						    if (CurrentHealth > 95 ){
						        SetPlayerHealth(i, 100.0);
								SendClientMessage(i, COLOR_SYSTEM_PM , "* Your health is at its max, you can continue your own way.");
								if(GetPlayerMoney(i) > 5000){
									format(strings, sizeof(strings), "* Money decreased by $%d (old: $%d), because player-id %d was healed by the medic", 5000, GetPlayerMoney(i), i);
									StatGivePlayerMoney(i, -5000, strings);
									SendClientMessage(i, COLOR_SYSTEM_PM , "* The medical bill is $ 5000 , which you payed automatically.");
								} else {
									SendClientMessage(i, COLOR_SYSTEM_PM , "* The medical bill is $ 5000 , which was payed by the community since you cannot afford it.");
								}
				                TogglePlayerControllable(i,1);
				                RemovePlayerFromVehicle(i);
								format(strings, sizeof(strings), "* You healed a patient, and are rewarded $ %d for the medical services.", medicalreward[0]);
								SendClientMessage(AmbuHealing[0], COLOR_SYSTEM_PM , strings);
								format(strings, sizeof(strings), "* Money increased by $%d (old: $%d), because player-id %d was in a paying-area", medicalreward[0], GetPlayerMoney(AmbuHealing[0]), AmbuHealing[0]);
								StatGivePlayerMoney(AmbuHealing[0], medicalreward[0], strings);
								if(medicalreward[0] != 100000){
									medicalreward[0]=medicalreward[0]+2500;
								} else {
									medicalreward[0]=2500;
								}
								format(strings, sizeof(strings), "* The next reward will be $ %d.", medicalreward[0]);
								SendClientMessage(AmbuHealing[0], COLOR_SYSTEM_PM , strings);
							} else {
							    SetPlayerHealth(i, health+5.0);
								format(strings, sizeof(strings), "* Your health increased to %d.", CurrentHealth);
								SendClientMessage(i, COLOR_SYSTEM_GM , strings);
							}
						} else {
							TogglePlayerControllable(i,1);
							SendClientMessage(i, COLOR_SYSTEM_PM , "* Your don't need to be healed.");
				            TogglePlayerControllable(i,1);
				            RemovePlayerFromVehicle(i);
				        }
				    } else {
						SendClientMessage(i, COLOR_SYSTEM_PM , "* Sorry, this ambulance is out of medical supplies, and it cannot take any passengers.");
			            TogglePlayerControllable(i,1);
			            RemovePlayerFromVehicle(i);
					}
				}
	            if(IsPlayerInVehicle(i,202)){
	                if(AmbuHealing[1]!=999){
		                TogglePlayerControllable(i,0);
						GetPlayerHealth(i, health);
						CurrentHealth=floatround(health);
						if ( CurrentHealth < 100 ){
						    if (CurrentHealth > 95 ){
						        SetPlayerHealth(i, 100.0);
								SendClientMessage(i, COLOR_SYSTEM_PM , "* Your health is at its max, you can continue your own way.");
								if(GetPlayerMoney(i) > 5000){
									format(strings, sizeof(strings), "* Money decreased by $%d (old: $%d), because player-id %d was healed by the medic", 5000, GetPlayerMoney(i), i);
									StatGivePlayerMoney(i, -5000, strings);
									SendClientMessage(i, COLOR_SYSTEM_PM , "* The medical bill is $ 5000 , which you payed automatically.");
								} else {
									SendClientMessage(i, COLOR_SYSTEM_PM , "* The medical bill is $ 5000 , which was payed by the community since you cannot afford it.");
								}
				                TogglePlayerControllable(i,1);
				                RemovePlayerFromVehicle(i);
								format(strings, sizeof(strings), "* You healed a patient, and are rewarded $ %d for the medical services.", medicalreward[1]);
								SendClientMessage(AmbuHealing[1], COLOR_SYSTEM_PM , strings);
								format(strings, sizeof(strings), "* Money increased by $%d (old: $%d), because player-id %d healed another player", medicalreward[1], GetPlayerMoney(AmbuHealing[1]), AmbuHealing[1]);
								StatGivePlayerMoney(AmbuHealing[1], medicalreward[1], strings);
								if(medicalreward[1] != 100000){
									medicalreward[1]=medicalreward[1]+2500;
								} else {
									medicalreward[1]=2500;
								}
								format(strings, sizeof(strings), "* The next reward will be $ %d.", medicalreward[1]);
								SendClientMessage(AmbuHealing[1], COLOR_SYSTEM_PM , strings);
							} else {
							    SetPlayerHealth(i, health+5.0);
								format(strings, sizeof(strings), "* Your health increased to %d.", CurrentHealth);
								SendClientMessage(i, COLOR_SYSTEM_GM , strings);
							}
						} else {
							TogglePlayerControllable(i,1);
							SendClientMessage(i, COLOR_SYSTEM_PM , "* Your don't need to be healed.");
				            TogglePlayerControllable(i,1);
				            RemovePlayerFromVehicle(i);
				        }
				    } else {
						SendClientMessage(i, COLOR_SYSTEM_PM , "* Sorry, this ambulance is out of medical supplies, and it cannot take any passengers.");
			            TogglePlayerControllable(i,1);
			            RemovePlayerFromVehicle(i);
					}
				}
			}
		}
	}
}

public PropertyCheckpointSelection(PlayerCheckpointToBeChecked){
	switch (PlayerCheckpointToBeChecked) {
		case CP_DRAGON:{
			return P_DRAGON;
		}
		case CP_SEXSHOP:{
			return P_SEXSHOP;
		}
		case CP_BAR:{
			return P_BAR;
		}
		case CP_CALIGULA:{
			return P_CALIGULA;
		}
		case CP_ZIP:{
			return P_ZIP;
		}
		case CP_BINCO:{
			return P_BINCO;
		}
		case CP_TATOO:{
			return P_TATOO;
		}
		case CP_BOTIQUE:{
			return P_BOTIQUE;
		}
		case CP_JIZZY:{
		    return P_JIZZY;
		}
		case CP_PIZZA:{
		    return P_PIZZA;
	 	}
		case CP_VICTIM:{
			return P_VICTIM;
		}
		case CP_STRIPCLUB:{
			return P_STRIPCLUB;
		}
		case CP_WANGCARS:{
			return P_WANGCARS;
		}
		case CP_EMERALD:{
			return P_EMERALD;
		}
		case CP_VISAGE:{
			return P_VISAGE;
		}
		case CP_SUBURBAN:{
			return P_SUBURBAN;
		}
		case CP_PROLAPS:{
			return P_PROLAPS;
		}
		case CP_BURGER:{
			return P_BURGER;
		}
		case CP_CLUCKIN:{
			return P_CLUCKIN;
		}
		case CP_CLUB:{
			return P_CLUB;
		}
		case CP_DS:{
			return P_DS;
		}
		case CP_ZOMBO:{
			return P_ZOMBO;
		}
		case CP_MADD_D:{
			return P_MADD_D;
		}
		case CP_LV_AP:{
			return P_LV_AP;
		}
		case CP_SF_HOTEL:{
			return P_SF_HOTEL;
		}
		case CP_BS_RANCH:{
			return P_BS_RANCH;
		}
		case CP_CITY_PL_D:{
			return P_CITY_PL_D;
		}
		case CP_ROCK_HOTEL:{
			return P_ROCK_HOTEL;
		}
		case CP_CLOWN_HOTEL:{
			return P_CLOWN_HOTEL;
		}
		case CP_LV_STADIUM:{
			return P_LV_STADIUM;
		}
		case CP_S_DAM:{
			return P_S_DAM;
		}
		case CP_ZERO_RC:{
			return P_ZERO_RC;
		}
		case CP_E_BASIN:{
			return P_E_BASIN;
		}
		case CP_OTTO_AUTO:{
			return P_OTTO_AUTO;
		}
		case CP_PH_LIQUOR:{
			return P_PH_LIQUOR;
		}
		case CP_LS_POLICE:{
			return P_LS_POLICE;
		}
		case CP_BETTING:{
			return P_BETTING;
		}
		case CP_SA_BANK:{
			return P_SA_BANK;
		}
		case CP_LS_MOTEL:{
			return P_LS_MOTEL;
		}
		case CP_GYM:{
			return P_GYM;
		}
		case CP_UFO_RES:{
			return P_UFO_RES;
		}
		case CP_BARTS_BEER:{
			return P_BARTS_BEER;
		}
		case CP_BANKADMIN:{ return P_BANKADMIN;}
		case CP_ISPOFFICE:{ return P_ISPOFFICE;}
		case CP_INSURANCE:{ return P_INSURANCE;}
		case CP_FOREIGN:{ return P_FOREIGN;}
		case CP_LSCARGOTRNS:{ return P_LSCARGOTRNS;}
		case CP_LSCARGOCMP:{ return P_LSCARGOCMP;}
		case CP_LSCARGODCK:{ return P_LSCARGODCK;}
		case CP_LSCONTAINER:{ return P_LSCONTAINER;}
		case CP_LSMARKET:{ return P_LSMARKET;}
		case CP_DONUT:{ return P_DONUT;}
		case CP_LEREGALLE:{ return P_LEREGALLE;}
		case CP_SEXCINEMA:{ return P_SEXCINEMA;}
		case CP_ROYAL:{ return P_ROYAL;}
		case CP_MOVIE:{ return P_MOVIE;}
		case CP_TELEVISION:{ return P_TELEVISION;}
		case CP_YACHT:{ return P_YACHT;}
		case CP_TOMCR:{ return P_TOMCR;}
		case CP_ELPACM:{ return P_ELPACM;}
		case CP_GEORGET:{ return P_GEORGET;}
		case CP_MELTRIP:{ return P_MELTRIP;}
		case CP_WHITENAG:{ return P_WHITENAG;}
		case CP_RUSSEL:{ return P_RUSSEL;}
		case CP_SYLVESTER:{ return P_SYLVESTER;}
		case CP_DITRINA:{ return P_DITRINA;}
		case CP_BILLFENCE:{ return P_BILLFENCE;}
		case CP_OPRAH:{ return P_OPRAH;}
		case CP_GARDENER:{ return P_GARDENER;}
		case CP_GLITTON:{ return P_GLITTON;}
		case CP_PIGFARM:{ return P_PIGFARM;}
		case CP_SOLARADM:{ return P_SOLARADM;}
		case CP_DILLGAS:{ return P_DILLGAS;}
		case CP_WELCOME:{ return P_WELCOME;}
		case CP_PALDICK:{ return P_PALDICK;}
		case CP_PALLIBR:{ return P_PALLIBR;}
		case CP_BIOENG:{ return P_BIOENG;}
		case CP_MONTGAS:{ return P_MONTGAS;}
		case CP_SPRUNK:{ return P_SPRUNK;}
		case CP_BARTHIDE:{ return P_BARTHIDE;}
		case CP_BLUETRUCK:{ return P_BLUETRUCK;}
		case CP_COTTON:{ return P_COTTON;}
		case CP_LOGGING:{ return P_LOGGING;}
		case CP_FLINTRANCH:{ return P_FLINTRANCH;}
		case CP_RSHAUL:{ return P_RSHAUL;}
		case CP_FALLENTREE:{ return P_FALLENTREE;}
		case CP_HUNTING:{ return P_HUNTING;}
		case CP_GRASS:{ return P_GRASS;}
		case CP_JUNKYARD:{ return P_JUNKYARD;}
		case CP_ANGELMOT:{ return P_ANGELMOT;}
		case CP_SAWMILL:{ return P_SAWMILL;}
		case CP_WHETGAS:{ return P_WHETGAS;}
		case CP_FLINTMOT:{ return P_FLINTMOT;}
		case CP_ANGELGAS:{ return P_ANGELGAS;}
		case CP_EASTCHEM:{ return P_EASTCHEM;}
		case CP_TOBACCO:{ return P_TOBACCO;}
		case CP_DIARY:{ return P_DIARY;}
		case CP_SABROAD:{ return P_SABROAD;}
		case CP_RETIRE:{ return P_RETIRE;}
		case CP_FBI:{ return P_FBI;}
		case CP_SADIRT:{ return P_SADIRT;}
		case CP_AVISPA:{ return P_AVISPA;}
		case CP_HIPPY:{ return P_HIPPY;}
		case CP_ARTMUS:{ return P_ARTMUS;}
		case CP_SFTOWN:{ return P_SFTOWN;}
		case CP_SAHOSP:{ return P_SAHOSP;}
		case CP_SAMINT:{ return P_SAMINT;}
		case CP_CITY:{ return P_CITY;}
		case CP_QUEENS:{ return P_QUEENS;}
		case CP_BIFFIN:{ return P_BIFFIN;}
		case CP_DOJO:{ return P_DOJO;}
		case CP_DRUGS:{ return P_DRUGS;}
		case CP_PUBLICTRAN:{ return P_PUBLICTRAN;}
		case CP_DEA:{ return P_DEA;}
		case CP_SFCONT:{ return P_SFCONT;}
		case CP_CARINEX:{ return P_CARINEX;}
		case CP_SOLARFAC:{ return P_SOLARFAC;}
		case CP_SFGAS:{ return P_SFGAS;}
		case CP_SUPERMARK:{ return P_SUPERMARK;}
		case CP_CIAOFFICE:{ return P_CIAOFFICE;}
		case CP_BAYYACHT:{ return P_BAYYACHT;}
		case CP_JAYDINER:{ return P_JAYDINER;}
		case CP_CIAHID:{ return P_CIAHID;}
		case CP_CARSHOTEL:{ return P_CARSHOTEL;}
		case CP_HIK69:{ return P_HIK69;}
		case CP_DRIVEINN:{ return P_DRIVEINN;}
		case CP_BOWLED:{ return P_BOWLED;}
		case CP_KINGRING:{ return P_KINGRING;}
		case CP_LOOKOUT:{ return P_LOOKOUT;}
		case CP_BIGEAR:{ return P_BIGEAR;}
		case CP_REGULAR:{ return P_REGULAR;}
		case CP_BARRGIFT:{ return P_BARRGIFT;}
		case CP_BARTEE:{ return P_BARTEE;}
		case CP_RONNIECRIB:{ return P_RONNIECRIB;}
		case CP_BAIT:{ return P_BAIT;}
		case CP_ELQUEHOTEL:{ return P_ELQUEHOTEL;}
		case CP_ELQUEGAS:{ return P_ELQUEGAS;}
		case CP_PEUBLOMUS:{ return P_PEUBLOMUS;}
		case CP_VALTEE:{ return P_VALTEE;}
		case CP_AIRMUS:{ return P_AIRMUS;}
		case CP_LASCHICK:{ return P_LASCHICK;}
		case CP_BONEGAS:{ return P_BONEGAS;}
		case CP_OILREF:{ return P_OILREF;}
		case CP_HUNTER:{ return P_HUNTER;}
		case CP_SHOOTING:{ return P_SHOOTING;}
		case CP_COLLEGE:{ return P_COLLEGE;}
		case CP_SABIKE:{ return P_SABIKE;}
		case CP_CUSTOMS:{ return P_CUSTOMS;}
		case CP_MEATFAC:{ return P_MEATFAC;}
		case CP_LVCARGO:{ return P_LVCARGO;}
		case CP_AIRCONTR:{ return P_AIRCONTR;}
		case CP_FIREBRIG:{ return P_FIREBRIG;}
		case CP_RIMSHINE:{ return P_RIMSHINE;}
		case CP_LVGAS:{ return P_LVGAS;}
		case CP_STARBUCK:{ return P_STARBUCK;}
		case CP_BEHIND:{ return P_BEHIND;}
		case CP_LVSOURV:{ return P_LVSOURV;}
		case CP_CENTER:{ return P_CENTER;}
		case CP_YELLOWBELL:{ return P_YELLOWBELL;}
		case CP_TRANSMAIN:{ return P_TRANSMAIN;}
		case CP_AZTECMOT:{ return P_AZTECMOT;}
		case CP_CONCA:{ return P_CONCA;}
		case CP_MIDEVAL:{ return P_MIDEVAL;}
		case CP_OLDCOWBOY:{ return P_OLDCOWBOY;}
		case CP_KICKHEELS:{ return P_KICKHEELS;}
		case CP_ROYALCAS:{ return P_ROYALCAS;}
		case CP_COMEALOT:{ return P_COMEALOT;}
		case CP_LVCARGOHAR:{ return P_LVCARGOHAR;}
		case CP_PHEELY:{ return P_PHEELY;}
		case CP_CHUCKUP:{ return P_CHUCKUP;}
		case CP_FINALBUILD:{ return P_FINALBUILD;}
		case CP_SHOODY:{ return P_SHOODY;}
		case CP_TAXICOMP:{ return P_TAXICOMP;}
		case CP_JOSDJCON:{ return P_JOSDJCON;}
		case CP_ADMWEAP:{ return P_ADMWEAP;}
		case CP_SECRWEAP:{ return P_SECRWEAP;}
		case CP_BEERTENDER:{ return P_BEERTENDER;}
		case CP_WARMEMORIAL:{ return P_WARMEMORIAL;}
		case CP_LSSEXXSHOP:{ return P_LSSEXXSHOP;}
		case CP_BAHAMAS:{ return P_BAHAMAS;}
		case CP_ANGELMED:{ return P_ANGELMED;}
		case CP_ELQMED:{ return P_ELQMED;}
		case CP_GOLDMINE:{ return P_GOLDMINE;}
		case CP_VORTEX:{ return P_VORTEX;}
		case CP_GASEMER:{ return P_GASEMER;}
		case CP_GASBEHCAM:{ return P_GASBEHCAM;}
		case CP_GASBESCAM:{ return P_GASBESCAM;}
		case CP_GASSPINY:{ return P_GASSPINY;}
		case CP_GASTIERRA:{ return P_GASTIERRA;}
		case CP_GASJUNIP:{ return P_GASJUNIP;}
		case CP_GASIDLE:{ return P_GASIDLE;}
		case CP_GASFLINT:{ return P_GASFLINT;}
		case CP_LSTOWN:{ return P_LSTOWN;}
		case CP_SAGOVERN:{ return P_SAGOVERN;}
		case CP_LVTOWN:{ return P_LVTOWN;}
		case CP_FORTCARSONPD:{ return P_FORTCARSONPD;}
		case CP_LIFTMECHIL:{ return P_LIFTMECHIL;}
		case CP_LUIGIS:{ return P_LUIGIS;}
		case CP_ADMINRENTCAR:{ return P_ADMINRENTCAR;}
	}
	return 999;
}

public CancelMedical(){
	new connected;
	new resetted;
	for (new i=0;i<MAX_PLAYERS;i++){
		if(MedicalOfficerOnMission[i] == 1){
	    	if(!IsPlayerConnected(i)){
				MedicalOfficerOnMission[i]=0;
				resetted = 1;
			} else {
			    connected = 1;
			}
		}
	}
	if(connected == 0 && resetted == 1){
		SendClientMessageToAll(COLOR_ADMIN_TOALL,"* The medical mission has ended, since the last medical officer left or timed out.");
	}
}

public CountDown(){
   	new minutes, seconds;
	if(countdownseconds > 0) {
	    countdownseconds--;
		if(countdownseconds == 0) {
			for(new i=0; i<MAX_PLAYERS; i++) {
			    if(IsPlayerConnected(i)) {
					PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
				}
			}
        	GameTextForAll("~w~GO",3000,4);
		} else {
   			minutes=floatround((countdownseconds/60),floatround_tozero);
   			seconds=countdownseconds - (minutes * 60);
			for(new i=0; i<MAX_PLAYERS; i++) {
			    if(IsPlayerConnected(i)) {
					PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
				}
			}
			if(seconds > 9){
				format(strings, sizeof(strings), "~w~%d:%d", minutes,seconds);
			} else {
				format(strings, sizeof(strings), "~w~%d:0%d", minutes,seconds);
			}
			GameTextForAll(strings,3000,4);
		}
	}
	for(new playerid=0; playerid<MAX_PLAYERS; playerid++){
	    if(IsPlayerConnected(playerid)){
	        if(FloodProtectionTimer[playerid] > 0 ){
	            FloodProtectionTimer[playerid]--;
			} else {
				FloodProtectionCounter[playerid]=0;
			}
		}
	}
	return 1;
}

public IsPlayerInSphere(playerid,Float:x,Float:y,Float:z,radius){
	if(GetPlayerDistanceToPointEx(playerid,x,y,z) < radius){
		return 1;
	}
	return 0;
}

public GetPlayerDistanceToPointEx(playerid,Float:x,Float:y,Float:z){
	new Float:temp;
	temp = floatsqroot(floatpower(floatabs(floatsub(x,X250[playerid])),2)+floatpower(floatabs(floatsub(y,Y250[playerid])),2)+floatpower(floatabs(floatsub(z,Z250[playerid])),2));
	return floatround(temp);
}

public BankTaxing(){
	new TaxMoney;
	new Taxdeduct;
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
	        if(bank[i] > 20000000 ){
	            TaxMoney = bank[i] - 20000000;
	            Taxdeduct = floatround(floatdiv(TaxMoney,66));
		        bank[i] = bank[i] - Taxdeduct;
       		    format(strings, sizeof(strings), "* Your savings were taxed (1.5 %% tax) and you had to pay $%d.", Taxdeduct);
				SendClientMessage(i, COLOR_SYSTEM_PW, strings);
			}
		}
	}
	return 1;
}

public BankProfit(){
	new ProfitMoney;
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
	        if(bank[i] > 0 ){
	            ProfitMoney = floatround(floatmul(bank[i],0.008));
		        bank[i] = bank[i] + ProfitMoney;
       		    format(strings, sizeof(strings), "* You received profit on your savings (0.8%%): $%d.", ProfitMoney);
				SendClientMessage(i, COLOR_SYSTEM_PW, strings);
			}
		}
	}
	return 1;
}

public ChairLifting(){
	new Float:Angle[MAX_PLAYERS];
	new counter;
	for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
		if(Chairlifter1[playerid]==1){
			if (IsPlayerConnected(playerid)){
			    counter=Chairliftcounter1[playerid];
				if(counter == 0) TogglePlayerControllable(playerid,0);
				if(counter == 20) TogglePlayerControllable(playerid,1);
				GetPlayerFacingAngle(playerid,Angle[playerid]);
				if(floatround(Angle[playerid]) >= 330){
				    Angle[playerid] = 0.0;
				} else {
				    Angle[playerid] = Angle[playerid] + 30.0;
				}
				SetPlayerPos(playerid,ChairLift1Coords[counter][0],ChairLift1Coords[counter][1],ChairLift1Coords[counter][2]);
				SetPlayerFacingAngle(playerid,Angle[playerid]);
				SetCameraBehindPlayer(playerid);
				ChairliftDelay[playerid]++;
				if(ChairliftDelay[playerid] > 6) Chairliftcounter1[playerid]++;
				if(Chairliftcounter1[playerid] == 21){
				    Chairlifter1[playerid] = 0;
				    Chairliftcounter1[playerid] = 0;
				    ChairliftDelay[playerid] = 0;
				}
			} else {
			    Chairlifter1[playerid] = 0;
			}
		}
		if(Chairlifter2[playerid]==1){
			if (IsPlayerConnected(playerid)){
			    counter=Chairliftcounter2[playerid];
				if(counter == 0) TogglePlayerControllable(playerid,0);
				if(counter == 20) TogglePlayerControllable(playerid,1);
				GetPlayerFacingAngle(playerid,Angle[playerid]);
				if(floatround(Angle[playerid]) >= 330){
				    Angle[playerid] = 0.0;
				} else {
				    Angle[playerid] = Angle[playerid] + 30.0;
				}
				if(counter ==20) Angle[playerid] = 176.0;
				SetPlayerPos(playerid,ChairLift2Coords[counter][0],ChairLift2Coords[counter][1],ChairLift2Coords[counter][2]);
				SetPlayerFacingAngle(playerid,Angle[playerid]);
				SetCameraBehindPlayer(playerid);
				ChairliftDelay[playerid]++;
				if(ChairliftDelay[playerid] > 6) Chairliftcounter2[playerid]++;
				if(Chairliftcounter2[playerid] == 21){
				    Chairlifter2[playerid] = 0;
				    Chairliftcounter2[playerid] = 0;
				    ChairliftDelay[playerid] = 0;
				}
			} else {
			    Chairlifter2[playerid] = 0;
			}
		}
	}
	return 1;
}

public PizzaNextCheckpoint(playerid) {
	new randomloc, reward, property, delivered;
	
	if(!IsPlayerInAnyVehicle(playerid)){
		PizzaVehicle[playerid] = 999;
		delivered=PizzaDelivered[playerid];
		format(strings, sizeof(strings),"* Luigi told you over and over: no walking! He has fired you despite delivering %d pizza's", delivered);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		TotalPizzas(playerid, delivered);
		Pizza[playerid] = 0;
	    PizzaNextCP[playerid] = 0;
		DisablePlayerCheckpoint(playerid);
	}
	if(!IsPlayerDriver(playerid)){
		PizzaVehicle[playerid] = 999;
		delivered=PizzaDelivered[playerid];
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You should have driven yourself. Luigi doesn't like his pizza's being delivered by a passenger");
		format(strings, sizeof(strings), "* He has fired you despite delivering %d pizza's", delivered);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		TotalPizzas(playerid, delivered);
		Pizza[playerid] = 0;
	    PizzaNextCP[playerid] = 0;
		DisablePlayerCheckpoint(playerid);
	}
	TogglePlayerControllable(playerid,0);
	if(PizzaNextCP[playerid] == CP_LUIGIS){
		DisablePlayerCheckpoint(playerid);
		randomloc=random(sizeof(PizzaLocs));
		PizzaNextCP[playerid] = PizzaLocs[randomloc];
		SetPlayerCheckpoint(playerid,checkpoints[PizzaNextCP[playerid]][0],checkpoints[PizzaNextCP[playerid]][1],checkpoints[PizzaNextCP[playerid]][2],2.0);
		property=PropertyCheckpointSelection(PizzaNextCP[playerid]);
		PizzaExtraTime[playerid]=PizzaTimer[playerid];
		PizzaTimer[playerid] = PizzaTimes[randomloc];
		PizzaReturnTrip[playerid] = PizzaTimer[playerid];
		format(strings, sizeof(strings), "* Next location: %s . Type /pizzastop to end the mission.", propertyNames[property]);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
	} else {
		PizzaDelivered[playerid]++;
		DisablePlayerCheckpoint(playerid);
		property=PropertyCheckpointSelection(PizzaNextCP[playerid]);
		reward = 950 + floatround(PizzaTimer[playerid]*5) + floatround(PizzaDelivered[playerid] * 50);
		format(strings, sizeof(strings),"* Pizza number %d delivered at %s, you received $%d.", PizzaDelivered[playerid], propertyNames[property], reward);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Return to Luigi's at once to pick up another order.");
		format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player delivered a pizza.", playerid, reward, GetPlayerMoney(playerid));
		StatGivePlayerMoney(playerid, reward, strings);
		PizzaNextCP[playerid] = CP_LUIGIS;
		SetPlayerCheckpoint(playerid,checkpoints[PizzaNextCP[playerid]][0],checkpoints[PizzaNextCP[playerid]][1],checkpoints[PizzaNextCP[playerid]][2], 2.0);
		PizzaExtraTime[playerid]=PizzaTimer[playerid];
		if(PizzaExtraTime[playerid] > 0){
		    PizzaExtraTimeDisplay[playerid]=3;
			if(PizzaDelivered[playerid] <= 10) PizzaExtraTime[playerid]=PizzaExtraTime[playerid] + 10;
			if(PizzaDelivered[playerid] <= 20 && PizzaDelivered[playerid] > 10) PizzaExtraTime[playerid]=PizzaExtraTime[playerid] + 5;
			if(PizzaDelivered[playerid] <= 40 && PizzaDelivered[playerid] > 30) PizzaExtraTime[playerid]=PizzaExtraTime[playerid] - 5;
			if(PizzaDelivered[playerid] > 40) PizzaExtraTime[playerid]=PizzaExtraTime[playerid] - 10;
		}
		PizzaTimer[playerid] = PizzaReturnTrip[playerid];
	}
	PizzaTotalTime[playerid]=PizzaTotalTime[playerid] + PizzaExtraTime[playerid] + PizzaTimer[playerid] + 2;
	PizzaWaitTime[playerid]=3;
	return 1;
}

public TotalPizzas(playerid, delivered){
	GetPlayerName(playerid, playername, sizeof(playername));
	if(delivered > GlobalPizza1){
		format(strings, sizeof(strings),"* %s has reached the nr 1 spot in the pizza-leaderboard by delivering %d pizza's", playername, delivered);
		SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
		GlobalPizza5=GlobalPizza4;
		format(GlobalPizzaMan5, sizeof(GlobalPizzaMan5), "%s", GlobalPizzaMan4);
		GlobalPizza4=GlobalPizza3;
		format(GlobalPizzaMan4, sizeof(GlobalPizzaMan4), "%s", GlobalPizzaMan3);
		GlobalPizza3=GlobalPizza2;
		format(GlobalPizzaMan3, sizeof(GlobalPizzaMan3), "%s", GlobalPizzaMan2);
		GlobalPizza2=GlobalPizza1;
		format(GlobalPizzaMan2, sizeof(GlobalPizzaMan2), "%s", GlobalPizzaMan1);
		GlobalPizza1=delivered;
		format(GlobalPizzaMan1, sizeof(GlobalPizzaMan1), "%s", playername);
	} else {
		if(delivered > GlobalPizza2){
			format(strings, sizeof(strings),"* %s has reached the nr 2 spot in the pizza-leaderboard by delivering %d pizza's", playername, delivered);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
			GlobalPizza5=GlobalPizza4;
			format(GlobalPizzaMan5, sizeof(GlobalPizzaMan5), "%s", GlobalPizzaMan4);
			GlobalPizza4=GlobalPizza3;
			format(GlobalPizzaMan4, sizeof(GlobalPizzaMan4), "%s", GlobalPizzaMan3);
			GlobalPizza3=GlobalPizza2;
			format(GlobalPizzaMan3, sizeof(GlobalPizzaMan3), "%s", GlobalPizzaMan2);
			GlobalPizza2=delivered;
			format(GlobalPizzaMan2, sizeof(GlobalPizzaMan2), "%s", playername);
		} else {
			if(delivered > GlobalPizza3){
				format(strings, sizeof(strings),"* %s has reached the nr 3 spot in the pizza-leaderboard by delivering %d pizza's", playername, delivered);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				GlobalPizza5=GlobalPizza4;
				format(GlobalPizzaMan5, sizeof(GlobalPizzaMan5), "%s", GlobalPizzaMan4);
				GlobalPizza4=GlobalPizza3;
				format(GlobalPizzaMan4, sizeof(GlobalPizzaMan4), "%s", GlobalPizzaMan3);
				GlobalPizza3=delivered;
				format(GlobalPizzaMan3, sizeof(GlobalPizzaMan3), "%s", playername);
			} else {
				if(delivered > GlobalPizza4){
					format(strings, sizeof(strings),"* %s has reached the nr 4 spot in the pizza-leaderboard by delivering %d pizza's", playername, delivered);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					GlobalPizza5=GlobalPizza4;
					format(GlobalPizzaMan5, sizeof(GlobalPizzaMan5), "%s", GlobalPizzaMan4);
					GlobalPizza4=delivered;
					format(GlobalPizzaMan4, sizeof(GlobalPizzaMan4), "%s", playername);
				} else {
					if(delivered > GlobalPizza4){
						format(strings, sizeof(strings),"* %s has reached the nr 5 spot in the pizza-leaderboard by delivering %d pizza's", playername, delivered);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						GlobalPizza5=delivered;
						format(GlobalPizzaMan5, sizeof(GlobalPizzaMan5), "%s", playername);
					} else {
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Sorry, your score was not enough to reach the pizza-leaderboard.");
					}
				}
			}
		}
	}
	PizzaBoardUpdate();
	return 1;
}

public TaxiNextCheckpoint(playerid) {
	new randomloc, reward, delivered, property;

	DisablePlayerCheckpoint(playerid);
	if(!IsPlayerInAnyVehicle(playerid)){
		TaxiVehicle[playerid] = 999;
		delivered=TaxiDelivered[playerid];
		format(strings, sizeof(strings),"* Mickey is angry on you for loosing your taxi and has fired you. You have made %d taxirides", delivered);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		TotalTaxis(playerid, delivered);
		TaxiDriver[playerid] = 0;
	    TaxiNextCP[playerid] = 0;
	}
	if(!IsPlayerDriver(playerid)){
		TaxiVehicle[playerid] = 999;
		delivered=TaxiDelivered[playerid];
		SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You should have driven yourself. Mickey doesn't like it when unknown people drive in his taxi's.");
		format(strings, sizeof(strings), "* He has fired you despite making %d taxirides", delivered);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
		TotalTaxis(playerid, delivered);
		TaxiDriver[playerid] = 0;
	    TaxiNextCP[playerid] = 0;
	}
	TaxiDelivered[playerid]++;
	TogglePlayerControllable(playerid,0);
	randomloc=random(32)+1;
	TaxiNextCP[playerid] = TaxiDriverLocs[randomloc];
	property=TaxiNextCP[playerid];
	SetPlayerCheckpoint(playerid,TaxiCheckpoints[property][0],TaxiCheckpoints[property][1],TaxiCheckpoints[property][2],5.0);
	TaxiExtraTime[playerid]=TaxiTimer[playerid];
	if(TaxiExtraTime[playerid] > 0){
	    TaxiExtraTimeDisplay[playerid]=3;
		if(TaxiDelivered[playerid] <= 10 && TaxiDelivered[playerid] > 0) TaxiExtraTime[playerid]=TaxiExtraTime[playerid] + 10;
		if(TaxiDelivered[playerid] <= 20 && TaxiDelivered[playerid] > 10) TaxiExtraTime[playerid]=TaxiExtraTime[playerid] + 5;
	}
	if(TaxiDelivered[playerid] >= 30) TaxiTotalTime[playerid]=TaxiTotalTime[playerid] - 5;
	format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player completed a taxi run.", playerid, reward, GetPlayerMoney(playerid));
	reward = 750 + floatround(TaxiDistance[playerid]*0.25) + floatround(TaxiTimer[playerid]*5) + floatround(TaxiDelivered[playerid] * 50);
	StatGivePlayerMoney(playerid, reward, strings);
	if(TaxiDelivered[playerid] > 0){
		format(strings, sizeof(strings),"* Taxirun number %d completed, you earned $%d.", TaxiDelivered[playerid], reward);
		SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
	}
	format(strings, sizeof(strings), "* Next location: %s . Type /taxistop to end the mission.", TaxiCheckpointDescriptions[TaxiNextCP[playerid]]);
	SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
	TaxiDistance[playerid]=floatround(floatsqroot(floatpower(floatabs(floatsub(X250[playerid],TaxiCheckpoints[property][0])),2)+
												  floatpower(floatabs(floatsub(Y250[playerid],TaxiCheckpoints[property][1])),2)+
												  floatpower(floatabs(floatsub(Z250[playerid],TaxiCheckpoints[property][2])),2)));
	TaxiTimer[playerid] = floatround(TaxiDistance[playerid]*0.06);
	TaxiTotalTime[playerid]=TaxiTotalTime[playerid] + TaxiExtraTime[playerid] + TaxiTimer[playerid] + 3;
	TaxiWaitTime[playerid]=3;
	return 1;
}


public TotalTaxis(playerid, delivered){
	GetPlayerName(playerid, playername, sizeof(playername));
	if(delivered > GlobalTaxi1){
		format(strings, sizeof(strings),"* %s has reached the nr 1 spot in the taxi-leaderboard by completing %d taxiruns", playername, delivered);
		SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
		GlobalTaxi5=GlobalTaxi4;
		format(GlobalTaxiMan5, sizeof(GlobalTaxiMan5), "%s", GlobalTaxiMan4);
		GlobalTaxi4=GlobalTaxi3;
		format(GlobalTaxiMan4, sizeof(GlobalTaxiMan4), "%s", GlobalTaxiMan3);
		GlobalTaxi3=GlobalTaxi2;
		format(GlobalTaxiMan3, sizeof(GlobalTaxiMan3), "%s", GlobalTaxiMan2);
		GlobalTaxi2=GlobalTaxi1;
		format(GlobalTaxiMan2, sizeof(GlobalTaxiMan2), "%s", GlobalTaxiMan1);
		GlobalTaxi1=delivered;
		format(GlobalTaxiMan1, sizeof(GlobalTaxiMan1), "%s", playername);
	} else {
		if(delivered > GlobalTaxi2){
			format(strings, sizeof(strings),"* %s has reached the nr 2 spot in the taxi-leaderboard by completing %d taxiruns", playername, delivered);
			SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
			GlobalTaxi5=GlobalTaxi4;
			format(GlobalTaxiMan5, sizeof(GlobalTaxiMan5), "%s", GlobalTaxiMan4);
			GlobalTaxi4=GlobalTaxi3;
			format(GlobalTaxiMan4, sizeof(GlobalTaxiMan4), "%s", GlobalTaxiMan3);
			GlobalTaxi3=GlobalTaxi2;
			format(GlobalTaxiMan3, sizeof(GlobalTaxiMan3), "%s", GlobalTaxiMan2);
			GlobalTaxi2=delivered;
			format(GlobalTaxiMan2, sizeof(GlobalTaxiMan2), "%s", playername);
		} else {
			if(delivered > GlobalTaxi3){
				format(strings, sizeof(strings),"* %s has reached the nr 3 spot in the taxi-leaderboard by completing %d taxiruns", playername, delivered);
				SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
				GlobalTaxi5=GlobalTaxi4;
				format(GlobalTaxiMan5, sizeof(GlobalTaxiMan5), "%s", GlobalTaxiMan4);
				GlobalTaxi4=GlobalTaxi3;
				format(GlobalTaxiMan4, sizeof(GlobalTaxiMan4), "%s", GlobalTaxiMan3);
				GlobalTaxi3=delivered;
				format(GlobalTaxiMan3, sizeof(GlobalTaxiMan3), "%s", playername);
			} else {
				if(delivered > GlobalTaxi4){
					format(strings, sizeof(strings),"* %s has reached the nr 4 spot in the taxi-leaderboard by completing %d taxiruns", playername, delivered);
					SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					GlobalTaxi5=GlobalTaxi4;
					format(GlobalTaxiMan5, sizeof(GlobalTaxiMan5), "%s", GlobalTaxiMan4);
					GlobalTaxi4=delivered;
					format(GlobalTaxiMan4, sizeof(GlobalTaxiMan4), "%s", playername);
				} else {
					if(delivered > GlobalTaxi4){
						format(strings, sizeof(strings),"* %s has reached the nr 5 spot in the taxi-leaderboard by completing %d taxiruns", playername, delivered);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						GlobalTaxi5=delivered;
						format(GlobalTaxiMan5, sizeof(GlobalTaxiMan5), "%s", playername);
					} else {
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Sorry, your score was not enough to reach the taxi-leaderboard.");
					}
				}
			}
		}
	}
	TaxiBoardUpdate();
	return 1;
}

public PizzaBoardUpdate(){
	if (!dini_Exists(FILE_PIZZABOARD)) {
		dini_Create(FILE_PIZZABOARD);
	}
	if (dini_Exists(FILE_PIZZABOARD)) {
		dini_IntSet(FILE_PIZZABOARD, "Pizza1", GlobalPizza1);
		dini_Set(FILE_PIZZABOARD, "PizzaMan1", GlobalPizzaMan1);
		dini_IntSet(FILE_PIZZABOARD, "Pizza2", GlobalPizza2);
		dini_Set(FILE_PIZZABOARD, "PizzaMan2", GlobalPizzaMan2);
		dini_IntSet(FILE_PIZZABOARD, "Pizza3", GlobalPizza3);
		dini_Set(FILE_PIZZABOARD, "PizzaMan3", GlobalPizzaMan3);
		dini_IntSet(FILE_PIZZABOARD, "Pizza4", GlobalPizza3);
		dini_Set(FILE_PIZZABOARD, "PizzaMan4", GlobalPizzaMan3);
		dini_IntSet(FILE_PIZZABOARD, "Pizza5", GlobalPizza5);
		dini_Set(FILE_PIZZABOARD, "PizzaMan5", GlobalPizzaMan5);
	} else {
	    SendClientMessageToAll(COLOR_RED, "* The server was unable to update the pizzaboard, please notify an admin.");
	}
	return 1;
}

public PizzaScores(){
	if (dini_Exists(FILE_PIZZABOARD)) {
		tmps1 = dini_Get(FILE_PIZZABOARD, "Pizza1");
	    if (strval(tmps1) > 0) GlobalPizza1=strval(tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "PizzaMan1");
		if (strlen(tmps1)) format(GlobalPizzaMan1, sizeof(GlobalPizzaMan1), "%s", tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "Pizza2");
	    if (strval(tmps1) > 0) GlobalPizza2=strval(tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "PizzaMan2");
		if (strlen(tmps1)) format(GlobalPizzaMan2, sizeof(GlobalPizzaMan2), "%s", tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "Pizza3");
	    if (strval(tmps1) > 0) GlobalPizza3=strval(tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "PizzaMan3");
		if (strlen(tmps1)) format(GlobalPizzaMan3, sizeof(GlobalPizzaMan3), "%s", tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "Pizza4");
	    if (strval(tmps1) > 0) GlobalPizza4=strval(tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "PizzaMan4");
		if (strlen(tmps1)) format(GlobalPizzaMan4, sizeof(GlobalPizzaMan4), "%s", tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "Pizza5");
	    if (strval(tmps1) > 0) GlobalPizza5=strval(tmps1);
		tmps1 = dini_Get(FILE_PIZZABOARD, "PizzaMan5");
		if (strlen(tmps1)) format(GlobalPizzaMan5, sizeof(GlobalPizzaMan5), "%s", tmps1);
	}
	return 1;
}

public TaxiBoardUpdate(){
	if (!dini_Exists(FILE_TAXIBOARD)) {
		dini_Create(FILE_TAXIBOARD);
	}
	if (dini_Exists(FILE_TAXIBOARD)) {
		dini_IntSet(FILE_TAXIBOARD, "Taxi1", GlobalTaxi1);
		dini_Set(FILE_TAXIBOARD, "TaxiMan1", GlobalTaxiMan1);
		dini_IntSet(FILE_TAXIBOARD, "Taxi2", GlobalTaxi2);
		dini_Set(FILE_TAXIBOARD, "TaxiMan2", GlobalTaxiMan2);
		dini_IntSet(FILE_TAXIBOARD, "Taxi3", GlobalTaxi3);
		dini_Set(FILE_TAXIBOARD, "TaxiMan3", GlobalTaxiMan3);
		dini_IntSet(FILE_TAXIBOARD, "Taxi4", GlobalTaxi3);
		dini_Set(FILE_TAXIBOARD, "TaxiMan4", GlobalTaxiMan3);
		dini_IntSet(FILE_TAXIBOARD, "Taxi5", GlobalTaxi5);
		dini_Set(FILE_TAXIBOARD, "TaxiMan5", GlobalTaxiMan5);
	} else {
	    SendClientMessageToAll(COLOR_RED, "* The server was unable to update the Taxiboard, please notify an admin.");
	}
	return 1;
}

public TaxiScores(){
	if (dini_Exists(FILE_TAXIBOARD)) {
		tmps1 = dini_Get(FILE_TAXIBOARD, "Taxi1");
	    if (strval(tmps1) > 0) GlobalTaxi1=strval(tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "TaxiMan1");
		if (strlen(tmps1)) format(GlobalTaxiMan1, sizeof(GlobalTaxiMan1), "%s", tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "Taxi2");
	    if (strval(tmps1) > 0) GlobalTaxi2=strval(tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "TaxiMan2");
		if (strlen(tmps1)) format(GlobalTaxiMan2, sizeof(GlobalTaxiMan2), "%s", tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "Taxi3");
	    if (strval(tmps1) > 0) GlobalTaxi3=strval(tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "TaxiMan3");
		if (strlen(tmps1)) format(GlobalTaxiMan3, sizeof(GlobalTaxiMan3), "%s", tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "Taxi4");
	    if (strval(tmps1) > 0) GlobalTaxi4=strval(tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "TaxiMan4");
		if (strlen(tmps1)) format(GlobalTaxiMan4, sizeof(GlobalTaxiMan4), "%s", tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "Taxi5");
	    if (strval(tmps1) > 0) GlobalTaxi5=strval(tmps1);
		tmps1 = dini_Get(FILE_TAXIBOARD, "TaxiMan5");
		if (strlen(tmps1)) format(GlobalTaxiMan5, sizeof(GlobalTaxiMan5), "%s", tmps1);
	}
	return 1;
}

public SprintRace3Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer1[2];
	new Float:X1=1771.0892;
	new Float:Y1=836.7173;
	new Float:Z1=13.0037;
	new Float:A1=90.0000;
	new Float:X2=1771.0892;
	new Float:Y2=831.3871;
	new Float:Z2=13.0037;
	new Float:A2=90.0000;

    if(sprintrace3started == 0){
        return 1;
	} else {
	    if(sprintrace3countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace3players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace3players[i]=0;
				sprintrace3[0]=0;
				sprintrace3started=0;
				DMplayer[i]=0;
				playerssprintrace3=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace3players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				sprintrace3players[i]=0;
				sprintrace3[0]=0;
				sprintrace3started=0;
				DMplayer[i]=0;
				playerssprintrace3=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace3players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace3players[i]=0;
				sprintrace3[i]=0;
				DMplayer[i]=0;
				playerssprintrace3=playerssprintrace3-1;
			} else {
	   		    if (deathmatchplayer == 1) {

					deathmatcher18[i]=1;
					sprintrace3racer[0]=i;
					sprintrace3players[i]=0;
					sprintrace3inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer1[0], A1);
					SetVehiclePos(CircuitRacer1[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace3CPCounter[i]=0;
					SprintRace3NextCP[i]=SprintRace3CP[SprintRace3CPCounter[i]];
					sprintracer[i] = 1;
					SprintRace3NextCheckpoint(i);
				} else {
					deathmatcher18[i]=1;

					sprintrace3racer[1]=i;
					sprintrace3players[i]=0;
					sprintrace3inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer1[1], A2);
					SetVehiclePos(CircuitRacer1[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace3CPCounter[i]=0;
					SprintRace3NextCP[i]=SprintRace3CP[SprintRace3CPCounter[i]];
					sprintracer[i] = 1;
					SprintRace3NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace3Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public SprintRace4Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer2[2];
	new Float:X1=-1654.2976;
	new Float:Y1=541.9305;
	new Float:Z1=41.8037;
	new Float:A1=316.0000;
	new Float:X2=-1658.4791;
	new Float:Y2=546.6398;
	new Float:Z2=41.8037;
	new Float:A2=316.0000;

    if(sprintrace4started == 0){
        return 1;
	} else {
	    if(sprintrace4countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace4players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace4players[i]=0;
				sprintrace4[0]=0;
				sprintrace4started=0;
				DMplayer[i]=0;
				playerssprintrace4=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace4players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				sprintrace4players[i]=0;
				sprintrace4[0]=0;
				sprintrace4started=0;
				DMplayer[i]=0;
				playerssprintrace4=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace4players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace4players[i]=0;
				sprintrace4[i]=0;
				DMplayer[i]=0;
				playerssprintrace4=playerssprintrace4-1;
			} else {
	   		    if (deathmatchplayer == 1) {

					deathmatcher19[i]=1;
					sprintrace4racer[0]=i;
					sprintrace4players[i]=0;
					sprintrace4inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer2[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer2[0], A1);
					SetVehiclePos(CircuitRacer2[0], X1,Y1,Z1);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					SetCameraBehindPlayer(i);
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace4NextCP[i]=SprintRace4CP[0];
					sprintracer[i] = 1;
					SprintRace4NextCheckpoint(i);
				} else {
					deathmatcher19[i]=1;

					sprintrace4racer[1]=i;
					sprintrace4players[i]=0;
					sprintrace4inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer2[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer2[1], A2);
					SetVehiclePos(CircuitRacer2[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace4NextCP[i]=SprintRace4CP[0];
					sprintracer[i] = 1;
					SprintRace4NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace4Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public SprintRace5Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer3[2];
	new Float:X1=-2144.2795;
	new Float:Y1=332.7245;
	new Float:Z1=37.8037;
	new Float:A1=0.0000;
	new Float:X2=-2149.2207;
	new Float:Y2=332.7245;
	new Float:Z2=37.8037;
	new Float:A2=0.0000;

    if(sprintrace5started == 0){
        return 1;
	} else {
	    if(sprintrace5countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace5players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace5players[i]=0;
				sprintrace5[0]=0;
				sprintrace5started=0;
				DMplayer[i]=0;
				playerssprintrace5=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace5players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				sprintrace5players[i]=0;
				sprintrace5[0]=0;
				sprintrace5started=0;
				DMplayer[i]=0;
				playerssprintrace5=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace5players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace5players[i]=0;
				sprintrace5[i]=0;
				DMplayer[i]=0;
				playerssprintrace5=playerssprintrace5-1;
			} else {
	   		    if (deathmatchplayer == 1) {

					deathmatcher20[i]=1;
					sprintrace5racer[0]=i;
					sprintrace5players[i]=0;
					sprintrace5inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer3[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer3[0], A1);
					SetVehiclePos(CircuitRacer3[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace5NextCP[i]=SprintRace5CP[0];
					sprintracer[i] = 1;
					SprintRace5NextCheckpoint(i);
				} else {
					deathmatcher20[i]=1;

					sprintrace5racer[1]=i;
					sprintrace5players[i]=0;
					sprintrace5inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer3[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer3[1], A2);
					SetVehiclePos(CircuitRacer3[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace5NextCP[i]=SprintRace5CP[0];
					sprintracer[i] = 1;
					SprintRace5NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace5Countdown2Seconds=10;
			}
		}
	}

	return 1;
}

public SprintRace6Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer4[2];
	new Float:X1=2466.6399;
	new Float:Y1=-1656.3975;
	new Float:Z1=15.8037;
	new Float:A1=90.0000;
	new Float:X2=2466.6399;
	new Float:Y2=-1661.5897;
	new Float:Z2=15.8037;
	new Float:A2=90.0000;

    if(sprintrace6started == 0){
        return 1;
	} else {
	    if(sprintrace6countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace6players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace6players[i]=0;
				sprintrace6[0]=0;
				sprintrace6started=0;
				DMplayer[i]=0;
				playerssprintrace6=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace6players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				sprintrace6players[i]=0;
				sprintrace6[0]=0;
				sprintrace6started=0;
				DMplayer[i]=0;
				playerssprintrace6=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace6players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace6players[i]=0;
				sprintrace6[i]=0;
				DMplayer[i]=0;
				playerssprintrace6=playerssprintrace6-1;
			} else {
	   		    if (deathmatchplayer == 1) {

					deathmatcher21[i]=1;
					sprintrace6racer[0]=i;
					sprintrace6players[i]=0;
					sprintrace6inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer4[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer4[0], A1);
					SetVehiclePos(CircuitRacer4[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace6NextCP[i]=SprintRace6CP[0];
					sprintracer[i] = 1;
					SprintRace6NextCheckpoint(i);
				} else {
					deathmatcher21[i]=1;

					sprintrace6racer[1]=i;
					sprintrace6players[i]=0;
					sprintrace6inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer4[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer4[1], A2);
					SetVehiclePos(CircuitRacer4[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace6NextCP[i]=SprintRace6CP[0];
					sprintracer[i] = 1;
					SprintRace6NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace6Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public SprintRace7Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer4[2];
	new Float:X1=2711.1150;
	new Float:Y1=-1607.9021;
	new Float:Z1=15.8037;
	new Float:A1=90.0000;
	new Float:X2=2711.1150;
	new Float:Y2=-1613.4053;
	new Float:Z2=15.8037;
	new Float:A2=90.0000;

    if(sprintrace7started == 0){
        return 1;
	} else {
	    if(sprintrace7countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace7players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				sprintrace7players[i]=0;
				sprintrace7[0]=0;
				sprintrace7started=0;
				DMplayer[i]=0;
				playerssprintrace7=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(sprintrace7players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				sprintrace7players[i]=0;
				sprintrace7[0]=0;
				sprintrace7started=0;
				DMplayer[i]=0;
				playerssprintrace7=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (sprintrace7players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				sprintrace7players[i]=0;
				sprintrace7[i]=0;
				DMplayer[i]=0;
				playerssprintrace7=playerssprintrace7-1;
			} else {
	   		    if (deathmatchplayer == 1) {

					deathmatcher22[i]=1;
					sprintrace7racer[0]=i;
					sprintrace7players[i]=0;
					sprintrace7inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer4[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer4[0], A1);
					SetVehiclePos(CircuitRacer4[0], X1,Y1,Z1);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace7CPCounter[i]=0;
					SprintRace7NextCP[i]=SprintRace7CP[0];
					sprintracer[i] = 1;
					SprintRace7NextCheckpoint(i);
				} else {
					deathmatcher22[i]=1;

					sprintrace7racer[1]=i;
					sprintrace7players[i]=0;
					sprintrace7inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer4[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a sprintrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetVehicleZAngle(CircuitRacer4[1], A2);
					SetVehiclePos(CircuitRacer4[1], X2,Y2,Z2);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					Teleporting[i]=0;
					TogglePlayerControllable(i, 0);
					SprintRace7CPCounter[i]=0;
					SprintRace7NextCP[i]=SprintRace7CP[0];
					sprintracer[i] = 1;
					SprintRace7NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				SprintRace7Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public MotorRace1Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer1[2];
	new Float:X1=1560.7233;
	new Float:Y1=16.7367;
	new Float:Z1=24.7265;
	new Float:A1=180.0000;
	new Float:X2=1557.1709;
	new Float:Y2=16.7367;
	new Float:Z2=24.7265;
	new Float:A2=180.0000;

    if(motorrace1started == 0){
        return 1;
	} else {
	    if(motorrace1countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace1players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				motorrace1players[i]=0;
				motorrace1[0]=0;
				motorrace1started=0;
				DMplayer[i]=0;
				playersmotorrace1=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(motorrace1players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				motorrace1players[i]=0;
				motorrace1[0]=0;
				motorrace1started=0;
				DMplayer[i]=0;
				playersmotorrace1=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace1players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				motorrace1players[i]=0;
				motorrace1[i]=0;
				DMplayer[i]=0;
				playersmotorrace1=playersmotorrace1-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher24[i]=1;
					motorrace1racer[0]=i;
					motorrace1players[i]=0;
					motorrace1inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[0], A1);
					SetVehiclePos(CircuitRacer1[0], X1,Y1,Z1);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					TogglePlayerControllable(i, 0);
					MotorRace1CPCounter[i]=0;
					MotorRace1NextCP[i]=MotorRace1CP[MotorRace1CPCounter[i]];
					motorracer[i] = 1;
					MotorRace1NextCheckpoint(i);
				} else {
					deathmatcher24[i]=1;
					motorrace1racer[1]=i;
					motorrace1players[i]=0;
					motorrace1inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[1], A2);
					SetVehiclePos(CircuitRacer1[1], X2,Y2,Z2);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					TogglePlayerControllable(i, 0);
					MotorRace1CPCounter[i]=0;
					MotorRace1NextCP[i]=MotorRace1CP[MotorRace1CPCounter[i]];
					motorracer[i] = 1;
					MotorRace1NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				MotorRace1Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public MotorRace2Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer1[2];
	new Float:X1=-305.0182;
	new Float:Y1=1506.3241;
	new Float:Z1=74.9619;
	new Float:A1=184.0000;
	new Float:X2=-299.2922;
	new Float:Y2=1506.3241;
	new Float:Z2=74.9619;
	new Float:A2=184.0000;

    if(motorrace2started == 0){
        return 1;
	} else {
	    if(motorrace2countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace2players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				motorrace2players[i]=0;
				motorrace2[0]=0;
				motorrace2started=0;
				DMplayer[i]=0;
				playersmotorrace2=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(motorrace2players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				motorrace2players[i]=0;
				motorrace2[0]=0;
				motorrace2started=0;
				DMplayer[i]=0;
				playersmotorrace2=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace2players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				motorrace2players[i]=0;
				motorrace2[i]=0;
				DMplayer[i]=0;
				playersmotorrace2=playersmotorrace2-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher25[i]=1;
					motorrace2racer[0]=i;
					motorrace2players[i]=0;
					motorrace2inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[0], A1);
					SetVehiclePos(CircuitRacer1[0], X1,Y1,Z1);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					TogglePlayerControllable(i, 0);
					MotorRace2CPCounter[i]=0;
					MotorRace2NextCP[i]=MotorRace2CP[MotorRace2CPCounter[i]];
					motorracer[i] = 1;
					MotorRace2NextCheckpoint(i);
				} else {
					deathmatcher25[i]=1;
					motorrace2racer[1]=i;
					motorrace2players[i]=0;
					motorrace2inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[1], A2);
					SetVehiclePos(CircuitRacer1[1], X2,Y2,Z2);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					TogglePlayerControllable(i, 0);
					MotorRace2CPCounter[i]=0;
					MotorRace2NextCP[i]=MotorRace2CP[MotorRace2CPCounter[i]];
					motorracer[i] = 1;
					MotorRace2NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				MotorRace2Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public MotorRace3Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer1[2];
	new Float:X1=-1572.7124;
	new Float:Y1=736.6984;
	new Float:Z1=6.6569;
	new Float:A1=90.0000;
	new Float:X2=-1572.7324;
	new Float:Y2=729.6496;
	new Float:Z2=6.6569;
	new Float:A2=90.0000;

    if(motorrace3started == 0){
        return 1;
	} else {
	    if(motorrace3countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace3players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				motorrace3players[i]=0;
				motorrace3[0]=0;
				motorrace3started=0;
				DMplayer[i]=0;
				playersmotorrace3=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(motorrace3players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				motorrace3players[i]=0;
				motorrace3[0]=0;
				motorrace3started=0;
				DMplayer[i]=0;
				playersmotorrace3=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace3players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				motorrace3players[i]=0;
				motorrace3[i]=0;
				DMplayer[i]=0;
				playersmotorrace3=playersmotorrace3-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher26[i]=1;
					motorrace3racer[0]=i;
					motorrace3players[i]=0;
					motorrace3inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[0], A1);
					SetVehiclePos(CircuitRacer1[0], X1,Y1,Z1);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					TogglePlayerControllable(i, 0);
					MotorRace3CPCounter[i]=0;
					MotorRace3NextCP[i]=MotorRace3CP[MotorRace3CPCounter[i]];
					motorracer[i] = 1;
					MotorRace3NextCheckpoint(i);
				} else {
					deathmatcher26[i]=1;
					motorrace3racer[1]=i;
					motorrace3players[i]=0;
					motorrace3inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[1], A2);
					SetVehiclePos(CircuitRacer1[1], X2,Y2,Z2);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					TogglePlayerControllable(i, 0);
					MotorRace3CPCounter[i]=0;
					MotorRace3NextCP[i]=MotorRace3CP[MotorRace3CPCounter[i]];
					motorracer[i] = 1;
					MotorRace3NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				MotorRace3Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public MotorRace4Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer1[2];
	new Float:X1=-2295.3286;
	new Float:Y1=-1684.3595;
	new Float:Z1=482.1652;
	new Float:A1=203.0000;
	new Float:X2=-2293.1572;
	new Float:Y2=-1683.3959;
	new Float:Z2=482.1652;
	new Float:A2=203.0000;

    if(motorrace4started == 0){
        return 1;
	} else {
	    if(motorrace4countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace4players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				motorrace4players[i]=0;
				motorrace4[0]=0;
				motorrace4started=0;
				DMplayer[i]=0;
				playersmotorrace4=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(motorrace4players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 50000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 50000, strings);
				motorrace4players[i]=0;
				motorrace4[0]=0;
				motorrace4started=0;
				DMplayer[i]=0;
				playersmotorrace4=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace4players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				motorrace4players[i]=0;
				motorrace4[i]=0;
				DMplayer[i]=0;
				playersmotorrace4=playersmotorrace4-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher27[i]=1;
					motorrace4racer[0]=i;
					motorrace4players[i]=0;
					motorrace4inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[0], A1);
					SetVehiclePos(CircuitRacer1[0], X1,Y1,Z1);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					TogglePlayerControllable(i, 0);
					MotorRace4CPCounter[i]=0;
					MotorRace4NextCP[i]=MotorRace4CP[MotorRace4CPCounter[i]];
					motorracer[i] = 1;
					MotorRace4NextCheckpoint(i);
				} else {
					deathmatcher27[i]=1;
					motorrace4racer[1]=i;
					motorrace4players[i]=0;
					motorrace4inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[1], A2);
					SetVehiclePos(CircuitRacer1[1], X2,Y2,Z2);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					TogglePlayerControllable(i, 0);
					MotorRace4CPCounter[i]=0;
					MotorRace4NextCP[i]=MotorRace4CP[MotorRace4CPCounter[i]];
					motorracer[i] = 1;
					MotorRace4NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				MotorRace4Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public MotorRace5Game(){
	new CurrentID;
	new deathmatchplayer;
	new CircuitRacer1[2];
	new Float:X1=1795.8898;
	new Float:Y1=825.4000;
	new Float:Z1=10.3;
	new Float:A1=180.0000;
	new Float:X2=1800.9294;
	new Float:Y2=825.4000;
	new Float:Z2=10.3;
	new Float:A2=180.0000;

    if(motorrace5started == 0){
        return 1;
	} else {
	    if(motorrace5countdownseconds>0){
	        return 1;
		}
	}

	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace5players[i] == 1)){
			if(IsPlayerInAnyVehicle(i)){
			    deathmatchplayer++;
			} else {
				SendClientMessage(i, COLOR_SYSTEM_PM, "You should have stayed in your vehicle. Because you didn't, you are disqualified.");
				motorrace5players[i]=0;
				motorrace5[0]=0;
				motorrace5started=0;
				DMplayer[i]=0;
				playersmotorrace5=0;
			}
		}
	}
	if(deathmatchplayer==1){
		for(new i=0;i<MAX_PLAYERS;i++){
			if(motorrace5players[i] == 1){
				SendClientMessage(i, COLOR_SYSTEM_PM, "No other players wants to race you, you get your money back.");
				format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because no one wanted to challange the player.", i, 25000, GetPlayerMoney(i));
				StatGivePlayerMoney(i, 25000, strings);
				motorrace5players[i]=0;
				motorrace5[0]=0;
				motorrace5started=0;
				DMplayer[i]=0;
				playersmotorrace5=0;
				return 1;
			}
		}
	}
	deathmatchplayer=0;
	for(new i=0;i<MAX_PLAYERS;i++){
		if((IsPlayerConnected(i)) && (logged[i] == 1) && (motorrace5players[i] == 1)){
			deathmatchplayer++;
			if(jailed[i] == 1) {
			    SendClientMessage(i, COLOR_SYSTEM_PW , "* You cannot join the race since you are jailed.");
				motorrace5players[i]=0;
				motorrace5[i]=0;
				DMplayer[i]=0;
				playersmotorrace5=playersmotorrace5-1;
			} else {
	   		    if (deathmatchplayer == 1) {
					deathmatcher28[i]=1;
					motorrace5racer[0]=i;
					motorrace5players[i]=0;
					motorrace5inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[0] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[0], A1);
					SetVehiclePos(CircuitRacer1[0], X1,Y1,Z1);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X1;
					CarYPos[i] = Y1;
					CarZPos[i] = Z1;
					TogglePlayerControllable(i, 0);
					MotorRace5CPCounter[i]=0;
					MotorRace5NextCP[i]=MotorRace5CP[MotorRace5CPCounter[i]];
					motorracer[i] = 1;
					MotorRace5NextCheckpoint(i);
				} else {
					deathmatcher28[i]=1;
					motorrace5racer[1]=i;
					motorrace5players[i]=0;
					motorrace5inprogress=1;
					Teleporting[i]=1;
  					CircuitRacer1[1] = GetPlayerVehicleID(i);
					dragracer[i]=1;
					for(new j=0;j<MAX_PLAYERS;j++){
						if(IsPlayerConnected(j) && logged[j] == 1 && j != i){
						    if(IsPlayerInAnyVehicle(j)){
								if(GetPlayerVehicleID(j) == GetPlayerVehicleID(i)){
									RemovePlayerFromVehicle(j);
									SendClientMessage(j,COLOR_SYSTEM_PW,"* Your driver is participating in a motorrace, at which no passengers are allowed. Sorry.");
								}
							}
						}
					}
					SetPlayerWorldBounds(i,324.9738,324.9738,2520.6030,2520.6030);
					SetVehicleZAngle(CircuitRacer1[1], A2);
					SetVehiclePos(CircuitRacer1[1], X2,Y2,Z2);
			    	SetTimer("ResetPlayerBounds",400,0);
					SetCameraBehindPlayer(i);
					CurrentID = CurrentVehicle[i];
					VehicleGroup[i]=WhichVehicleGroup(CurrentID);
					VehiclePetrol[CurrentID]=PetrolTank[VehicleGroup[i]];
					CarXPos[i] = X2;
					CarYPos[i] = Y2;
					CarZPos[i] = Z2;
					TogglePlayerControllable(i, 0);
					MotorRace5CPCounter[i]=0;
					MotorRace5NextCP[i]=MotorRace5CP[MotorRace5CPCounter[i]];
					motorracer[i] = 1;
					MotorRace5NextCheckpoint(i);
				}
				SendClientMessage(i, COLOR_ADMIN_TOALL , "* Follow the checkpoints, cross the finish first to win this race.");
				SendClientMessage(i, COLOR_RED , "!!!GET READY!!!");
				MotorRace5Countdown2Seconds=10;
			}
		}
	}
	return 1;
}

public SprintRace3NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(SprintRace3CPCounter[playerid] < 17){
		AutoCancelSprint3=90;
		CrossedCheckpoints[playerid]=SprintRace3CPCounter[playerid];
     	SprintRace3CPCounter[playerid]++;
		SprintRace3NextCP[playerid]=SprintRace3CP[SprintRace3CPCounter[playerid]];
		checkpoint=SprintRace3NextCP[playerid];
		SetPlayerCheckpoint(playerid,SprintRace3Checkpoints[checkpoint][0],SprintRace3Checkpoints[checkpoint][1],SprintRace3Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		SprintRace3Finisher++;
		if(SprintRace3Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the sprint race type 3 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the sprint race type 3! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the sprint race type 3.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			sprintracer[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace3[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace3players[playerid] = 0;
			deathmatcher18[playerid]=0;
			if(CancelSprint3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in sprint race type 3 has been cancelled the race has ended.");
				playerssprintrace3=0;
				sprintrace3started=0;
				sprintrace3inprogress=0;
				sprintrace3racer[0]=0;
				sprintrace3racer[1]=0;
				CancelSprint3 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the sprint race type 3 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the sprint race type 3!");
			DMplayer[playerid] = 0;
			sprintrace3[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace3players[playerid] = 0;
			playerssprintrace3=0;
			sprintracer[playerid] = 0;
			sprintrace3started=0;
			sprintrace3inprogress=0;
			sprintrace3racer[0]=0;
			sprintrace3racer[1]=0;
			deathmatcher18[playerid]=0;
		}
	}
	return 1;
}

public SprintRace4NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(SprintRace4CPCounter[playerid] < 24){
		AutoCancelSprint4=90;
		CrossedCheckpoints[playerid]=SprintRace4CPCounter[playerid];
     	SprintRace4CPCounter[playerid]++;
		SprintRace4NextCP[playerid]=SprintRace4CP[SprintRace4CPCounter[playerid]];
		checkpoint=SprintRace4NextCP[playerid];
		SetPlayerCheckpoint(playerid,SprintRace4Checkpoints[checkpoint][0],SprintRace4Checkpoints[checkpoint][1],SprintRace4Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		SprintRace4Finisher++;
		if(SprintRace4Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the sprint race type 4 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the sprint race type 4! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the sprint race type 2.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			DMplayer[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace4[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace4players[playerid] = 0;
			deathmatcher19[playerid]=0;
			if(CancelSprint4 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in sprint race type 4 has been cancelled the race has ended.");
				playerssprintrace4=0;
				sprintrace4started=0;
				sprintrace4inprogress=0;
				sprintrace4racer[0]=0;
				sprintrace4racer[1]=0;
				CancelSprint4 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the sprint race type 4 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the sprint race type 4!");
			DMplayer[playerid] = 0;
			sprintrace4[playerid] = 0;
			sprintracer[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace4players[playerid] = 0;
			playerssprintrace4=0;
			sprintrace4started=0;
			sprintrace4inprogress=0;
			sprintrace4racer[0]=0;
			sprintrace4racer[1]=0;
			deathmatcher19[playerid]=0;
		}
	}
	return 1;
}

public SprintRace5NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(SprintRace5CPCounter[playerid] < 19){
		AutoCancelSprint5=90;
		CrossedCheckpoints[playerid]=SprintRace5CPCounter[playerid];
     	SprintRace5CPCounter[playerid]++;
		SprintRace5NextCP[playerid]=SprintRace5CP[SprintRace5CPCounter[playerid]];
		checkpoint=SprintRace5NextCP[playerid];
		SetPlayerCheckpoint(playerid,SprintRace5Checkpoints[checkpoint][0],SprintRace5Checkpoints[checkpoint][1],SprintRace5Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		SprintRace5Finisher++;
		if(SprintRace5Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the sprint race type 5 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the sprint race type 5! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the sprint race type 3.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			sprintracer[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace5[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace5players[playerid] = 0;
			deathmatcher20[playerid]=0;
			if(CancelSprint5 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in sprint race type 5 has been cancelled the race has ended.");
				playerssprintrace5=0;
				sprintrace5started=0;
				sprintrace5inprogress=0;
				sprintrace5racer[0]=0;
				sprintrace5racer[1]=0;
				CancelSprint5 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the sprint race type 5 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the sprint race type 5!");
			sprintracer[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace5[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace5players[playerid] = 0;
			playerssprintrace5=0;
			sprintrace5started=0;
			sprintrace5inprogress=0;
			sprintrace5racer[0]=0;
			sprintrace5racer[1]=0;
			deathmatcher20[playerid]=0;
		}
	}
	return 1;
}

public SprintRace6NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(SprintRace6CPCounter[playerid] < 22){
		AutoCancelSprint6=90;
		CrossedCheckpoints[playerid]=SprintRace6CPCounter[playerid];
     	SprintRace6CPCounter[playerid]++;
		SprintRace6NextCP[playerid]=SprintRace6CP[SprintRace6CPCounter[playerid]];
		checkpoint=SprintRace6NextCP[playerid];
		SetPlayerCheckpoint(playerid,SprintRace6Checkpoints[checkpoint][0],SprintRace6Checkpoints[checkpoint][1],SprintRace6Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		SprintRace6Finisher++;
		if(SprintRace6Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the sprint race type 6 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the sprint race type 6! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the sprint race type 4.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			sprintracer[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace6[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace6players[playerid] = 0;
			deathmatcher21[playerid]=0;
			if(CancelSprint6 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in sprint race type 6 has been cancelled the race has ended.");
				playerssprintrace6=0;
				sprintrace6started=0;
				sprintrace6inprogress=0;
				sprintrace6racer[0]=0;
				sprintrace6racer[1]=0;
				CancelSprint6 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the sprint race type 6 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the sprint race type 6!");
			DMplayer[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace6[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace6players[playerid] = 0;
			playerssprintrace6=0;
			sprintrace6started=0;
			sprintrace6inprogress=0;
			sprintrace6racer[0]=0;
			sprintrace6racer[1]=0;
			deathmatcher21[playerid]=0;
		}
	}
	return 1;
}

public SprintRace7NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(SprintRace7CPCounter[playerid] < 36){
		AutoCancelSprint7=90;
		CrossedCheckpoints[playerid]=SprintRace7CPCounter[playerid];
     	SprintRace7CPCounter[playerid]++;
		SprintRace7NextCP[playerid]=SprintRace7CP[SprintRace7CPCounter[playerid]];
		checkpoint=SprintRace7NextCP[playerid];
		SetPlayerCheckpoint(playerid,SprintRace7Checkpoints[checkpoint][0],SprintRace7Checkpoints[checkpoint][1],SprintRace7Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		SprintRace7Finisher++;
		if(SprintRace7Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the sprint race type 7 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the sprint race type 7! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the sprint race type 4.", playerid, 80000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 80000, strings);
			sprintracer[playerid] = 0;
			DMplayer[playerid] = 0;
			sprintrace7[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace7players[playerid] = 0;
			deathmatcher22[playerid]=0;
			if(CancelSprint7 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in sprint race type 7 has been cancelled the race has ended.");
				playerssprintrace7=0;
				sprintrace7started=0;
				sprintrace7inprogress=0;
				sprintrace7racer[0]=0;
				sprintrace7racer[1]=0;
				CancelSprint7 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the sprint race type 7 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the sprint race type 7!");
			DMplayer[playerid] = 0;
			sprintracer[playerid] = 0;
			sprintrace7[playerid] = 0;
			Fined[playerid] = 0;
			sprintrace7players[playerid] = 0;
			playerssprintrace7=0;
			sprintrace7started=0;
			sprintrace7inprogress=0;
			sprintrace7racer[0]=0;
			sprintrace7racer[1]=0;
			deathmatcher22[playerid]=0;
		}
	}
	return 1;
}

public MotorRace1NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(MotorRace1CPCounter[playerid] < 22){
		AutoCancelMotor1=90;
		CrossedCheckpoints[playerid]=MotorRace1CPCounter[playerid];
     	MotorRace1CPCounter[playerid]++;
		MotorRace1NextCP[playerid]=MotorRace1CP[MotorRace1CPCounter[playerid]];
		checkpoint=MotorRace1NextCP[playerid];
		SetPlayerCheckpoint(playerid,MotorRace1Checkpoints[checkpoint][0],MotorRace1Checkpoints[checkpoint][1],MotorRace1Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		MotorRace1Finisher++;
		if(MotorRace1Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the motor race type 1 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the motor race type 1! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the motor race type 1.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			motorracer[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace1[playerid] = 0;
			Fined[playerid] = 0;
			motorrace1players[playerid] = 0;
			deathmatcher24[playerid]=0;
			if(CancelMotor3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in motor race type 1 has been cancelled the race has ended.");
				playersmotorrace1=0;
				motorrace1started=0;
				motorrace1inprogress=0;
				motorrace1racer[0]=0;
				motorrace1racer[1]=0;
				CancelMotor3 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the motor race type 1 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the motor race type 1!");
			DMplayer[playerid] = 0;
			motorrace1[playerid] = 0;
			Fined[playerid] = 0;
			motorrace1players[playerid] = 0;
			playersmotorrace1=0;
			motorracer[playerid] = 0;
			motorrace1started=0;
			motorrace1inprogress=0;
			motorrace1racer[0]=0;
			motorrace1racer[1]=0;
			deathmatcher24[playerid]=0;
		}
	}
	return 1;
}

public MotorRace2NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(MotorRace2CPCounter[playerid] < 31){
		AutoCancelMotor2=90;
		CrossedCheckpoints[playerid]=MotorRace2CPCounter[playerid];
     	MotorRace2CPCounter[playerid]++;
		MotorRace2NextCP[playerid]=MotorRace2CP[MotorRace2CPCounter[playerid]];
		checkpoint=MotorRace2NextCP[playerid];
		SetPlayerCheckpoint(playerid,MotorRace2Checkpoints[checkpoint][0],MotorRace2Checkpoints[checkpoint][1],MotorRace2Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		MotorRace2Finisher++;
		if(MotorRace2Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the motor race type 2 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the motor race type 2! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the motor race type 2.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			motorracer[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace2[playerid] = 0;
			Fined[playerid] = 0;
			motorrace2players[playerid] = 0;
			deathmatcher25[playerid]=0;
			if(CancelMotor3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in motor race type 2 has been cancelled the race has ended.");
				playersmotorrace2=0;
				motorrace2started=0;
				motorrace2inprogress=0;
				motorrace2racer[0]=0;
				motorrace2racer[1]=0;
				CancelMotor3 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the motor race type 2 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the motor race type 2!");
			DMplayer[playerid] = 0;
			motorrace2[playerid] = 0;
			Fined[playerid] = 0;
			motorrace2players[playerid] = 0;
			playersmotorrace2=0;
			motorracer[playerid] = 0;
			motorrace2started=0;
			motorrace2inprogress=0;
			motorrace2racer[0]=0;
			motorrace2racer[1]=0;
			deathmatcher25[playerid]=0;
		}
	}
	return 1;
}

public MotorRace3NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(MotorRace3CPCounter[playerid] < 23){
		AutoCancelMotor3=90;
		CrossedCheckpoints[playerid]=MotorRace3CPCounter[playerid];
     	MotorRace3CPCounter[playerid]++;
		MotorRace3NextCP[playerid]=MotorRace3CP[MotorRace3CPCounter[playerid]];
		checkpoint=MotorRace3NextCP[playerid];
		SetPlayerCheckpoint(playerid,MotorRace3Checkpoints[checkpoint][0],MotorRace3Checkpoints[checkpoint][1],MotorRace3Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		MotorRace3Finisher++;
		if(MotorRace3Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the motor race type 3 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the motor race type 3! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the motor race type 3.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			motorracer[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace3[playerid] = 0;
			Fined[playerid] = 0;
			motorrace3players[playerid] = 0;
			deathmatcher26[playerid]=0;
			if(CancelMotor3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in motor race type 3 has been cancelled the race has ended.");
				playersmotorrace3=0;
				motorrace3started=0;
				motorrace3inprogress=0;
				motorrace3racer[0]=0;
				motorrace3racer[1]=0;
				CancelMotor3 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the motor race type 3 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the motor race type 3!");
			DMplayer[playerid] = 0;
			motorrace3[playerid] = 0;
			Fined[playerid] = 0;
			motorrace3players[playerid] = 0;
			playersmotorrace3=0;
			motorracer[playerid] = 0;
			motorrace3started=0;
			motorrace3inprogress=0;
			motorrace3racer[0]=0;
			motorrace3racer[1]=0;
			deathmatcher26[playerid]=0;
		}
	}
	return 1;
}

public MotorRace4NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(MotorRace4CPCounter[playerid] < 17){
		AutoCancelMotor4=90;
		CrossedCheckpoints[playerid]=MotorRace4CPCounter[playerid];
     	MotorRace4CPCounter[playerid]++;
		MotorRace4NextCP[playerid]=MotorRace4CP[MotorRace4CPCounter[playerid]];
		checkpoint=MotorRace4NextCP[playerid];
		SetPlayerCheckpoint(playerid,MotorRace4Checkpoints[checkpoint][0],MotorRace4Checkpoints[checkpoint][1],MotorRace4Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		MotorRace4Finisher++;
		if(MotorRace4Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the motor race type 4 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the motor race type 4! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the motor race type 4.", playerid, 100000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 100000, strings);
			motorracer[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace4[playerid] = 0;
			Fined[playerid] = 0;
			motorrace4players[playerid] = 0;
			deathmatcher27[playerid]=0;
			if(CancelMotor3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in motor race type 4 has been cancelled the race has ended.");
				playersmotorrace4=0;
				motorrace4started=0;
				motorrace4inprogress=0;
				motorrace4racer[0]=0;
				motorrace4racer[1]=0;
				CancelMotor3 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the motor race type 4 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the motor race type 4!");
			DMplayer[playerid] = 0;
			motorrace4[playerid] = 0;
			Fined[playerid] = 0;
			motorrace4players[playerid] = 0;
			playersmotorrace4=0;
			motorracer[playerid] = 0;
			motorrace4started=0;
			motorrace4inprogress=0;
			motorrace4racer[0]=0;
			motorrace4racer[1]=0;
			deathmatcher27[playerid]=0;
		}
	}
	return 1;
}

public MotorRace5NextCheckpoint(playerid) {
	new checkpoint, minutes, seconds,tenthseconds, temp;
	new finishtime[32];

	DisablePlayerCheckpoint(playerid);
	if(MotorRace5CPCounter[playerid] < 27){
		AutoCancelMotor5=90;
		CrossedCheckpoints[playerid]=MotorRace5CPCounter[playerid];
     	MotorRace5CPCounter[playerid]++;
		MotorRace5NextCP[playerid]=MotorRace5CP[MotorRace5CPCounter[playerid]];
		checkpoint=MotorRace5NextCP[playerid];
		SetPlayerCheckpoint(playerid,MotorRace5Checkpoints[checkpoint][0],MotorRace5Checkpoints[checkpoint][1],MotorRace5Checkpoints[checkpoint][2],10.0);
		PlayerPlaySound(playerid,1057,X250[playerid],Y250[playerid],Z250[playerid]);
	} else {
		PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
		MotorRace5Finisher++;
		if(MotorRace5Finisher == 1){
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has won the motor race type 5 race in a time of %s. Congratulations!.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You won the motor race type 5! Congratulations.");
			format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player won the motor race type 5.", playerid, 50000, GetPlayerMoney(playerid));
			StatGivePlayerMoney(playerid, 50000, strings);
			motorracer[playerid] = 0;
			DMplayer[playerid] = 0;
			motorrace5[playerid] = 0;
			Fined[playerid] = 0;
			motorrace5players[playerid] = 0;
			deathmatcher28[playerid]=0;
			if(CancelMotor3 == 1){
			    SendClientMessageToAll(COLOR_SYSTEM_PW, "* Since the other player in motor race type 5 has been cancelled the race has ended.");
				playersmotorrace5=0;
				motorrace5started=0;
				motorrace5inprogress=0;
				motorrace5racer[0]=0;
				motorrace5racer[1]=0;
				CancelMotor3 = 0;
			}
		} else {
		    RaceTiming[playerid] = 0;
			minutes=floatround((RaceTime[playerid]/600), floatround_tozero);
			temp=(RaceTime[playerid]-(minutes*600));
			seconds=floatround((temp/10), floatround_tozero);
			tenthseconds=(temp-(seconds*10));
			if(seconds > 9){
				format(finishtime,sizeof(finishtime), "%d:%d.%d", minutes,seconds,tenthseconds);
			} else {
				format(finishtime,sizeof(finishtime), "%d:0%d.%d", minutes,seconds,tenthseconds);
			}
			GetPlayerName(playerid,playername,sizeof(playername));
		    format(strings, sizeof(strings), "* %s has finished second at the motor race type 5 race in a time of %s.", playername, finishtime);
			SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
			SendClientMessage(playerid,COLOR_SYSTEM_PM, "You have become second at the motor race type 5!");
			DMplayer[playerid] = 0;
			motorrace5[playerid] = 0;
			Fined[playerid] = 0;
			motorrace5players[playerid] = 0;
			playersmotorrace5=0;
			motorracer[playerid] = 0;
			motorrace5started=0;
			motorrace5inprogress=0;
			motorrace5racer[0]=0;
			motorrace5racer[1]=0;
			deathmatcher28[playerid]=0;
		}
	}
	return 1;
}

public CircuitRaceTime(){
	for(new playerid=0;playerid<MAX_PLAYERS;playerid++){
	    if(IsPlayerConnected(playerid)){
	        if(RaceTiming[playerid] == 1){
	            RaceTime[playerid]++;
			}
		}
	}
}

public AddStaticVehicleEx2(modelid, Float:spawn_x, Float:spawn_y, Float:spawn_z, Float:z_angle, color1, color2, respawn){
	if(VC<MAX_VEHICLES){
		CarLocation[VC][0]=floatsub(spawn_x,25.0);
		CarLocation[VC][1]=floatsub(spawn_y,25.0);
		CarLocation[VC][2]=floatadd(spawn_x,25.0);
		CarLocation[VC][3]=floatadd(spawn_y,25.0);
		VC++;
		VehicleModels[VC] = modelid;
		AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2, respawn);
	}
}

public KickOperation(){
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
		    if(ToBeKicked[i] == 1){
    	   		Kick(i);
				ToBeKicked[i] = 0;
    	   	}
		}
	}
	return 1;
}

public BanOperation(){
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(IsPlayerConnected(i)){
		    if(ToBeBanned[i] == 1){
    	   		Ban(i);
				ToBeBanned[i] = 0;
    	   	}
		}
	}
	return 1;
}

public ResetPlayerBounds(){
	for ( new i = 0; i < MAX_PLAYERS; i++ ){
	    if(IsPlayerConnected(i)){
		    if(Teleporting[i] == 1){
	    		SetPlayerWorldBounds( i,5000.0,-5000.0,5000.0,-5000.0 );
	    		Teleporting[i] = 0;
		 	}
		}
	}
}

public OnPlayerPrivmsg(senderid, receiverid, text[]){
	new receivername[MAX_PLAYER_NAME];
	if(IsPlayerConnected(senderid)){
		GetPlayerName(receiverid, receivername, sizeof(receivername));
		format(strings, sizeof(strings), "You send a pm to %s (id: %d): %s", receivername, receiverid, text);
		SendClientMessage(senderid, COLOR_YELLOW, strings);
		if(IgnorePlayerlist[receiverid][senderid] == 0) {
			GetPlayerName(senderid, sendername, sizeof(sendername));
			format(strings, sizeof(strings), "Private message from %s (id: %d): %s", sendername, senderid, text);
			SendClientMessage(receiverid, COLOR_YELLOW, strings);
		}
		if(PMSpyOn[senderid] == 1 || PMSpyOn[receiverid] == 1){
	        format(strings, sizeof(strings), "%s (%d) pm'ed %s (%d): %s", sendername, senderid, receivername, receiverid, text);
		    for (new i=0; i<MAX_PLAYERS; i++){
		        if(PMListen[i] == 1){
	                SendClientMessage(i, COLOR_ADMIN_PM, strings);
				}
			}
		}
	}
}

public PatrolMissionTimer(){
	if(HighwayMission == 1){
	    PatrolTimer++;
	    if(PatrolTimer == 10) {
			PatrolTimer = 0;
		    PatrolTimer2++;
		    if(PatrolTimer2 > 14){
		        PatrolDisable = 1;
		        PatrolCountingUp = 0;
				for(new playerid; playerid < MAX_PLAYERS; playerid++){
				    if(IsPlayerConnected(playerid)){
				        if(HighwayOnMission[playerid] == 1){
							GetPlayerName(playerid, playername, sizeof(playername));
				            HighwayOnMission[playerid] = 0;
							SendClientMessage(playerid, COLOR_SYSTEM_PM, "* Your patrol vehicle ran out of film to capture the speeders. Resupplying is gonna take 15 minutes.");
							SendClientMessage(playerid, COLOR_SYSTEM_PM, "* During that period you cannot patrol the highways.");
							format(strings, sizeof(strings),"* The patrol vehicle of player %s is restacking its supplies.",playername);
							SendClientMessageToAll(COLOR_SYSTEM_PM,strings);
							SendClientMessageToAll(COLOR_SYSTEM_PM, "* For the next 15 minutes you can roam freely over the highways without getting a ticket.");
							OutOfRanger[playerid]=0;
							HighwayMission = 0;
							SetPlayerColor(playerid,playerColors[playerid]);
						}
				    }
				}
		    } else {
   				for(new playerid; playerid < MAX_PLAYERS; playerid++){
				    if(IsPlayerConnected(playerid)){
				        if(HighwayOnMission[playerid] == 1){
							format(strings, sizeof(strings),"* You have %d minutes film left.",15-PatrolTimer2);
							SendClientMessage(playerid,COLOR_SYSTEM_PM,strings);
						}
					}
				}
		    }
		}
	} else {
	    PatrolTimer++;
	    if(PatrolTimer == 10) {
			PatrolTimer = 0;
		    if(PatrolTimer2 > 0 && PatrolDisable == 1 && PatrolCountingUp == 0){
		        PatrolTimer2 --;
		        if(PatrolTimer2 == 0) PatrolDisable = 0;
		    }
		}
	}
}

IsPlayerInZone(playerid, zoneid) {
	if(zoneid == -1) return 0;
	if(X250[playerid] >= zones[zoneid][zone_minx] && X250[playerid] < zones[zoneid][zone_maxx]
	&& Y250[playerid] >= zones[zoneid][zone_miny] && Y250[playerid] < zones[zoneid][zone_maxy]
	&& Z250[playerid] >= zones[zoneid][zone_minz] && Z250[playerid] < zones[zoneid][zone_maxz]) return 1;
	return 0;
}

public GoldPotWinner(playerid){
	if(IsPlayerConnected(playerid)){
	    GetPlayerName(playerid, playername, sizeof(playername));
		format(strings, sizeof(strings), "* The pot filled with %d golden dollar coins has been found by %s. Congratulations!.", GoldPotPrice, playername);
		SendClientMessageToAll(COLOR_GOLD, strings);
		if((GetPlayerMoney(playerid) + GoldPotPrice) > MAX_MONEY) {
			GoldPotPrice=MAX_MONEY-GetPlayerMoney(playerid);
			format(strings, sizeof(strings), "* Because you can only carry $%d around, you receive $%d.", MAX_MONEY, GoldPotPrice);
		}
		format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d was in a paying-area", GoldPotPrice, GetPlayerMoney(playerid), playerid);
		StatGivePlayerMoney(playerid, GoldPotPrice, moneyreason);
		DisablePlayerCheckpoint(playerid);
		GoldPotActive = 0;
	}
	return 1;
}

public ForbiddenTuning(playerid,VehicleID){
	new temp;
	if(ForbiddenTuningTimes[playerid] == 0){
	    //First time, warning
	    SendClientMessage(playerid, COLOR_RULES, "* The server detected that you were going to tune a vehicle which is untunable without a mod.");
		SendClientMessage(playerid, COLOR_RULES, "* Such mods are NOT allowed on this server and we strongly suggest you removing the mod from your computer!");
		ForbiddenTuningTimes[playerid]++;
		dini_IntSet(udb_encode(playername), "forbiddentuning", ForbiddenTuningTimes[playerid]);
        for(new i=0; i<MAX_PLAYERS; i++){
            if(IsPlayerConnected(i)){
                if(i != playerid){
	                if(IsPlayerInAnyVehicle(i)){
						if(!IsPlayerDriver(i)){
						    temp=GetPlayerVehicleID(i);
						    if(temp == VehicleID){
								RemovePlayerFromVehicle(i);
								NoReset[i]=1;
								SpawnPlayer(i);
								SendClientMessage(i, COLOR_SYSTEM_PM, "* You are respawned because your driver was trying to tune a vehicle with a mod,");
								SendClientMessage(i, COLOR_SYSTEM_PM, "* and since those mods are not allowed the driver is kicked from the server.");
							}
						}
					}
				}
			}
		}
        KickMsg(playerid, -1, "Tuning mod user detected.");
	} else {
		if(ForbiddenTuningTimes[playerid] == 1){
		    //Second time, warning
		    SendClientMessage(playerid, COLOR_RULES, "* The server detected that you were going to tune a vehicle which is untunable without a mod.");
			SendClientMessage(playerid, COLOR_RULES, "* Such mods are NOT allowed on this server and we strongly suggest you removing the mod from your computer!");
			SendClientMessage(playerid, COLOR_RULES, "* This is the second time the server detects this mod on you: if it detects you once more it will ban you!");
			ForbiddenTuningTimes[playerid]++;
			dini_IntSet(udb_encode(playername), "forbiddentuning", ForbiddenTuningTimes[playerid]);
	        for(new i=0; i<MAX_PLAYERS; i++){
	            if(IsPlayerConnected(i)){
	                if(i != playerid){
		                if(IsPlayerInAnyVehicle(i)){
							if(!IsPlayerDriver(i)){
							    temp=GetPlayerVehicleID(i);
							    if(temp == VehicleID){
									RemovePlayerFromVehicle(i);
									NoReset[i]=1;
									SpawnPlayer(i);
									SendClientMessage(i, COLOR_SYSTEM_PM, "* You are respawned because your driver was trying to tune a vehicle with a mod,");
									SendClientMessage(i, COLOR_SYSTEM_PM, "* and since those mods are not allowed the driver is kicked from the server.");
								}
							}
						}
					}
				}
			}
	        KickMsg(playerid, -1, "Tuning mod user detected.");
		} else {
		    //Third time, ban
		    SendClientMessage(playerid, COLOR_RULES, "* The server detected that you were going to tune a vehicle which is untunable without a mod.");
			SendClientMessage(playerid, COLOR_RULES, "* Such mods are NOT allowed on this server and we strongly suggest you removing the mod from your computer!");
			SendClientMessage(playerid, COLOR_RULES, "* This is the third time the server detects this mod on you thus you are now banned from this server.");
			ForbiddenTuningTimes[playerid]++;
			dini_IntSet(udb_encode(playername), "forbiddentuning", ForbiddenTuningTimes[playerid]);
	        for(new i=0; i<MAX_PLAYERS; i++){
	            if(IsPlayerConnected(i)){
	                if(i != playerid){
		                if(IsPlayerInAnyVehicle(i)){
							if(!IsPlayerDriver(i)){
							    temp=GetPlayerVehicleID(i);
							    if(temp == VehicleID){
									RemovePlayerFromVehicle(i);
									NoReset[i]=1;
									SpawnPlayer(i);
									SendClientMessage(i, COLOR_SYSTEM_PM, "* You are respawned because your driver was trying to tune a vehicle with a mod,");
									SendClientMessage(i, COLOR_SYSTEM_PM, "* and since those mods are not allowed the driver is kicked from the server.");
								}
							}
						}
					}
				}
			}
	  		if(isprotected[playerid] == 1) {
		    	KickMsg(playerid, -1, "Tuning mod user detected. Advise removing ban protection for this user.");
			} else {
		    	BanMsg(playerid, -1, "Tuning mod user detected.");
		    }
		}
	}
}

public SelfHealing(){
	new Float:health, CurrentHealth;
	for(new i=0; i<MAX_PLAYERS; i++){
		if(IsPlayerConnected(i) && logged[i] == 1 && spawned[i] == 1){
			if(MedicalOfficer[i]==1 && DMplayer[i] == 0){
				GetPlayerHealth(i, health);
				CurrentHealth=floatround(health);
				if ( CurrentHealth < 100 ){
				    if (CurrentHealth > 98 ){
						SetPlayerHealth(i, 100.0);
					} else {
					    SetPlayerHealth(i, health+2.0);
					}
				}
			} else {
			    if(god[i] == 1 && DMplayer[i] == 0) SetPlayerHealth(i, 99999.0);
			}
		}
	}
	return 1;
}

public TransferMoney(){
	for(new playerid=0; playerid<MAX_PLAYERS; playerid++){
	    if(IsPlayerConnected(playerid)){
	        if(MoneyTransferAmount[playerid] > 0 && MoneyChecking[playerid] == 0){
				MoneyChecking[playerid]=1;
			    currentmoney[playerid] = currentmoney[playerid]+MoneyTransferAmount[playerid];
			    GivePlayerMoney(playerid, MoneyTransferAmount[playerid]);
			    printf(MoneyTransferReason[playerid]);
				MoneyTransferAmount[playerid]=0;
				MoneyChecking[playerid]=0;
			}
		}
	}
	return 1;
}

public MinuteRoutine(){
	new TotalWealth;
	for(new playerid=0; playerid<MAX_PLAYERS; playerid++){
		if(IsPlayerConnected(playerid) && logged[playerid] == 1 && spawned[playerid] == 1){
//MuteCountdown
			if(mutetime[playerid]>0){
			    mutetime[playerid]--;
			} else {
			    if(muted[playerid]==1){
			        muted[playerid] = 0;
          			GetPlayerName(playerid, giveplayer, sizeof(giveplayer));
					dini_IntSet(udb_encode(giveplayer), "muted", 0);
					format(strings, sizeof(strings), "--- %s (id: %d) is unmuted because the time was up.", giveplayer,playerid);
					printf(strings);
					format(strings, sizeof(strings), "* %s (id: %d) is unmuted.", giveplayer,playerid);
					SendClientMessageToAll(COLOR_ADMIN_GM , strings);
					SendClientMessage(playerid, COLOR_ADMIN_PM , "* You are unmuted because the time was up.");
				}
			}
//MedicCountdown
			if(Medic[playerid]>0){
			    Medic[playerid]--;
			}
//PayAndSpray3
			if(payandspray[playerid] > 0) {
			    payandspray[playerid]--;
			}
//ResetFined
			if(Fined[playerid] > 0) {
			    Fined[playerid]--;
			}
//SocialServices
			TotalWealth=0;
			for(new i=0; i<MAX_PROPERTIES; i++) {
				if (propertyOwner[i] == playerid) {
					TotalWealth+=propertyCurrentValue[i];
				}
			}
			TotalWealth+=GetPlayerMoney(playerid);
			TotalWealth+=bank[playerid];
			if(TotalWealth < 10000000){
				if(X250[playerid] >= 1995.5 && X250[playerid] <= 2006.0 && Y250[playerid] >= 1518.0 && Y250[playerid] <= 1569.0) {
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You are already receiving $ 100 every 5 seconds, no extra welfare for you at the moment.");
				} else {
					format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d received welfare", 500, GetPlayerMoney(playerid), playerid);
					StatGivePlayerMoney(playerid, 500, moneyreason);
					if(FirstWellfare[playerid] == 1){
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You received a welfare of $ 500 to support you on this server.");
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You continue to receive this welfare as long as your total wealth -money and properties- is below 10 mil.");
						FirstWellfare[playerid] = 0;
					} else {
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You received  a wellfare of $500.");
					}
					WelFare[playerid]=1;
				}
			} else {
				FirstWellfare[playerid] = 0;
			    if(WelFare[playerid]==1){
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You exceeded the wealth limits for which you qualify for welfare.");
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* From now on you will get a small amount of pocketmoney every minute.");
					WelFare[playerid]=0;
			    }
				if(X250[playerid] >= 1995.5 && X250[playerid] <= 2006.0 && Y250[playerid] >= 1518.0 && Y250[playerid] <= 1569.0) {
					SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You are already receiving $ 100 every 5 seconds, no extra pocketmoney for you at the moment.");
				} else {
				    if(WelFare[playerid]==0){
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You received $50 pocketmoney.");
					}
					format(moneyreason, sizeof(moneyreason), "* Money increased by $%d (old: $%d), because player-id %d received pocketmoney", 50, GetPlayerMoney(playerid), playerid);
					StatGivePlayerMoney(playerid, 50, moneyreason);
				}
			}
//TransferedCountdown
	        if(Transfered[playerid] > 0){
	            Transfered[playerid]--;
	        }
		}
	}
//GoldPotRoutine
	GoldPotCountup++;
	if(GoldPotCountup == 15){
	    GoldPotCountup = 0;
	    GoldPotFiveMinute = 5;
	    GoldPotChoice=GoldPotCheckpoints[random(32)];
	    GoldPotPrice=random(75000)+25000;
		format(strings, sizeof(strings), "* A new pot of golden dollars is placed. It is filled with %d coins, you have 5 minutes to find it.", GoldPotPrice);
		SendClientMessageToAll(COLOR_GOLD, strings);
		format(strings, sizeof(strings), "* The clue: %s", propertyNames[GoldPotChoice-P_OFFSET]);
		SendClientMessageToAll(COLOR_GOLD, strings);
	    GoldPotActive = 1;
	} else {
	    if(GoldPotActive == 1){
			if(GoldPotFiveMinute > 0){
			    GoldPotFiveMinute--;
			    if(GoldPotFiveMinute > 0){
					format(strings, sizeof(strings), "* You have %d minute(s) left to find the pot filled with $%d. Type /clue to see the clue again.", GoldPotFiveMinute, GoldPotPrice);
					SendClientMessageToAll(COLOR_GOLD, strings);
				} else {
				    SendClientMessageToAll(COLOR_GOLD, "* The pot of gold was not found. There will be a new pot of gold every fifteen minutes.");
				    GoldPotActive = 0;
				}
			}
		}
	}
//ResetLVPartytime
	if(LVPartytime > 0){
	    LVPartytime--;
	    if(LVPartytime == 0) SendClientMessageToAll(COLOR_ADMIN_TOALL, "* Las Venturas party time is over.");
	}
//ChatOffCountdown
	if(MuteAll > 0){
	    MuteAll--;
	    if(MuteAll== 0){
	        SendClientMessageToAll(COLOR_SYSTEM_GM, "* The public chat is opened again.");
	    }
	}
	return 1;
}

public RacesCountdown(){
//eaglematch countdown 1
	if(eaglematchstarted == 1){
		if(eaglecountdownseconds > 0) {
		    eaglecountdownseconds--;
			if(eaglecountdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(eaglematchplayers[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~eagle DM starts in~n~~b~%d", eaglecountdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(eaglecountdownseconds == 20){
				    if(eaglematch[1] == 0){
						format(strings, sizeof(strings), "Desert eagle DM starts in %d seconds, one seat available. Type /eaglematch to join", eaglecountdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    eaglecountdownseconds = 5;
					}
				}
				if(eaglecountdownseconds == 10){
				    if(eaglematch[1] == 0){
						format(strings, sizeof(strings), "Desert eagle DM starts in %d seconds, one seat available. Type /eaglematch to join", eaglecountdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    eaglecountdownseconds = 5;
					}
				}
				if(eaglecountdownseconds == 5){
				    if(eaglematch[1] == 0){
						format(strings, sizeof(strings), "Desert eagle DM starts in %d seconds, one seat available. Type /eaglematch to join", eaglecountdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(eaglematchplayers[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerseaglematch--;
					eaglematchplayers[i]=0;
					if(playerseaglematch == 0){
						format(strings, sizeof(strings), "Desert eagle DM has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						eaglematchstarted=0;
						eaglematchinprogress=0;
						eaglecountdownseconds=0;
					}
				}
			}
		}
	}
//eagle match countdown 2
	if(eaglematchinprogress == 1){
		if(eaglecountdownseconds2 > 0) {
		    eaglecountdownseconds2--;
			for(new i=0; i<MAX_PLAYERS; i++) {
		    	if(IsPlayerConnected(i)) {
					if(deathmatcher1[i]==1){
						if(eaglecountdownseconds2 > 0) {
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~get ready!~n~~b~%d", eaglecountdownseconds2);
							GameTextForPlayer(i,strings,3000,4);
						} else {
							PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~r~GO");
							GameTextForPlayer(i,strings,3000,4);
							ResetPlayerWeapons(i);
							GivePlayerWeapon(i,24,200);
							TogglePlayerControllable(i,1);
						}
					}
				}
			}
		}
		if(playerseaglematch > 0){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(eaglematchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerseaglematch--;
					}
				}
			}
		}
	}
//chain match countdown 1
    if(chainmatchstarted == 1){
		if(chaincountdownseconds > 0) {
		    chaincountdownseconds--;
			if(chaincountdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(chainmatchplayers[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~Chainsaw massacre starts in~n~~r~%d", chaincountdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(chaincountdownseconds == 20){
				    if(chainmatch[3] == 0){
						format(strings, sizeof(strings), "Chainsaw massacre starts in %d seconds, %d seats available. Type /chainmatch to join", chaincountdownseconds,4-playerschainmatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(chaincountdownseconds == 10){
				    if(chainmatch[3] == 0){
						format(strings, sizeof(strings), "Chainsaw massacre starts in %d seconds, %d seats available. Type /chainmatch to join", chaincountdownseconds,4-playerschainmatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(chaincountdownseconds == 5){
				    if(chainmatch[3] == 0){
						format(strings, sizeof(strings), "Chainsaw massacre starts in %d seconds, %d seats available. Type /chainmatch to join", chaincountdownseconds,4-playerschainmatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		if(playerschainmatch > 0){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(chainmatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerschainmatch--;
						chainmatchprice=chainmatchprice-10000;
						if(playerschainmatch == 0){
							format(strings, sizeof(strings), "Chain saw massacre has been cancelled.");
							SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
							chainmatchstarted=0;
							chainmatchinprogress=0;
							chaincountdownseconds=0;
						}
					}
				}
			}
		}
	}
//chain match countdown 2
	if(chainmatchinprogress == 1){
		if(chaincountdownseconds2 > 0) {
		    chaincountdownseconds2--;
			for(new i=0; i<MAX_PLAYERS; i++) {
		    	if(IsPlayerConnected(i)) {
					if(deathmatcher4[i]==1){
						if(chaincountdownseconds2 > 0) {
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~get ready!~n~~b~%d", chaincountdownseconds2);
							GameTextForPlayer(i,strings,3000,4);
						} else {
							PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~r~GO");
							GameTextForPlayer(i,strings,3000,4);
							ResetPlayerWeapons(i);
							GivePlayerWeapon(i,9,1);
							TogglePlayerControllable(i,1);
						}
					}
				}
			}
		} else {
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(chainmatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerschainmatch--;
					}
				}
			}
		}
	}
//mini match countdown 1
    if(minimatchstarted == 1){
		if(minicountdownseconds > 0) {
		    minicountdownseconds--;
			if(minicountdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(minimatchplayers[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~Minigun madness starts in~n~~y~%d", minicountdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(minicountdownseconds == 20){
				    if(minimatch[5] == 0){
						format(strings, sizeof(strings), "Minigun madness starts in %d seconds, %d seats available. Type /minimatch to join", minicountdownseconds, 6-playersminimatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(minicountdownseconds == 10){
				    if(minimatch[5] == 0){
						format(strings, sizeof(strings), "Minigun madness starts in %d seconds, %d seats available. Type /minimatch to join", minicountdownseconds, 6-playersminimatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(minicountdownseconds == 5){
				    if(minimatch[5] == 0){
						format(strings, sizeof(strings), "Minigun madness starts in %d seconds, %d seats available. Type /minimatch to join", minicountdownseconds, 6-playersminimatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		if(playersminimatch > 0){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(minimatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersminimatch--;
						minimatchprice=minimatchprice-25000;
						if(playersminimatch == 0){
							format(strings, sizeof(strings), "Minigun madness has been cancelled.");
							SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
							minimatchstarted=0;
							minimatchinprogress=0;
							minicountdownseconds=0;
						}
					}
				}
			}
		}
	}
//mini match countdown 2
	if(minimatchinprogress == 1){
		if(minicountdownseconds2 > 0) {
		    minicountdownseconds2--;
			for(new i=0; i<MAX_PLAYERS; i++) {
		    	if(IsPlayerConnected(i)) {
					if(deathmatcher5[i]==1){
						if(minicountdownseconds2 > 0) {
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~get ready!~n~~b~%d", minicountdownseconds2);
							GameTextForPlayer(i,strings,3000,4);
						} else {
							PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~r~GO");
							GameTextForPlayer(i,strings,3000,4);
							ResetPlayerWeapons(i);
							GivePlayerWeapon(i,38,500);
							TogglePlayerControllable(i,1);
						}
					}
				}
			}
		} else {
		    if (minimatchinprogress==1){
				for(new i=0; i<MAX_PLAYERS; i++) {
					if(minimatchplayers[i]==1){
				    	if(!IsPlayerConnected(i)) {
							playersminimatch--;
						}
					}
				}
			}
		}
	}
//uzi match countdown 1
    if(uzimatchstarted == 1){
		if(uzicountdownseconds > 0) {
		    uzicountdownseconds--;
			if(uzicountdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(uzimatchplayers[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~crazy uzis deathmatch starts in~n~~y~%d", uzicountdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(uzicountdownseconds == 20){
				    if(uzimatch[5] == 0){
						format(strings, sizeof(strings), "crazy uzis deathmatch starts in %d seconds, %d seats available. Type /uzimatch to join", uzicountdownseconds, 6-playersuzimatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(uzicountdownseconds == 10){
				    if(uzimatch[5] == 0){
						format(strings, sizeof(strings), "crazy uzis deathmatch starts in %d seconds, %d seats available. Type /uzimatch to join", uzicountdownseconds, 6-playersuzimatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
				if(uzicountdownseconds == 5){
				    if(uzimatch[5] == 0){
						format(strings, sizeof(strings), "crazy uzis deathmatch starts in %d seconds, %d seats available. Type /uzimatch to join", uzicountdownseconds, 6-playersuzimatch);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		if(playersuzimatch > 0){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(uzimatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersuzimatch--;
						uzimatchprice=uzimatchprice-10000;
						if(playersuzimatch == 0){
							format(strings, sizeof(strings), "crazy uzis deathmatch has been cancelled.");
							SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
							uzimatchstarted=0;
							uzimatchinprogress=0;
							uzicountdownseconds=0;
						}
					}
				}
			}
		}
	}
//uzi match countdown 2
	if(uzimatchinprogress == 1){
		if(uzicountdownseconds2 > 0) {
		    uzicountdownseconds2--;
			for(new i=0; i<MAX_PLAYERS; i++) {
		    	if(IsPlayerConnected(i)) {
					if(deathmatcher6[i]==1){
						if(uzicountdownseconds2 > 0) {
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~get ready!~n~~b~%d", uzicountdownseconds2);
							GameTextForPlayer(i,strings,3000,4);
						} else {
							PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~r~GO");
							GameTextForPlayer(i,strings,3000,4);
							ResetPlayerWeapons(i);
							GivePlayerWeapon(i,28,1000);
							TogglePlayerControllable(i,1);
						}
					}
				}
			}
		} else {
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(uzimatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersuzimatch--;
					}
				}
			}
		}
	}
//russian match countdown
	if(russianmatchstarted == 1){
		if(russiancountdownseconds > 0) {
		    russiancountdownseconds--;
			if(russiancountdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(russianmatchplayers[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~russian DM starts in~n~~b~%d", russiancountdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(russiancountdownseconds == 20){
				    if(russianmatch[1] == 0){
						format(strings, sizeof(strings), "Russian roulette starts in %d seconds, one seat available. Type /rusroulette to join", russiancountdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    russiancountdownseconds = 5;
					}
				}
				if(russiancountdownseconds == 10){
				    if(russianmatch[1] == 0){
						format(strings, sizeof(strings), "Russian roulette starts in %d seconds, one seat available. Type /rusroulette to join", russiancountdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    russiancountdownseconds = 5;
					}
				}
				if(russiancountdownseconds == 5){
				    if(russianmatch[1] == 0){
						format(strings, sizeof(strings), "Russian roulette starts in %d seconds, one seat available. Type /rusroulette to join", russiancountdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(russianmatchplayers[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersrussianmatch--;
					russianmatchplayers[i]=0;
					if(playersrussianmatch == 0){
						format(strings, sizeof(strings), "Russian roulette has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						russianmatchstarted=0;
						russianmatchinprogress=0;
						russiancountdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (russianmatchinprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(russianmatchplayers[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersrussianmatch--;
					}
				}
			}
		}
	}
//dragrace 1 countdown
	if(dragrace1started == 1){
		if(dragrace1countdownseconds > 0) {
		    dragrace1countdownseconds--;
			if(dragrace1countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace1players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 1 starts in~n~~b~%d", dragrace1countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace1countdownseconds == 20){
				    if(dragrace1[1] == 0){
						format(strings, sizeof(strings), "Drag race type 1 starts in %d seconds, one seat available. Type /dragrace1 to join", dragrace1countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace1countdownseconds = 5;
					}
				}
				if(dragrace1countdownseconds == 10){
				    if(dragrace1[1] == 0){
						format(strings, sizeof(strings), "Drag race type 1 starts in %d seconds, one seat available. Type /dragrace1 to join", dragrace1countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace1countdownseconds = 5;
					}
				}
				if(dragrace1countdownseconds == 5){
				    if(dragrace1[1] == 0){
						format(strings, sizeof(strings), "Drag race type 1 starts in %d seconds, one seat available. Type /dragrace1 to join", dragrace1countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace1players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace1--;
					dragrace1players[i]=0;
					if(playersdragrace1 == 0){
						format(strings, sizeof(strings), "Drag race type 1 DM has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace1started=0;
						dragrace1inprogress=0;
						dragrace1countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace1inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace1players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace1--;
					}
				}
			}
		}
	}
//dragrace 2 countdown
	if(dragrace2started == 1){
		if(dragrace2countdownseconds > 0) {
		    dragrace2countdownseconds--;
			if(dragrace2countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace2players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 2 starts in~n~~b~%d", dragrace2countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace2countdownseconds == 20){
				    if(dragrace2[3] == 0){
						format(strings, sizeof(strings), "Drag race type 2 starts in %d seconds, %d seat available. Type /dragrace2 to join", dragrace2countdownseconds, 4-playersdragrace2);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace2countdownseconds = 5;
					}
				}
				if(dragrace2countdownseconds == 10){
				    if(dragrace2[3] == 0){
						format(strings, sizeof(strings), "Drag race type 2 starts in %d seconds, %d seat available. Type /dragrace2 to join", dragrace2countdownseconds, 4-playersdragrace2);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace2countdownseconds = 5;
					}
				}
				if(dragrace2countdownseconds == 5){
				    if(dragrace2[3] == 0){
						format(strings, sizeof(strings), "Drag race type 2 starts in %d seconds, %d seat available. Type /dragrace2 to join", dragrace2countdownseconds, 4-playersdragrace2);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace2players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace2--;
					dragrace2players[i]=0;
					if(playersdragrace2 == 0){
						format(strings, sizeof(strings), "Drag race type 2 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace2started=0;
						dragrace2inprogress=0;
						dragrace2countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace2inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace2players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace2--;
					}
				}
			}
		}
	}
//drag race 3 countdown
	if(dragrace3started == 1){
		if(dragrace3countdownseconds > 0) {
		    dragrace3countdownseconds--;
			if(dragrace3countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace3players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 3 starts in~n~~b~%d", dragrace3countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace3countdownseconds == 20){
				    if(dragrace3[1] == 0){
						format(strings, sizeof(strings), "Drag race type 3 starts in %d seconds, one seat available. Type /dragrace3 to join", dragrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace3countdownseconds = 5;
					}
				}
				if(dragrace3countdownseconds == 10){
				    if(dragrace3[1] == 0){
						format(strings, sizeof(strings), "Drag race type 3 starts in %d seconds, one seat available. Type /dragrace3 to join", dragrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace3countdownseconds = 5;
					}
				}
				if(dragrace3countdownseconds == 5){
				    if(dragrace3[1] == 0){
						format(strings, sizeof(strings), "Drag race type 3 starts in %d seconds, one seat available. Type /dragrace3 to join", dragrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace3players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace3--;
					dragrace3players[i]=0;
					if(playersdragrace3 == 0){
						format(strings, sizeof(strings), "Drag race type 3 DM has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace3started=0;
						dragrace3inprogress=0;
						dragrace3countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace3inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace3players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace3--;
					}
				}
			}
		}
	}
//dragrace 4 countdown
	if(dragrace4started == 1){
		if(dragrace4countdownseconds > 0) {
		    dragrace4countdownseconds--;
			if(dragrace4countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace4players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 4 starts in~n~~b~%d", dragrace4countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace4countdownseconds == 20){
				    if(dragrace4[1] == 0){
						format(strings, sizeof(strings), "Drag race type 4 starts in %d seconds, one seat available. Type /dragrace4 to join", dragrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace4countdownseconds = 5;
					}
				}
				if(dragrace4countdownseconds == 10){
				    if(dragrace4[1] == 0){
						format(strings, sizeof(strings), "Drag race type 4 starts in %d seconds, one seat available. Type /dragrace4 to join", dragrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace4countdownseconds = 5;
					}
				}
				if(dragrace4countdownseconds == 5){
				    if(dragrace4[1] == 0){
						format(strings, sizeof(strings), "Drag race type 4 starts in %d seconds, one seat available. Type /dragrace4 to join", dragrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace4players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace4--;
					dragrace4players[i]=0;
					if(playersdragrace4 == 0){
						format(strings, sizeof(strings), "Drag race type 4 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace4started=0;
						dragrace4inprogress=0;
						dragrace4countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace4inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace4players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace4--;
					}
				}
			}
		}
	}
//dragrace 5 countdown
	if(dragrace5started == 1){
		if(dragrace5countdownseconds > 0) {
		    dragrace5countdownseconds--;
			if(dragrace5countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace5players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 5 starts in~n~~b~%d", dragrace5countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace5countdownseconds == 20){
				    if(dragrace5[1] == 0){
						format(strings, sizeof(strings), "Drag race type 5 starts in %d seconds, one seat available. Type /dragrace5 to join", dragrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace5countdownseconds = 5;
					}
				}
				if(dragrace5countdownseconds == 10){
				    if(dragrace5[1] == 0){
						format(strings, sizeof(strings), "Drag race type 5 starts in %d seconds, one seat available. Type /dragrace5 to join", dragrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace5countdownseconds = 5;
					}
				}
				if(dragrace5countdownseconds == 5){
				    if(dragrace5[1] == 0){
						format(strings, sizeof(strings), "Drag race type 5 starts in %d seconds, one seat available. Type /dragrace5 to join", dragrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace5players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace5--;
					dragrace5players[i]=0;
					if(playersdragrace5 == 0){
						format(strings, sizeof(strings), "Drag race type 5 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace5started=0;
						dragrace5inprogress=0;
						dragrace5countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace5inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace5players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace5--;
					}
				}
			}
		}
	}
//dragrace 6 countdown
	if(dragrace6started == 1){
		if(dragrace6countdownseconds > 0) {
		    dragrace6countdownseconds--;
			if(dragrace6countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace6players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 6 starts in~n~~b~%d", dragrace6countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace6countdownseconds == 20){
				    if(dragrace6[1] == 0){
						format(strings, sizeof(strings), "Drag race type 6 starts in %d seconds, one seat available. Type /dragrace6 to join", dragrace6countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace6countdownseconds = 5;
					}
				}
				if(dragrace6countdownseconds == 10){
				    if(dragrace6[1] == 0){
						format(strings, sizeof(strings), "Drag race type 6 starts in %d seconds, one seat available. Type /dragrace6 to join", dragrace6countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace6countdownseconds = 5;
					}
				}
				if(dragrace6countdownseconds == 5){
				    if(dragrace6[1] == 0){
						format(strings, sizeof(strings), "Drag race type 6 starts in %d seconds, one seat available. Type /dragrace6 to join", dragrace6countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace6players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace6--;
					dragrace6players[i]=0;
					if(playersdragrace6 == 0){
						format(strings, sizeof(strings), "Drag race type 6 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace6started=0;
						dragrace6inprogress=0;
						dragrace6countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace6inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace6players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace6--;
					}
				}
			}
		}
	}
//dragrace 7 countdown
	if(dragrace7started == 1){
		if(dragrace7countdownseconds > 0) {
		    dragrace7countdownseconds--;
			if(dragrace7countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace7players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 7 starts in~n~~b~%d", dragrace7countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace7countdownseconds == 20){
				    if(dragrace7[1] == 0){
						format(strings, sizeof(strings), "Drag race type 7 starts in %d seconds, one seat available. Type /dragrace7 to join", dragrace7countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace7countdownseconds = 5;
					}
				}
				if(dragrace7countdownseconds == 10){
				    if(dragrace7[1] == 0){
						format(strings, sizeof(strings), "Drag race type 7 starts in %d seconds, one seat available. Type /dragrace7 to join", dragrace7countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace7countdownseconds = 5;
					}
				}
				if(dragrace7countdownseconds == 5){
				    if(dragrace7[1] == 0){
						format(strings, sizeof(strings), "Drag race type 7 starts in %d seconds, one seat available. Type /dragrace7 to join", dragrace7countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace7players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace7--;
					dragrace7players[i]=0;
					if(playersdragrace7 == 0){
						format(strings, sizeof(strings), "Drag race type 7 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace7started=0;
						dragrace7inprogress=0;
						dragrace7countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace7inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace7players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace7--;
					}
				}
			}
		}
	}
//dragrace 8 countdown
	if(dragrace8started == 1){
		if(dragrace8countdownseconds > 0) {
		    dragrace8countdownseconds--;
			if(dragrace8countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace8players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 8 starts in~n~~b~%d", dragrace8countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace8countdownseconds == 20){
				    if(dragrace8[1] == 0){
						format(strings, sizeof(strings), "Drag race type 8 starts in %d seconds, one seat available. Type /dragrace8 to join", dragrace8countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace8countdownseconds = 5;
					}
				}
				if(dragrace8countdownseconds == 10){
				    if(dragrace8[1] == 0){
						format(strings, sizeof(strings), "Drag race type 8 starts in %d seconds, one seat available. Type /dragrace8 to join", dragrace8countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace8countdownseconds = 5;
					}
				}
				if(dragrace8countdownseconds == 5){
				    if(dragrace8[1] == 0){
						format(strings, sizeof(strings), "Drag race type 8 starts in %d seconds, one seat available. Type /dragrace8 to join", dragrace8countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace8players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace8--;
					dragrace8players[i]=0;
					if(playersdragrace8 == 0){
						format(strings, sizeof(strings), "Drag race type 8 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace8started=0;
						dragrace8inprogress=0;
						dragrace8countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace8inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace8players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace8--;
					}
				}
			}
		}
	}
//dragrace 9 countdown
	if(dragrace9started == 1){
		if(dragrace9countdownseconds > 0) {
		    dragrace9countdownseconds--;
			if(dragrace9countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(dragrace9players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~drag race type 9 starts in~n~~b~%d", dragrace9countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(dragrace9countdownseconds == 20){
				    if(dragrace9[1] == 0){
						format(strings, sizeof(strings), "Drag race type 9 starts in %d seconds, one seat available. Type /dragrace9 to join", dragrace9countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace9countdownseconds = 5;
					}
				}
				if(dragrace9countdownseconds == 10){
				    if(dragrace9[1] == 0){
						format(strings, sizeof(strings), "Drag race type 9 starts in %d seconds, one seat available. Type /dragrace9 to join", dragrace9countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    dragrace9countdownseconds = 5;
					}
				}
				if(dragrace9countdownseconds == 5){
				    if(dragrace9[1] == 0){
						format(strings, sizeof(strings), "Drag race type 9 starts in %d seconds, one seat available. Type /dragrace9 to join", dragrace9countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(dragrace9players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersdragrace9--;
					dragrace9players[i]=0;
					if(playersdragrace9 == 0){
						format(strings, sizeof(strings), "Drag race type 9 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						dragrace9started=0;
						dragrace9inprogress=0;
						dragrace9countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (dragrace9inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(dragrace9players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersdragrace9--;
					}
				}
			}
		}
	}
//sprintrace 1 countdown
	if(sprintrace1started == 1){
		if(sprintrace1countdownseconds > 0) {
		    sprintrace1countdownseconds--;
			if(sprintrace1countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace1players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~Sprint race type 1 starts in~n~~b~%d", sprintrace1countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace1countdownseconds == 20){
				    if(sprintrace1[3] == 0){
						format(strings, sizeof(strings), "Sprint race type 1 starts in %d seconds, %d seat available. Type /sprintrace1 to join", sprintrace1countdownseconds, 4-playerssprintrace1);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace1countdownseconds = 5;
					}
				}
				if(sprintrace1countdownseconds == 10){
				    if(sprintrace1[3] == 0){
						format(strings, sizeof(strings), "Sprint race type 1 starts in %d seconds, %d seat available. Type /sprintrace1 to join", sprintrace1countdownseconds, 4-playerssprintrace1);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace1countdownseconds = 5;
					}
				}
				if(sprintrace1countdownseconds == 5){
				    if(sprintrace1[3] == 0){
						format(strings, sizeof(strings), "Sprint race type 1 starts in %d seconds, %d seat available. Type /sprintrace1 to join", sprintrace1countdownseconds, 4-playerssprintrace1);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace1players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace1--;
					sprintrace1players[i]=0;
					if(playerssprintrace1 == 0){
						format(strings, sizeof(strings), "Sprint race type 1 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace1started=0;
						sprintrace1inprogress=0;
						sprintrace1countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace1inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace1players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace1--;
					}
				}
			}
		}
	}
//sprint race 2 countdown
	if(sprintrace2started == 1){
		if(sprintrace2countdownseconds > 0) {
		    sprintrace2countdownseconds--;
			if(sprintrace2countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace2players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~Sprint race type 2 starts in~n~~b~%d", sprintrace2countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace2countdownseconds == 20){
				    if(sprintrace2[3] == 0){
						format(strings, sizeof(strings), "Sprint race type 2 starts in %d seconds, %d seat available. Type /sprintrace2 to join", sprintrace2countdownseconds, 4-playerssprintrace2);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace2countdownseconds = 5;
					}
				}
				if(sprintrace2countdownseconds == 10){
				    if(sprintrace2[3] == 0){
						format(strings, sizeof(strings), "Sprint race type 2 starts in %d seconds, %d seat available. Type /sprintrace2 to join", sprintrace2countdownseconds, 4-playerssprintrace2);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace2countdownseconds = 5;
					}
				}
				if(sprintrace2countdownseconds == 5){
				    if(sprintrace2[3] == 0){
						format(strings, sizeof(strings), "Sprint race type 2 starts in %d seconds, %d seat available. Type /sprintrace2 to join", sprintrace2countdownseconds, 4-playerssprintrace2);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace2players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace2--;
					sprintrace2players[i]=0;
					if(playerssprintrace2 == 0){
						format(strings, sizeof(strings), "Sprint race type 2 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace2started=0;
						sprintrace2inprogress=0;
						sprintrace2countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace2inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace2players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace2--;
					}
				}
			}
		}
	}
//sprint race 3 countdown
	if(sprintrace3started == 1){
		if(sprintrace3countdownseconds > 0) {
		    sprintrace3countdownseconds--;
			if(sprintrace3countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace3players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~sprint race type 3 starts in~n~~b~%d", sprintrace3countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace3countdownseconds == 20){
				    if(sprintrace3[1] == 0){
						format(strings, sizeof(strings), "Sprint race type 3 starts in %d seconds, one seat available. Type /sprintrace3 to join", sprintrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace3countdownseconds = 5;
					}
				}
				if(sprintrace3countdownseconds == 10){
				    if(sprintrace3[1] == 0){
						format(strings, sizeof(strings), "Sprint race type 3 starts in %d seconds, one seat available. Type /sprintrace3 to join", sprintrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace3countdownseconds = 5;
					}
				}
				if(sprintrace3countdownseconds == 5){
				    if(sprintrace3[1] == 0){
						format(strings, sizeof(strings), "Sprint race type 3 starts in %d seconds, one seat available. Type /sprintrace3 to join", sprintrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace3players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace3--;
					sprintrace3players[i]=0;
					if(playerssprintrace3 == 0){
						format(strings, sizeof(strings), "Sprint race type 3 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace3started=0;
						sprintrace3inprogress=0;
						sprintrace3countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace3inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace3players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace3--;
					}
				}
			}
		}
	}
//sprint race 4 countdown
	if(sprintrace4started == 1){
		if(sprintrace4countdownseconds > 0) {
		    sprintrace4countdownseconds--;
			if(sprintrace4countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace4players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~sprintrace type 4 starts in~n~~b~%d", sprintrace4countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace4countdownseconds == 20){
				    if(sprintrace4[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 4 starts in %d seconds, one seat available. Type /sprintrace4 to join", sprintrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace4countdownseconds = 5;
					}
				}
				if(sprintrace4countdownseconds == 10){
				    if(sprintrace4[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 4 starts in %d seconds, one seat available. Type /sprintrace4 to join", sprintrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace4countdownseconds = 5;
					}
				}
				if(sprintrace4countdownseconds == 5){
				    if(sprintrace4[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 4 starts in %d seconds, one seat available. Type /sprintrace4 to join", sprintrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace4players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace4--;
					sprintrace4players[i]=0;
					if(playerssprintrace4 == 0){
						format(strings, sizeof(strings), "Sprintrace type 4 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace4started=0;
						sprintrace4inprogress=0;
						sprintrace4countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace4inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace4players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace4--;
					}
				}
			}
		}
	}
//sprint race 5 countdown
	if(sprintrace5started == 1){
		if(sprintrace5countdownseconds > 0) {
		    sprintrace5countdownseconds--;
			if(sprintrace5countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace5players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~sprintrace type 5 starts in~n~~b~%d", sprintrace5countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace5countdownseconds == 20){
				    if(sprintrace5[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 5 starts in %d seconds, one seat available. Type /sprintrace5 to join", sprintrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace5countdownseconds = 5;
					}
				}
				if(sprintrace5countdownseconds == 10){
				    if(sprintrace5[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 5 starts in %d seconds, one seat available. Type /sprintrace5 to join", sprintrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace5countdownseconds = 5;
					}
				}
				if(sprintrace5countdownseconds == 5){
				    if(sprintrace5[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 5 starts in %d seconds, one seat available. Type /sprintrace5 to join", sprintrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace5players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace5--;
					sprintrace5players[i]=0;
					if(playerssprintrace5 == 0){
						format(strings, sizeof(strings), "Sprintrace type 5 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace5started=0;
						sprintrace5inprogress=0;
						sprintrace5countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace5inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace5players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace5--;
					}
				}
			}
		}
	}
//sprint race 6 countdown
	if(sprintrace6started == 1){
		if(sprintrace6countdownseconds > 0) {
		    sprintrace6countdownseconds--;
			if(sprintrace6countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace6players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~sprintrace type 6 starts in~n~~b~%d", sprintrace6countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace6countdownseconds == 20){
				    if(sprintrace6[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 6 starts in %d seconds, one seat available. Type /sprintrace6 to join", sprintrace6countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace6countdownseconds = 5;
					}
				}
				if(sprintrace6countdownseconds == 10){
				    if(sprintrace6[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 6 starts in %d seconds, one seat available. Type /sprintrace6 to join", sprintrace6countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace6countdownseconds = 5;
					}
				}
				if(sprintrace6countdownseconds == 5){
				    if(sprintrace6[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 6 starts in %d seconds, one seat available. Type /sprintrace6 to join", sprintrace6countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace6players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace6--;
					sprintrace6players[i]=0;
					if(playerssprintrace6 == 0){
						format(strings, sizeof(strings), "Sprintrace type 6 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace6started=0;
						sprintrace6inprogress=0;
						sprintrace6countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace6inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace6players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace6--;
					}
				}
			}
		}
	}
//sprint race 7 countdown
	if(sprintrace7started == 1){
		if(sprintrace7countdownseconds > 0) {
		    sprintrace7countdownseconds--;
			if(sprintrace7countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(sprintrace7players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~sprintrace type 7 starts in~n~~b~%d", sprintrace7countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(sprintrace7countdownseconds == 20){
				    if(sprintrace7[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 7 starts in %d seconds, one seat available. Type /sprintrace7 to join", sprintrace7countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace7countdownseconds = 5;
					}
				}
				if(sprintrace7countdownseconds == 10){
				    if(sprintrace7[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 7 starts in %d seconds, one seat available. Type /sprintrace7 to join", sprintrace7countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    sprintrace7countdownseconds = 5;
					}
				}
				if(sprintrace7countdownseconds == 5){
				    if(sprintrace7[1] == 0){
						format(strings, sizeof(strings), "Sprintrace type 7 starts in %d seconds, one seat available. Type /sprintrace7 to join", sprintrace7countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(sprintrace7players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playerssprintrace7--;
					sprintrace7players[i]=0;
					if(playerssprintrace7 == 0){
						format(strings, sizeof(strings), "Sprintrace type 7 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						sprintrace7started=0;
						sprintrace7inprogress=0;
						sprintrace7countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (sprintrace7inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(sprintrace7players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playerssprintrace7--;
					}
				}
			}
		}
	}
//motor race 1 countdown
	if(motorrace1started == 1){
		if(motorrace1countdownseconds > 0) {
		    motorrace1countdownseconds--;
			if(motorrace1countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(motorrace1players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~motor race type 1 starts in~n~~b~%d", motorrace1countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(motorrace1countdownseconds == 20){
				    if(motorrace1[1] == 0){
						format(strings, sizeof(strings), "Motor race type 1 starts in %d seconds, one seat available. Type /motorrace1 to join", motorrace1countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace1countdownseconds = 5;
					}
				}
				if(motorrace1countdownseconds == 10){
				    if(motorrace1[1] == 0){
						format(strings, sizeof(strings), "Motor race type 1 starts in %d seconds, one seat available. Type /motorrace1 to join", motorrace1countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace1countdownseconds = 5;
					}
				}
				if(motorrace1countdownseconds == 5){
				    if(motorrace1[1] == 0){
						format(strings, sizeof(strings), "Motor race type 1 starts in %d seconds, one seat available. Type /motorrace1 to join", motorrace1countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(motorrace1players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersmotorrace1--;
					motorrace1players[i]=0;
					if(playersmotorrace1 == 0){
						format(strings, sizeof(strings), "Motor race type 1 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						motorrace1started=0;
						motorrace1inprogress=0;
						motorrace1countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (motorrace1inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(motorrace1players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersmotorrace1--;
					}
				}
			}
		}
	}
//motor race 2 countdown
	if(motorrace2started == 1){
		if(motorrace2countdownseconds > 0) {
		    motorrace2countdownseconds--;
			if(motorrace2countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(motorrace2players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~motor race type 2 starts in~n~~b~%d", motorrace2countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(motorrace2countdownseconds == 20){
				    if(motorrace2[1] == 0){
						format(strings, sizeof(strings), "Motor race type 2 starts in %d seconds, one seat available. Type /motorrace2 to join", motorrace2countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace2countdownseconds = 5;
					}
				}
				if(motorrace2countdownseconds == 10){
				    if(motorrace2[1] == 0){
						format(strings, sizeof(strings), "Motor race type 2 starts in %d seconds, one seat available. Type /motorrace2 to join", motorrace2countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace2countdownseconds = 5;
					}
				}
				if(motorrace2countdownseconds == 5){
				    if(motorrace2[1] == 0){
						format(strings, sizeof(strings), "Motor race type 2 starts in %d seconds, one seat available. Type /motorrace2 to join", motorrace2countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(motorrace2players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersmotorrace2--;
					motorrace2players[i]=0;
					if(playersmotorrace2 == 0){
						format(strings, sizeof(strings), "Motor race type 2 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						motorrace2started=0;
						motorrace2inprogress=0;
						motorrace2countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (motorrace2inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(motorrace2players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersmotorrace2--;
					}
				}
			}
		}
	}
//motor race 3 countdown
	if(motorrace3started == 1){
		if(motorrace3countdownseconds > 0) {
		    motorrace3countdownseconds--;
			if(motorrace3countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(motorrace3players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~motor race type 3 starts in~n~~b~%d", motorrace3countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(motorrace3countdownseconds == 20){
				    if(motorrace3[1] == 0){
						format(strings, sizeof(strings), "Motor race type 3 starts in %d seconds, one seat available. Type /motorrace3 to join", motorrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace3countdownseconds = 5;
					}
				}
				if(motorrace3countdownseconds == 10){
				    if(motorrace3[1] == 0){
						format(strings, sizeof(strings), "Motor race type 3 starts in %d seconds, one seat available. Type /motorrace3 to join", motorrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace3countdownseconds = 5;
					}
				}
				if(motorrace3countdownseconds == 5){
				    if(motorrace3[1] == 0){
						format(strings, sizeof(strings), "Motor race type 3 starts in %d seconds, one seat available. Type /motorrace3 to join", motorrace3countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(motorrace3players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersmotorrace3--;
					motorrace3players[i]=0;
					if(playersmotorrace3 == 0){
						format(strings, sizeof(strings), "Motor race type 3 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						motorrace3started=0;
						motorrace3inprogress=0;
						motorrace3countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (motorrace3inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(motorrace3players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersmotorrace3--;
					}
				}
			}
		}
	}
//motor race 4 countdown
	if(motorrace4started == 1){
		if(motorrace4countdownseconds > 0) {
		    motorrace4countdownseconds--;
			if(motorrace4countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(motorrace4players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~motor race type 4 starts in~n~~b~%d", motorrace4countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(motorrace4countdownseconds == 20){
				    if(motorrace4[1] == 0){
						format(strings, sizeof(strings), "Motor race type 4 starts in %d seconds, one seat available. Type /motorrace4 to join", motorrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace4countdownseconds = 5;
					}
				}
				if(motorrace4countdownseconds == 10){
				    if(motorrace4[1] == 0){
						format(strings, sizeof(strings), "Motor race type 4 starts in %d seconds, one seat available. Type /motorrace4 to join", motorrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace4countdownseconds = 5;
					}
				}
				if(motorrace4countdownseconds == 5){
				    if(motorrace4[1] == 0){
						format(strings, sizeof(strings), "Motor race type 4 starts in %d seconds, one seat available. Type /motorrace4 to join", motorrace4countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(motorrace4players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersmotorrace4--;
					motorrace4players[i]=0;
					if(playersmotorrace4 == 0){
						format(strings, sizeof(strings), "Motor race type 4 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						motorrace4started=0;
						motorrace4inprogress=0;
						motorrace4countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (motorrace4inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(motorrace4players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersmotorrace4--;
					}
				}
			}
		}
	}
//motor race 5 countdown{
	if(motorrace5started == 1){
		if(motorrace5countdownseconds > 0) {
		    motorrace5countdownseconds--;
			if(motorrace5countdownseconds > 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
			    	if(IsPlayerConnected(i)) {
						if(motorrace5players[i]==1){
							PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
							format(strings, sizeof(strings), "~w~motor race type 5 starts in~n~~b~%d", motorrace5countdownseconds);
							GameTextForPlayer(i,strings,3000,4);
						}
					}
				}
				if(motorrace5countdownseconds == 20){
				    if(motorrace5[1] == 0){
						format(strings, sizeof(strings), "Motor race type 5 starts in %d seconds, one seat available. Type /motorrace5 to join", motorrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace5countdownseconds = 5;
					}
				}
				if(motorrace5countdownseconds == 10){
				    if(motorrace5[1] == 0){
						format(strings, sizeof(strings), "Motor race type 5 starts in %d seconds, one seat available. Type /motorrace5 to join", motorrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					} else {
					    motorrace5countdownseconds = 5;
					}
				}
				if(motorrace5countdownseconds == 5){
				    if(motorrace5[1] == 0){
						format(strings, sizeof(strings), "Motor race type 5 starts in %d seconds, one seat available. Type /motorrace5 to join", motorrace5countdownseconds);
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
					}
				}
			}
		}
		for(new i=0; i<MAX_PLAYERS; i++) {
			if(motorrace5players[i]==1){
		    	if(!IsPlayerConnected(i)) {
					playersmotorrace5--;
					motorrace5players[i]=0;
					if(playersmotorrace5 == 0){
						format(strings, sizeof(strings), "Motor race type 5 has been cancelled.");
						SendClientMessageToAll(COLOR_SYSTEM_PM, strings);
						motorrace5started=0;
						motorrace5inprogress=0;
						motorrace5countdownseconds=0;
					}
				}
			}
		}
	} else {
	    if (motorrace5inprogress==1){
			for(new i=0; i<MAX_PLAYERS; i++) {
				if(motorrace5players[i]==1){
			    	if(!IsPlayerConnected(i)) {
						playersmotorrace5--;
					}
				}
			}
		}
	}
//dragraces countdown 2
    if(dragrace1started == 1){
		if(DragRaceCountdown2Seconds != 0) {
		    DragRaceCountdown2Seconds--;
			if(DragRaceCountdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher7[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace1TimeLimit=0;
				DragRace1Finish = SetTimer("DragRace1Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher7[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRaceCountdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace2started == 1){
		if(DragRace2Countdown2Seconds != 0) {
		    DragRace2Countdown2Seconds--;
			if(DragRace2Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher8[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace2TimeLimit=0;
				DragRace2Finish = SetTimer("DragRace2Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher8[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace2Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace3started == 1){
		if(DragRace3Countdown2Seconds != 0) {
		    DragRace3Countdown2Seconds--;
			if(DragRace3Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher9[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace3TimeLimit=0;
				DragRace3Finish = SetTimer("DragRace3Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher9[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace3Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace4started == 1){
		if(DragRace4Countdown2Seconds != 0) {
		    DragRace4Countdown2Seconds--;
			if(DragRace4Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher11[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace4TimeLimit=0;
				DragRace4Finish = SetTimer("DragRace4Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher11[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace4Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace5started == 1){
		if(DragRace5Countdown2Seconds != 0) {
		    DragRace5Countdown2Seconds--;
			if(DragRace5Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher13[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace5TimeLimit=0;
				DragRace5Finish = SetTimer("DragRace5Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher13[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace5Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace6started == 1){
		if(DragRace6Countdown2Seconds != 0) {
		    DragRace6Countdown2Seconds--;
			if(DragRace6Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher14[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						dragracer[i]=0;
						TogglePlayerControllable(i, 1);
					}
				}
				DragRace6TimeLimit=0;
				DragRace6Finish = SetTimer("DragRace6Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher14[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace6Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace7started == 1){
		if(DragRace7Countdown2Seconds != 0) {
		    DragRace7Countdown2Seconds--;
			if(DragRace7Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher15[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace7TimeLimit=0;
				DragRace7Finish = SetTimer("DragRace7Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher15[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace7Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace8started == 1){
		if(DragRace8Countdown2Seconds != 0) {
		    DragRace8Countdown2Seconds--;
			if(DragRace8Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher16[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace8TimeLimit=0;
				DragRace8Finish = SetTimer("DragRace8Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher16[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace8Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(dragrace9started == 1){
		if(DragRace9Countdown2Seconds != 0) {
		    DragRace9Countdown2Seconds--;
			if(DragRace9Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher17[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				DragRace9TimeLimit=0;
				DragRace9Finish = SetTimer("DragRace9Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher17[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", DragRace9Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace1started == 1){
		if(SprintRace1Countdown2Seconds != 0) {
		    SprintRace1Countdown2Seconds--;
			if(SprintRace1Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher10[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
	    		    	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				SprintRace1TimeLimit=0;
				SprintRace1Finish = SetTimer("SprintRace1Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher10[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace1Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace2started == 1){
		if(SprintRace2Countdown2Seconds != 0) {
		    SprintRace2Countdown2Seconds--;
			if(SprintRace2Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher12[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						dragracer[i]=0;
					}
				}
				SprintRace2TimeLimit=0;
				SprintRace2Finish = SetTimer("SprintRace2Finishing",500,1);
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher12[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace2Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace3started == 1){
		if(SprintRace3Countdown2Seconds != 0) {
		    SprintRace3Countdown2Seconds--;
			if(SprintRace3Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher18[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher18[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace3Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace4started == 1){
		if(SprintRace4Countdown2Seconds != 0) {
		    SprintRace4Countdown2Seconds--;
			if(SprintRace4Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher19[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher19[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace4Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace5started == 1){
		if(SprintRace5Countdown2Seconds != 0) {
		    SprintRace5Countdown2Seconds--;
			if(SprintRace5Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher20[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher20[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace5Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace6started == 1){
		if(SprintRace6Countdown2Seconds != 0) {
		    SprintRace6Countdown2Seconds--;
			if(SprintRace6Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher21[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher21[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace6Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(sprintrace7started == 1){
		if(SprintRace7Countdown2Seconds != 0) {
		    SprintRace7Countdown2Seconds--;
			if(SprintRace7Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher22[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher22[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", SprintRace7Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(motorrace1started == 1){
		if(MotorRace1Countdown2Seconds != 0) {
		    MotorRace1Countdown2Seconds--;
			if(MotorRace1Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher24[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher24[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", MotorRace1Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(motorrace2started == 1){
		if(MotorRace2Countdown2Seconds != 0) {
		    MotorRace2Countdown2Seconds--;
			if(MotorRace2Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher25[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher25[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", MotorRace2Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(motorrace3started == 1){
		if(MotorRace3Countdown2Seconds != 0) {
		    MotorRace3Countdown2Seconds--;
			if(MotorRace3Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher26[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher26[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", MotorRace3Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(motorrace4started == 1){
		if(MotorRace4Countdown2Seconds != 0) {
		    MotorRace4Countdown2Seconds--;
			if(MotorRace4Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher27[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher27[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", MotorRace4Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
    if(motorrace5started == 1){
		if(MotorRace5Countdown2Seconds != 0) {
		    MotorRace5Countdown2Seconds--;
			if(MotorRace5Countdown2Seconds == 0) {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher28[i]==1) {
						PlayerPlaySound(i,1057,X250[i],Y250[i],Z250[i]);
			        	GameTextForPlayer(i,"~r~GO",3000,4);
						TogglePlayerControllable(i, 1);
						SendClientMessage(i, COLOR_ADMIN_TOALL, "* If you want to cancel your participation in this race, type /cancelrace .");
						dragracer[i]=0;
						RaceTime[i]=0;
					    RaceTiming[i] = 1;
					}
				}
			} else {
				for(new i=0; i<MAX_PLAYERS; i++) {
				    if(IsPlayerConnected(i) && deathmatcher28[i]==1) {
						PlayerPlaySound(i,1056,X250[i],Y250[i],Z250[i]);
						format(strings, sizeof(strings), "~r~%d", MotorRace5Countdown2Seconds);
						GameTextForPlayer(i,strings,3000,4);
					}
				}
			}
		}
	}
	return 1;
}
public SecondRoutine(){
//variable definition
	new j,propowner;
	new owner, diffspeed;
	new spawnlocje;
	new rnd1, VehicleID;
	new Float:X, Float:Y, Float:Z;
	new correct, correctpassword, free;
	new victimid, correcttime;
	new victimname[MAX_PLAYER_NAME];
	new delivered;
	new player_zone_before;
//////////Routines/////////////////
    for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
        if (IsPlayerConnected(playerid)){
			if(logged[playerid] == 1 && spawned[playerid] == 1){
//Disarming players
	            if (PlayerDisarmDelay[playerid] > 0) {
	                PlayerDisarmDelay[playerid]--;
	            } else {
					if(Z250[playerid] > 900 && DisarmedPlayer[playerid] == 1) DisarmedPlayer[playerid] = 0;
					if(SpawnedPlayer[playerid] == 0){
						if(X250[playerid] >= LVBoundaries[0] && X250[playerid] <= LVBoundaries[2] && Y250[playerid] >= LVBoundaries[1] && Y250[playerid] <= LVBoundaries[3] && Z250[playerid] < 900){
							if(DisarmedPlayer[playerid] == 0) {
								if(DisplayMessage[playerid] == 0){
									SendClientMessage(playerid, COLOR_DISARMING , "* You are either entering Las Venturas or spawning there.");
									SendClientMessage(playerid, COLOR_DISARMING , "* Las Venturas is a no-deathmatch zone. To ensure this you loose all your guns.");
									SendClientMessage(playerid, COLOR_DISARMING , "* You can only keep your melee weapon. When you leave Las Venturas, you will get your guns back.");
									SendClientMessage(playerid, COLOR_DISARMING , "* Note: this is only valid for respawn weapons bought with /bw and the default desert eagle.");
								} else {
								    DisplayMessage[playerid] = 0;
								}
								ResetPlayerWeapons(playerid);
								if(melee[playerid] != 0){
								    if(melee[playerid] == 5){
									    GivePlayerWeapon(playerid, melee[playerid], 1);
									} else {
									    GivePlayerWeapon(playerid, 4, 1);
									}
								}
								if(gift[playerid] != 0){
								    GivePlayerWeapon(playerid, gift[playerid], 1);
								}
								DisarmedPlayer[playerid] = 1;
							}
						} else {
						    if(DisarmedPlayer[playerid] == 1){
								SendClientMessage(playerid, COLOR_DISARMING , "* You are leaving Las Venturas and you get back your respawn weapons,");
								SendClientMessage(playerid, COLOR_DISARMING , "* or your desert eagle if you do not have respawn weapons.");
							    if(shotgun[playerid] != 0){
								    GivePlayerWeapon(playerid, shotgun[playerid], shotgunammo[playerid]);
								}
							    if(smg[playerid] != 0){
								    GivePlayerWeapon(playerid, smg[playerid], smgammo[playerid]);
								}
							    if(rifle[playerid] != 0){
								    GivePlayerWeapon(playerid, rifle[playerid], rifleammo[playerid]);
								}
								if(gift[playerid] != 0){
								    GivePlayerWeapon(playerid, gift[playerid], 1);
								}
							    if(pistol[playerid] != 0){
								    GivePlayerWeapon(playerid, pistol[playerid], pistolammo[playerid]);
								} else {
								    GivePlayerWeapon(playerid, 24, 3000);
								}
								DisarmedPlayer[playerid] = 0;
							}
						}
					} else {
					    SpawnedPlayer[playerid] = 0;
					}
				}
//Vehicles free
		        if(IsPlayerInAnyVehicle(playerid) && GetPlayerState(playerid) == PLAYER_STATE_DRIVER){
//Ambulance free
		            if(IsPlayerInVehicle(playerid,201) || IsPlayerInVehicle(playerid,202)){
						if(propertyOwner[P_ANGELMED] != playerid && propertyOwner[P_ELQMED] != playerid){
							if(propertyOwner[P_ELQMED] != playerid){
								SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to be a medical officer to drive an ambulance.");
			                    RemovePlayerFromVehicle(playerid);
			                }
						}
					}
//Taxi free
					if(IsPlayerInVehicle(playerid,251) || IsPlayerInVehicle(playerid,252) || IsPlayerInVehicle(playerid,253)){
						if(TaxiDriver[playerid] == 0 && NewTaxiDriver[playerid] == 0){
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Mickey has fired you, you cannot drive in his taxi anymore.");
		                    RemovePlayerFromVehicle(playerid);
						}
					}
//Highway vehicle free
		            if(IsPlayerInVehicle(playerid,99)){
						if(propertyOwner[P_FORTCARSONPD] != playerid){
							SendClientMessage(playerid, COLOR_SYSTEM_PW , "* You need to own the Highway Patrol Headquaters to drive this vehicle.");
		                    RemovePlayerFromVehicle(playerid);
		                    SetVehiclePos(99,-210.3248,997.5375,19.7873);
						}
					}
				}
//Spawn view 2
				if (AskedSpawnView2[playerid] == 1) {
				    SpawnViewCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~You will be teleported in ~b~%d",SpawnViewCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (SpawnViewCountdown[playerid] == 0) {
		      			SetPlayerInterior(playerid, 0);
		   	            SetPlayerPos(playerid,PF[playerid],QF[playerid],RF[playerid]);
						AskedSpawnView2[playerid]=0;
						SpawnViewer[playerid]=0;
					}
				}
//Spawn view 1
				if (AskedSpawnView1[playerid] == 1) {
				    SpawnViewCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~You will be teleported in ~b~%d",SpawnViewCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (SpawnViewCountdown[playerid] == 0) {
		   	            spawnlocje=spawnloc[playerid];
		   	            SetPlayerPos(playerid,OwnSpawnLocations[spawnlocje][0],OwnSpawnLocations[spawnlocje][1],OwnSpawnLocations[spawnlocje][2]);
						SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You will be teleported back to your previous location in 30 seconds.");
						AskedSpawnView1[playerid]=0;
						AskedSpawnView2[playerid]=1;
						SpawnViewCountdown[playerid]= 30;
					}
				}
//Ship car free
				if((X250[playerid] >= adShip[0] && X250[playerid] <= adShip[2] && Y250[playerid] >= adShip[1] && Y250[playerid] <= adShip[3] && Z250[playerid] <= 110) ||
				   (X250[playerid] >= adShip2[0] && X250[playerid] <= adShip2[2] && Y250[playerid] >= adShip2[1] && Y250[playerid] <= adShip2[3] && Z250[playerid] <= 110)) {
				    if(IsPlayerInAnyVehicle(playerid)){
		                RemovePlayerFromVehicle(playerid);
						SendClientMessage(playerid, COLOR_RED , "* No vehicles on or above the pirate ship or walkway!");
					}
				}
//Pirate money zone
				if(X250[playerid] >= adShip3[0] && X250[playerid] <= adShip3[2] && Y250[playerid] >= adShip3[1] && Y250[playerid] <= adShip3[3] && Z250[playerid] <= 110 && PirateMoneyMessageCounter[playerid] == 0){
					SendClientMessage(playerid, COLOR_SYSTEM_PM , "* You can hold the pirate ship area to gain money.");
					PirateMoneyMessageCounter[playerid] = 120;
				}
//Pirate money message
				if(PirateMoneyMessageCounter[playerid] > 0){
				    PirateMoneyMessageCounter[playerid]--;
				}
//Lowtuner 1
				if (askedlowtuner[playerid] == 1) {
				    LowTunerCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~You will be teleported in ~b~%d",LowTunerCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (LowTunerCountdown[playerid] == 0) {
		   	       		if(!IsPlayerInAnyVehicle(playerid)){
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to teleport with it it.");
							askedlowtuner[playerid]=0;
							readylowtuner[playerid]=0;
							LowTunerVehicleid[playerid]=0;
						} else {
							Teleporting[playerid]=1;
		  					LowTunerVehicleid[playerid] = GetPlayerVehicleID(playerid);
							SetVehicleZAngle(LowTunerVehicleid[playerid], 178.0000);
							SetVehiclePos(LowTunerVehicleid[playerid], 2645.1211,-1992.7159,13.1255);
							CarXPos[playerid] = 2645.1211;
							CarYPos[playerid] = -1992.7159;
							CarZPos[playerid] = 13.1255;
							askedlowtuner[playerid]=0;
							readylowtuner[playerid]=1;
							lowtunerback[playerid]=0;
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* When you are ready, use the command /backtolv to teleport to Las Venturas.");
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can however drive back yourself if you want that. In that case, use the command /cancelback .");
							Teleporting[playerid]=0;
						}
					}
				}
//Lowtuner 2
				if (readylowtuner[playerid] == 1 && lowtunerback[playerid] == 1) {
				    LowTunerCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~You will be teleported to LV in ~b~%d",LowTunerCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (LowTunerCountdown[playerid] == 0) {
		   	       		if(!IsPlayerInAnyVehicle(playerid)){
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to teleport with it it.");
							askedlowtuner[playerid]=0;
							readylowtuner[playerid]=0;
							LowTunerVehicleid[playerid]=0;
							lowtunerback[playerid]=0;
						} else {
							if(GetPlayerVehicleID(playerid) != LowTunerVehicleid[playerid]){
								SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Teleporting to Las Venturas is only allowed for the same vehicle you came to Los Santos.");
								askedlowtuner[playerid]=0;
								readylowtuner[playerid]=0;
								LowTunerVehicleid[playerid]=0;
								lowtunerback[playerid]=0;
							} else {
								Teleporting[playerid]=1;
								SetVehicleZAngle(LowTunerVehicleid[playerid], 180.0000);
								SetVehiclePos(LowTunerVehicleid[playerid], 1484.6180,2843.0625,10.6953);
								CarXPos[playerid] = 1484.6180;
								CarYPos[playerid] = 2843.0625;
								CarZPos[playerid] = 10.6953;
								askedlowtuner[playerid]=0;
								readylowtuner[playerid]=0;
								lowtunerback[playerid]=0;
								Teleporting[playerid]=0;
							}
						}
					}
				}
//Streettuner 1
				if (askedstreettuner[playerid] == 1) {
				    StreetTunerCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~You will be teleported in ~b~%d",StreetTunerCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (StreetTunerCountdown[playerid] == 0) {
		   	       		if(!IsPlayerInAnyVehicle(playerid)){
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to teleport with it it.");
							askedstreettuner[playerid]=0;
							readystreettuner[playerid]=0;
							StreetTunerVehicleid[playerid]=0;
						} else {
							Teleporting[playerid]=1;
		  					StreetTunerVehicleid[playerid] = GetPlayerVehicleID(playerid);
							SetVehicleZAngle(StreetTunerVehicleid[playerid], 178.0000);
							SetVehiclePos(StreetTunerVehicleid[playerid], -2668.2588,268.1872,4.2109);
							CarXPos[playerid] = -2668.2588;
							CarYPos[playerid] = 268.1872;
							CarZPos[playerid] = 4.2109;
							askedstreettuner[playerid]=0;
							readystreettuner[playerid]=1;
							streettunerback[playerid]=0;
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* When you are ready, use the command /backtolv to teleport to Las Venturas.");
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You can however drive back yourself if you want that. In that case, use the command /cancelback .");
							Teleporting[playerid]=0;
						}
					}
				}
//Streettuner 2
				if (readystreettuner[playerid] == 1 && streettunerback[playerid] == 1) {
				    StreetTunerCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~You will be teleported to LV in ~b~%d",StreetTunerCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (StreetTunerCountdown[playerid] == 0) {
		   	       		if(!IsPlayerInAnyVehicle(playerid)){
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to teleport with it it.");
							askedstreettuner[playerid]=0;
							readystreettuner[playerid]=0;
							StreetTunerVehicleid[playerid]=0;
							streettunerback[playerid]=0;
						} else {
							if(GetPlayerVehicleID(playerid) != StreetTunerVehicleid[playerid]){
								SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Teleporting to Las Venturas is only allowed for the same vehicle you came to Los Santos.");
								askedstreettuner[playerid]=0;
								readystreettuner[playerid]=0;
								StreetTunerVehicleid[playerid]=0;
								streettunerback[playerid]=0;
							} else {
								Teleporting[playerid]=1;
								SetVehicleZAngle(StreetTunerVehicleid[playerid], 180.0000);
								SetVehiclePos(StreetTunerVehicleid[playerid], 1465.0822,2845.0054,10.6953);
								askedstreettuner[playerid]=0;
								CarXPos[playerid] = 1465.0822;
								CarYPos[playerid] = 2845.0054;
								CarZPos[playerid] = 10.6953;
								readystreettuner[playerid]=0;
								streettunerback[playerid]=0;
								Teleporting[playerid]=0;
							}
						}
					}
				}
//payandspray 2
				if (readypayandspray[playerid] == 1) {
				    CarSprayCountdown[playerid] --;
					format(strings,sizeof(strings),"~p~Your car will be ready in ~r~%d",CarSprayCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (CarSprayCountdown[playerid] == 0) {
						SetVehiclePos(CarSprayVehicleid[playerid], CarSprayX[playerid], CarSprayY[playerid], CarSprayZ[playerid]);
						TogglePlayerControllable(playerid,1);
						askedpayandspray[playerid]=0;
						readypayandspray[playerid]=0;
						CarSprayVehicleid[playerid]=0;
						Teleporting[playerid]=0;
						CarSprayX[playerid] = 0.0000;
						CarSprayY[playerid] = 0.0000;
						CarSprayZ[playerid] = 0.0000;
					}
				}
//payandspray 1
				if (askedpayandspray[playerid] == 1) {
				    CarSprayCountdown[playerid] --;
					format(strings,sizeof(strings),"~g~Your car will be sprayed in ~b~%d",CarSprayCountdown[playerid]);
					GameTextForPlayer(playerid,strings,1000,4);
		   	        if (CarSprayCountdown[playerid] == 0) {
		   	       		if(!IsPlayerInAnyVehicle(playerid)){
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* You need to be in a vehicle to respray it.");
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* Because the towcar was already on its way, you'll have to pay 50 percent, you'll get back $125.000");
							format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because he was out of the car at payandspray.", playerid, 125000, GetPlayerMoney(playerid));
							StatGivePlayerMoney(playerid, 12500, strings);
							askedpayandspray[playerid]=0;
							readypayandspray[playerid]=0;
							CarSprayVehicleid[playerid]=0;
							CarSprayX[playerid] = 0.0000;
							CarSprayY[playerid] = 0.0000;
							CarSprayZ[playerid] = 0.0000;
						} else {
							Teleporting[playerid]=1;
							CarSprayX[playerid]=X250[playerid];
							CarSprayY[playerid]=Y250[playerid];
							CarSprayZ[playerid]=Z250[playerid];
		  					CarSprayVehicleid[playerid] = GetPlayerVehicleID(playerid);
							SetVehicleZAngle(CarSprayVehicleid[playerid], 180.0000);
							SetVehiclePos(CarSprayVehicleid[playerid], -1420.6775, 2585.8892, 55.6749);
							askedpayandspray[playerid]=0;
							readypayandspray[playerid]=1;
							CarSprayCountdown[playerid]=6;
							TogglePlayerControllable(playerid,0);
						}
					}
				}
				if (askedcardive[playerid] == 1) {
				    CarDiveCountdownSeconds[playerid] --;
				    if (CarDiveCountdownSeconds[playerid] != 0){
						format(strings,sizeof(strings),"~g~Your cardive will start in ~b~%d",CarDiveCountdownSeconds[playerid]);
						GameTextForPlayer(playerid,strings,1010,4);
					} else {
						TogglePlayerControllable(playerid,1);
			  			VehicleID = GetPlayerVehicleID(playerid);
						rnd1=random(5000) - 2500;
						X=float(rnd1);
						rnd1=random(5000) - 2500;
						Y=float(rnd1);
						rnd1=random(1000)+750;
						Z=float(rnd1);
	    		 		SetVehiclePos(VehicleID, X, Y, Z);
	  			   		format(strings, sizeof(strings), "* You were thrown %d meters in the sky, enjoy the trip.", rnd1);
						SendClientMessage(playerid, COLOR_CARDIVE , strings);
				        format(GameTextForPlayers1[playerid], 36, "~r~D~w~I~g~I~y~I~b~I~p~V~r~E~w~E~g~E~y~E~b~E~p~E");
				        format(GameTextForPlayers2[playerid], 36, "");
						GameTextForPlayersCounter[playerid]=5;
						askedcardive[playerid]=0;
					}
				}
//Jailbreaking
				if (JailBreaker[playerid] == 1) {
				    JailBreakTimer[playerid] --;
			        GetPlayerName(playerid, playername, sizeof(playername));
					format(strings,sizeof(strings),"You have ~r~%d ~w~seconds to enter the password with ~b~/springpass [1-8]",JailBreakTimer[playerid]);
					GameTextForPlayer(playerid,strings,1000,5);
					if (JailBreakPassword[playerid] > 0) {
					    JailBreakTimer[playerid] = 0;
						correctpassword=random(8)+1;
						if(JailBreakPassword[playerid] == correctpassword){
						    correct=1;
						}
						if (correct==0){
							SendClientMessage(playerid, COLOR_RULES , "* Your jail break attempt failed: the password you choose was not correct.");
							format(strings, sizeof(strings), "* The correct password was number %d.", correctpassword);
							SendClientMessage(playerid, COLOR_RULES, strings);
							SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
							format(strings, sizeof(strings), "* %s has been caught hacking into the Dillmore PD computer, and has been send to jail.", playername);
							SendClientMessageToAll(COLOR_RULES, strings);
							jailed[playerid] = 1;
							jailtime[playerid] = 5;
							dini_IntSet(udb_encode(playername), "jailed", 1);
							dini_IntSet(udb_encode(playername), "jailtime", 5);
							SetPlayerInterior(playerid,10);
							SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
							if(jailcelcounter < 3) {
							    jailcelcounter++;
							} else {
							    jailcelcounter=0;
							}
							JailBreakTime[playerid]=0;
							JailBreaker[playerid]=0;
							JailBreakPassword[playerid]=0;
							JailBreakAttempt[playerid]=7;
							JailBreakWarning[playerid]=0;
					        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to spring the jail.", GetPlayerMoney(playerid), playerid);
					        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
					        DisablePlayerCheckpoint(playerid);
							ResetPlayerWeapons(playerid);
						} else {
							format(strings, sizeof(strings), "* %s (id: %d) hacked the Dillmore PD computer.", playername, playerid);
							printf(strings);
							SendClientMessage(playerid, COLOR_SYSTEM_GM , "* The hack was succesfull, starting processing.......");
					    	for(new i=0;i<MAX_PLAYERS;i++){
								if(IsPlayerConnected(i)){
								    if(jailtime[playerid] > 0){
										jailtime[playerid] = 0;
										format(strings, sizeof(strings), "* Player %s has hacked into the Dillmore PD computer, and set your jailtime to 0", playername);
										SendClientMessage(i, COLOR_SYSTEM_PM , strings);
										SendClientMessage(i, COLOR_SYSTEM_PM , "* You will be released soon!");
										free++;
									}
								}
							}
							if(free > 0){
								format(strings, sizeof(strings), "* You have modified %d police records, the players will be released soon.", free);
								SendClientMessage(playerid, COLOR_SYSTEM_PM , strings);
							} else {
								SendClientMessage(playerid, COLOR_SYSTEM_PM , "* No records found matched selection, no records updated. Sorry.");
							}
							JailBreakTime[playerid]=0;
							JailBreaker[playerid]=0;
							JailBreakPassword[playerid]=0;
							JailBreakAttempt[playerid]=7;
							JailBreakWarning[playerid]=0;
						}
					} else {
		   		        if ((JailBreakTimer[playerid] == 0) && (JailBreakPassword[playerid] == 0)) {
							SendClientMessage(playerid, COLOR_RULES , "* Your hacking attempt failed: you failed to enter a password.");
							SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
							format(strings, sizeof(strings), "* %s has been caught hacking into the Dillmore PD computer, and has been send to jail.", playername);
							SendClientMessageToAll(COLOR_RULES, strings);
							jailed[playerid] = 1;
							jailtime[playerid] = 5;
							dini_IntSet(udb_encode(playername), "jailed", 1);
							dini_IntSet(udb_encode(playername), "jailtime", 5);
							SetPlayerInterior(playerid,10);
							SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
							if(jailcelcounter < 3) {
							    jailcelcounter++;
							} else {
							    jailcelcounter=0;
							}
							JailBreakTime[playerid]=0;
							JailBreaker[playerid]=0;
							JailBreakPassword[playerid]=0;
							JailBreakAttempt[playerid]=7;
							JailBreakWarning[playerid]=0;
					        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to spring the jail.", GetPlayerMoney(playerid), playerid);
					        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
					        DisablePlayerCheckpoint(playerid);
							ResetPlayerWeapons(playerid);
		    	        }
		  		        if ((JailBreakTimer[playerid] > 59) && (JailBreakPassword[playerid] == 0)) {
		    	            format(strings, sizeof(strings), "~w~Connecting to server......~n~User: ~p~polowski~n~~r~Enter password:~w~_");
							GameTextForPlayer(playerid,strings,5000,3);
						}
		           	}
				}
//Bank hacking
				if (BankHacker[playerid] == 1) {
				    BankHackTimer[playerid] --;
			        GetPlayerName(playerid, playername, sizeof(playername));
					format(strings,sizeof(strings),"You have ~r~%d ~w~seconds to enter the password with ~b~/hackpass [1-4]",BankHackTimer[playerid]);
					GameTextForPlayer(playerid,strings,1000,5);
					if(IsPlayerConnected(BankHackVictim[playerid])){
						if (BankHackPassword[playerid] > 0) {
						    correctpassword=random(4)+1;
						    correcttime=random(2);
						    if(correcttime == 1){
						        if(BankHackPassword[playerid] == correctpassword) {
						            correct = 1;
						        }
						    }
						    WaitingTime[playerid] = 0;
							if (correcttime==0){
								SendClientMessage(playerid, COLOR_RULES , "* Your hacking attempt failed, it has been monitored by the police.");
								SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
								SendClientMessage(playerid, COLOR_RULES , "* Next time: try a different hour, the police can not monitor 24 hours a day.");
								format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
								SendClientMessageToAll(COLOR_RULES, strings);
								BankHacker[playerid]=0;
								jailed[playerid] = 1;
								jailtime[playerid] = 5;
								dini_IntSet(udb_encode(playername), "jailed", 1);
								dini_IntSet(udb_encode(playername), "jailtime", 5);
								SetPlayerInterior(playerid,10);
								SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
								if(jailcelcounter < 3) {
								    jailcelcounter++;
								} else {
								    jailcelcounter=0;
								}
								BankHackTime[playerid]=0;
								BankHacker[playerid]=0;
								BankHackVictim[playerid]=0;
								BankHackPassword[playerid]=0;
								BankHackAttempt[playerid]=14;
								BankHackWarning[playerid]=0;
						        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
						        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
						        DisablePlayerCheckpoint(playerid);
								ResetPlayerWeapons(playerid);
							} else {
								if (correct==0){
									SendClientMessage(playerid, COLOR_RULES , "* Your hacking attempt failed: the password you choose was not correct.");
									format(strings, sizeof(strings), "* The correct password was number %d.", correctpassword);
									SendClientMessage(playerid, COLOR_RULES, strings);
									SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
									format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
									SendClientMessageToAll(COLOR_RULES, strings);
									BankHacker[playerid]=0;
									jailed[playerid] = 1;
									jailtime[playerid] = 5;
									dini_IntSet(udb_encode(playername), "jailed", 1);
									dini_IntSet(udb_encode(playername), "jailtime", 5);
									SetPlayerInterior(playerid,10);
									SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
									if(jailcelcounter < 3) {
									    jailcelcounter++;
									} else {
									    jailcelcounter=0;
									}
									BankHackTime[playerid]=0;
									BankHacker[playerid]=0;
									BankHackVictim[playerid]=0;
									BankHackPassword[playerid]=0;
									BankHackAttempt[playerid]=14;
									BankHackWarning[playerid]=0;
							        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
							        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
							        DisablePlayerCheckpoint(playerid);
									ResetPlayerWeapons(playerid);
								} else {
								    //Correct time & correct password
									victimid=BankHackVictim[playerid];
							    	GetPlayerName(victimid, victimname, sizeof(victimname));
									BankAmount[playerid]=bank[victimid];
									if(BankAmount[playerid] > 0){
									    if(BankAmount[playerid] > 1000000){
									        BankAmount[playerid]=1000000;
										}
										format(strings, sizeof(strings), "* %s (id: %d) hacked the bank of %s and transferred $%d.", playername, playerid, victimname, BankAmount[playerid]);
										printf(strings);
										bank[playerid]+=BankAmount[playerid];
										bank[victimid]-=BankAmount[playerid];
			    				    	GetPlayerName(playerid, playername, sizeof(playername));
										format(strings, sizeof(strings), "* The hack was succesfull, you transfered $%d to your bankaccount.", BankAmount[playerid]);
										SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
										format(strings, sizeof(strings), "* Player %s has hacked into your bank, and transferred $%d to his bankaccount!", playername, BankAmount[playerid]);
										SendClientMessage(victimid, COLOR_RED , strings);
										BankHackTime[playerid]=0;
										BankHacker[playerid]=0;
										BankHackVictim[playerid]=0;
										BankHackPassword[playerid]=0;
										BankHackAttempt[playerid]=14;
										BankHackWarning[playerid]=0;
										BankAmount[playerid]=0;
									} else {
										format(strings, sizeof(strings), "* %s (id: %d) hacked the bank of %s but found an empty bank account.", playername, playerid, victimname);
										printf(strings);
										format(strings, sizeof(strings), "* The hack was succesfull, but player %s does not have anything on his bankaccount.", victimname);
										SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
										BankHackTime[playerid]=0;
										BankHacker[playerid]=0;
										BankHackVictim[playerid]=0;
										BankHackPassword[playerid]=0;
										BankHackAttempt[playerid]=14;
										BankHackWarning[playerid]=0;
										BankAmount[playerid]=0;
									}
								}
							}
						} else {
		    		        if ((BankHackTimer[playerid] == 0) && (BankHackPassword[playerid] == 0)) {
								SendClientMessage(playerid, COLOR_RULES , "* Your hacking attempt failed: you failed to enter a password within the given time.");
								SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
								format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
								SendClientMessageToAll(COLOR_RULES, strings);
								jailed[playerid] = 1;
								jailtime[playerid] = 5;
								dini_IntSet(udb_encode(playername), "jailed", 1);
								dini_IntSet(udb_encode(playername), "jailtime", 5);
								SetPlayerInterior(playerid,10);
								SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
								if(jailcelcounter < 3) {
								    jailcelcounter++;
								} else {
								    jailcelcounter=0;
								}
								BankHackTime[playerid]=0;
								BankHacker[playerid]=0;
								BankHackVictim[playerid]=0;
								BankHackPassword[playerid]=0;
								BankHackAttempt[playerid]=14;
								BankHackWarning[playerid]=0;
						        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
						        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
				    		    DisablePlayerCheckpoint(playerid);
								ResetPlayerWeapons(playerid);
			    	        }
						}
	            	} else {
						SendClientMessage(playerid, COLOR_RULES , "* Your hacking attempt failed: the player closed his bankaccount!");
						SendClientMessage(playerid, COLOR_RULES , "* The police has found you, and sentenced you to 5 minutes jailtime!");
						format(strings, sizeof(strings), "* %s has been caught hacking into the bank database, and has been send to jail.", playername);
						SendClientMessageToAll(COLOR_RULES, strings);
						BankHackTime[playerid]=0;
						BankHacker[playerid]=0;
						BankHackVictim[playerid]=0;
						BankHackPassword[playerid]=0;
						BankHackAttempt[playerid]=14;
						BankHackWarning[playerid]=0;
						jailed[playerid] = 1;
						jailtime[playerid] = 5;
						dini_IntSet(udb_encode(playername), "jailed", 1);
						dini_IntSet(udb_encode(playername), "jailtime", 5);
						SetPlayerInterior(playerid,10);
						SetPlayerPos(playerid,jailcelloc[jailcelcounter][0],jailcelloc[jailcelcounter][1],jailcelloc[jailcelcounter][2]);
						if(jailcelcounter < 3) {
						    jailcelcounter++;
						} else {
						    jailcelcounter=0;
						}
				        format(strings, sizeof(strings), "* Money decreased $%d, because player-id %d tried to hack the bank.", GetPlayerMoney(playerid), playerid);
				        StatGivePlayerMoney(playerid, -GetPlayerMoney(playerid), strings);
				        DisablePlayerCheckpoint(playerid);
						ResetPlayerWeapons(playerid);
	            	}
				}
//PizzaMissionCheck
				if(Pizza[playerid] == 1){
				    if(PizzaTotalTime[playerid] == 0){
						delivered=PizzaDelivered[playerid];
						format(strings, sizeof(strings),"* You ran out of time. You managed to deliver %d pizza's", delivered);
						SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
						TotalPizzas(playerid, delivered);
				 		DisablePlayerCheckpoint(playerid);
	                    PizzaNextCP[playerid] = 0;
						PizzaVehicle[playerid] = 999;
						PizzaTotalTime[playerid]=0;
						Pizza[playerid] = 0;
					}
				}
//PizzaWait
		        if(Pizza[playerid] == 1 && PizzaWaitTime[playerid] > 0){
		            PizzaWaitTime[playerid]--;
		            if(PizzaWaitTime[playerid] == 0)TogglePlayerControllable(playerid,1);
				}
//NewTaxiDriverWait
		        if(NewTaxiDriver[playerid] > 0 && ApplyTaxi[playerid] == 1){
		            NewTaxiDriver[playerid]--;
		            if(NewTaxiDriver[playerid] > 0) {
						PlayerPlaySound(playerid,1056,X250[playerid],Y250[playerid],Z250[playerid]);
						if(NewTaxiDriver[playerid] > 9){
							format(strings, sizeof(strings), "~w~0:%d", NewTaxiDriver[playerid]);
						} else {
							format(strings, sizeof(strings), "~w~0:0%d", NewTaxiDriver[playerid]);
						}
						GameTextForPlayer(playerid, strings, 3000, 4);
					}
		            if(NewTaxiDriver[playerid] == 18) TogglePlayerControllable(playerid,0);
		            if(NewTaxiDriver[playerid] == 0){
						TogglePlayerControllable(playerid,1);
						RemovePlayerFromVehicle(playerid);
						ApplyTaxi[playerid] = 0;
					}
				}
//TaxiWait
		        if(TaxiDriver[playerid] == 1 && TaxiWaitTime[playerid] > 0){
		            TaxiWaitTime[playerid]--;
		            if(TaxiWaitTime[playerid] == 0)TogglePlayerControllable(playerid,1);
				}
//TaxiMissionCheck
				if(TaxiDriver[playerid] == 1){
				    if(TaxiTotalTime[playerid] == 0){
						delivered=TaxiDelivered[playerid];
						format(strings, sizeof(strings),"* You ran out of time. You managed to complete %d taxiruns.", delivered);
						SendClientMessage(playerid, COLOR_SYSTEM_PM, strings);
						TotalTaxis(playerid, delivered);
		                TaxiNextCP[playerid] = 0;
						TaxiVehicle[playerid] = 999;
						TaxiTotalTime[playerid]=0;
						TaxiDriver[playerid] = 0;
					}
				}
//Update zones
				player_zone_before = player_zone[playerid];
				player_zone[playerid] = -1;
				for(new k=0; k<sizeof(zones);k++) {
					if(IsPlayerInZone(playerid,k) && player_zone[playerid] == -1) {
						player_zone[playerid] = k;
					}
				}
				if(player_zone[playerid] == -1){
					player_zone[playerid] = player_zone_before;
				}
			}
////////////Not logged or spawned/////////////
			if(spawned[playerid] == 1){
			    GetPlayerName(playerid,playername,sizeof(playername));
                if (dini_Exists(udb_encode(playername))) {
					if(logged[playerid] == 0) {
					    LoginTimeout[playerid]--;
					    if( LoginTimeout[playerid] == 50 ||
                            LoginTimeout[playerid] == 40 ||
                            LoginTimeout[playerid] == 30 ||
                            LoginTimeout[playerid] == 20 ||
                            LoginTimeout[playerid] == 10 ){
							//Bekende gebruiker, niet ingelogd.
							SendClientMessage(playerid, COLOR_GREENYELLOW, "* You are not logged in. Type /login <password> to login.");
							SendClientMessage(playerid, COLOR_GREENYELLOW, "* Note that you will receive your spawn weapons at your next spawn (next time you have died).");
							format(strings,sizeof(strings),"~w~You have %d seconds to login. type /login", LoginTimeout[playerid]);
							GameTextForPlayer(playerid, strings, 120000, 3);
						}
						if(LoginTimeout[playerid] == 1) {
							SendClientMessage(playerid, COLOR_GREENYELLOW, "* You failed to login. The connection to the server will be disconnected.");
						}
						if(LoginTimeout[playerid] == 0) {
						    //Niet ingelogd binnen de minuut, kick
							format(strings,sizeof(strings),"* Player %s failed to login within the 60 seconds period.",playername);
							SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
							Kick(playerid);
						}
					}
				} else {
				    LoginTimeout[playerid]--;
				    if( LoginTimeout[playerid] == 50 ||
                        LoginTimeout[playerid] == 40 ||
                        LoginTimeout[playerid] == 30 ||
                        LoginTimeout[playerid] == 20 ||
                        LoginTimeout[playerid] == 10 ){
						//Niet bekende gebruiker, niet ingelogd.
						SendClientMessage(playerid, COLOR_GREENYELLOW, "* You need to create an account on this server. Type /register <password>  to do so.");
						format(strings,sizeof(strings),"~w~You have %d seconds to register. type /register", LoginTimeout[playerid]);
						GameTextForPlayer(playerid, strings, 120000, 3);
					}
					if(LoginTimeout[playerid] == 1) {
					    //Niet geregistreerd binnen de minuut, kick
						SendClientMessage(playerid, COLOR_GREENYELLOW, "* You failed to register. The connection to the server will be disconnected.");
					}
					if(LoginTimeout[playerid] == 0) {
						format(strings,sizeof(strings),"* Player %s failed to register within the 60 seconds period.",playername);
						SendClientMessageToAll(COLOR_SYSTEM_GW, strings);
						Kick(playerid);
					}
				}
			}
		}
	}
//Highway patrol
	if(propertyOwner[P_FORTCARSONPD] != 999){
	    owner=propertyOwner[P_FORTCARSONPD];
		if(IsPlayerConnected(owner)){
	        if(IsPlayerInAnyVehicle(owner)){
				VehicleID = GetPlayerVehicleID(owner);
				if(IsPlayerDriver(owner) && VehicleID == 99){
					for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
				        if (IsPlayerConnected(playerid)){
							if(HighwayMission == 1){
				    	        if(IsPlayerInAnyVehicle(playerid) && GetPlayerState(playerid) == PLAYER_STATE_DRIVER && dragracer[playerid]==0 && DMplayer[playerid] == 0){
									if(playerid != propertyOwner[P_FORTCARSONPD] && Fined[playerid] == 0){
									    if(IsPlayerInSphere(playerid,X250[owner],Y250[owner],Z250[owner],100)){
									        if(PlayersSpeed[playerid] > 140){
									            diffspeed=floatround((PlayersSpeed[playerid] - 140)/10);
									            if(diffspeed > 19) diffspeed = 19;
												fine[playerid]=Fines[diffspeed];
												PlayerPlaySound(playerid,1132,X250[playerid],Y250[playerid],Z250[playerid]);
												PlayerPlaySound(owner,1132,X250[owner],Y250[owner],Z250[owner]);
												SendClientMessage(playerid, COLOR_CARDIVE, "* You were caught speeding!");
												format(strings, sizeof(strings),"* Your recorded speed is %d kph, you received a ticket of $ %d", PlayersSpeed[playerid], fine[playerid]);
												SendClientMessage(playerid, COLOR_CARDIVE, strings);
												GetPlayerName(playerid, playername, sizeof(playername));
												SendClientMessage(propertyOwner[P_FORTCARSONPD], COLOR_CARDIVE, "* You caught someone speeding!");
												format(strings, sizeof(strings),"* You fined %s for a recorded speed is %d kph. The fine is $ %d", playername, PlayersSpeed[playerid], fine[playerid]);
												SendClientMessage(propertyOwner[P_FORTCARSONPD], COLOR_CARDIVE, strings);
												format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because the player was fined.", playerid, fine[playerid], GetPlayerMoney(playerid));
												StatGivePlayerMoney(playerid, -fine[playerid], strings);
												format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player issued a fine.", propertyOwner[P_FORTCARSONPD], fine[playerid], GetPlayerMoney(propertyOwner[P_FORTCARSONPD]));
												StatGivePlayerMoney(propertyOwner[P_FORTCARSONPD], fine[playerid], strings);
												Fined[playerid]=2;
											}
										}
									}
									if(playerid == propertyOwner[P_FORTCARSONPD]){
									    if(HighwayOfficerColor == 0){
									        HighwayOfficerColor ++;
									        SetPlayerColor(playerid,COLOR_BLACK_PD);
									    } else {
									        HighwayOfficerColor --;
									        SetPlayerColor(playerid,COLOR_WHITE_PD);
										}
									}
								}
							}
						}
					}
				} else {
    				if(IsPlayerDriver(owner)) {
						if(VehicleID != 99 && HighwayMission == 1){
					        format(GameTextForPlayers1[owner], 36, "~w~Highway patrol mission is over");
					        format(GameTextForPlayers2[owner], 36, "");
							GameTextForPlayersCounter[owner]=5;
							GetPlayerName(owner,playername,sizeof(playername));
							format(strings, sizeof(strings),"* Player %s has ended the highway patrol mission, you can roam freely over the highways without getting a ticket.",playername);
							SendClientMessageToAll(COLOR_ADMIN_TOALL,strings);
							HighwayOnMission[owner]=0;
							OutOfRanger[owner]=0;
							HighwayMission = 0;
						}
					}
				}
			}
		}
	}
//property update
	for(new prop=0;prop<MAX_PROPERTIES;prop++){
		j=prop+1;
		if(propertyOwner[j]!= 999){
		    propowner=propertyOwner[j];
		    if(!IsPlayerConnected(propowner)){
		        propertyOwner[j]=999;
		        ownedtime[j]=0;
			}
		}
	}
//auto cancel races
	if(AutoCancelSprint3 > 0){
	    AutoCancelSprint3--;
	    if(AutoCancelSprint3 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher18[i] != 0){
					sprintrace3[i] = 0;
					sprintrace3players[i] = 0;
					deathmatcher18[i]=0;
				}
			}
			playerssprintrace3=0;
			sprintrace3started=0;
			sprintrace3inprogress=0;
			sprintrace3racer[0]=0;
			sprintrace3racer[1]=0;
			CancelSprint3 = 0;
			SprintRace3Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The sprintrace 3 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelSprint4 > 0){
	    AutoCancelSprint4--;
	    if(AutoCancelSprint4 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher19[i] != 0){
					sprintrace4[i] = 0;
					sprintrace4players[i] = 0;
					deathmatcher19[i]=0;
				}
			}
			playerssprintrace4=0;
			sprintrace4started=0;
			sprintrace4inprogress=0;
			sprintrace4racer[0]=0;
			sprintrace4racer[1]=0;
			CancelSprint4 = 0;
			SprintRace4Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The sprintrace 4 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelSprint5 > 0){
	    AutoCancelSprint5--;
	    if(AutoCancelSprint5 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher20[i] != 0){
					sprintrace5[i] = 0;
					sprintrace5players[i] = 0;
					deathmatcher20[i]=0;
				}
			}
			playerssprintrace5=0;
			sprintrace5started=0;
			sprintrace5inprogress=0;
			sprintrace5racer[0]=0;
			sprintrace5racer[1]=0;
			CancelSprint5 = 0;
			SprintRace5Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The sprintrace 5 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelSprint6 > 0){
	    AutoCancelSprint6--;
	    if(AutoCancelSprint6 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher21[i] != 0){
					sprintrace6[i] = 0;
					sprintrace6players[i] = 0;
					deathmatcher21[i]=0;
				}
			}
			playerssprintrace6=0;
			sprintrace6started=0;
			sprintrace6inprogress=0;
			sprintrace6racer[0]=0;
			sprintrace6racer[1]=0;
			CancelSprint6 = 0;
			SprintRace6Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The sprintrace 6 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelSprint7 > 0){
	    AutoCancelSprint7--;
	    if(AutoCancelSprint7 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher22[i] != 0){
					sprintrace7[i] = 0;
					sprintrace7players[i] = 0;
					deathmatcher22[i]=0;
				}
			}
			playerssprintrace7=0;
			sprintrace7started=0;
			sprintrace7inprogress=0;
			sprintrace7racer[0]=0;
			sprintrace7racer[1]=0;
			CancelSprint7 = 0;
			SprintRace7Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The sprintrace 7 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelMotor1 > 0){
	    AutoCancelMotor1--;
	    if(AutoCancelMotor1 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher24[i] != 0){
					motorrace1[i] = 0;
					motorrace1players[i] = 0;
					deathmatcher24[i]=0;
				}
			}
			playersmotorrace1=0;
			motorrace1started=0;
			motorrace1inprogress=0;
			motorrace1racer[0]=0;
			motorrace1racer[1]=0;
			CancelMotor1 = 0;
			MotorRace1Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The motorrace 1 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelMotor2 > 0){
	    AutoCancelMotor2--;
	    if(AutoCancelMotor2 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher25[i] != 0){
					motorrace2[i] = 0;
					motorrace2players[i] = 0;
					deathmatcher25[i]=0;
				}
			}
			playersmotorrace2=0;
			motorrace2started=0;
			motorrace2inprogress=0;
			motorrace2racer[0]=0;
			motorrace2racer[1]=0;
			CancelMotor2 = 0;
			MotorRace2Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The motorrace 2 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelMotor3 > 0){
	    AutoCancelMotor3--;
	    if(AutoCancelMotor3 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher26[i] != 0){
					motorrace3[i] = 0;
					motorrace3players[i] = 0;
					deathmatcher26[i]=0;
				}
			}
			playersmotorrace3=0;
			motorrace3started=0;
			motorrace3inprogress=0;
			motorrace3racer[0]=0;
			motorrace3racer[1]=0;
			CancelMotor3 = 0;
			MotorRace3Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The motorrace 3 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelMotor4 > 0){
	    AutoCancelMotor4--;
	    if(AutoCancelMotor4 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher27[i] != 0){
					motorrace4[i] = 0;
					motorrace4players[i] = 0;
					deathmatcher27[i]=0;
				}
			}
			playersmotorrace4=0;
			motorrace4started=0;
			motorrace4inprogress=0;
			motorrace4racer[0]=0;
			motorrace4racer[1]=0;
			CancelMotor4 = 0;
			MotorRace4Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The motorrace 4 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	if(AutoCancelMotor5 > 0){
	    AutoCancelMotor5--;
	    if(AutoCancelMotor5 == 0){
			for (new i=0; i<MAX_PLAYERS; i++){
				if(deathmatcher28[i] != 0){
					motorrace5[i] = 0;
					motorrace5players[i] = 0;
					deathmatcher28[i]=0;
				}
			}
			playersmotorrace5=0;
			motorrace5started=0;
			motorrace5inprogress=0;
			motorrace5racer[0]=0;
			motorrace5racer[1]=0;
			CancelMotor5 = 0;
			MotorRace5Finisher = 0;
			SendClientMessageToAll(COLOR_SYSTEM_PM,"* The motorrace 5 has been cancelled due to inactivity of the drivers, and is open for new racers.");
		}
	}
	for (new i=0;i<MAX_PLAYERS;i++){
	    if(sprintracer[i] == 1){
	        if(	deathmatcher18[i] == 0 &&
	            deathmatcher19[i] == 0 &&
	            deathmatcher20[i] == 0 &&
	            deathmatcher21[i] == 0 &&
	            deathmatcher22[i] == 0) {
				sprintracer[i] = 0;
				DMplayer[i] = 0;
			}
	    }
	    if(motorracer[i] == 1){
	        if(	deathmatcher24[i] == 0 &&
	            deathmatcher25[i] == 0 &&
	            deathmatcher26[i] == 0 &&
	            deathmatcher27[i] == 0&&
	            deathmatcher28[i] == 0) {
				motorracer[i] = 0;
				DMplayer[i] = 0;
			}
	    }
	}
	return 1;
}

public TaxiWaiting(){
	new taxiowner[32];
	new taxiownerid, taxinumber, reward, creditcardpayment, CashForBank, taxicheck, MoneyCheck;
	new CurrentTaxiRate[MAX_PLAYERS];
	for (new playerid=0;playerid<MAX_PLAYERS;playerid++){
        if (IsPlayerConnected(playerid)){
			if (RequestedTaxi[playerid] == 1) {
			    WaitingTime[playerid] --;

				format(strings,sizeof(strings),"The taxi will arrive in %d",WaitingTime[playerid]);
				GameTextForPlayer(playerid,strings,1000,5);
    	        if (WaitingTime[playerid] == 1)
        	    {
					PlayerPlaySound(playerid,1147,X250[playerid],Y250[playerid],Z250[playerid]);
				}
    	        if (WaitingTime[playerid] == 0)
        	    {
					TotalMoney[playerid]=GetPlayerMoney(playerid)+bank[playerid];
					if (TaxiUpcomingDrive[playerid] == 1){
					    if (TotalMoney[playerid] > 500){
   							format(strings, sizeof(strings), "* You do not qualify for our free service anymore, you have more than $500.");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
   							format(strings, sizeof(strings), "* You can request a taxi again, but you will have to pay $5000 for a ride when having more than $500.");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
							RequestedTaxi[playerid] = 0;
							TaxiUsedNew[playerid]--;
							TaxiUpcomingDrive[playerid]=0;
							TaxiLocname[playerid]="";
							TaxiCreditcard[playerid]=0;
							break;
						}
					}
					if (TaxiUpcomingDrive[playerid] == 2){
					    if (TotalMoney[playerid] > 50000){
   							format(strings, sizeof(strings), "* You do not qualify for our reduced service anymore, you have more than $50000.");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
   							format(strings, sizeof(strings), "* You can request a taxi again, but you will have to pay $10000 for a ride when having more than $50000.");
							SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
							RequestedTaxi[playerid] = 0;
							TaxiUsedPoor[playerid]--;
							TaxiUpcomingDrive[playerid]=0;
							TaxiLocname[playerid]="";
							TaxiCreditcard[playerid]=0;
							break;
						} else {
							if(TaxiCreditcard[playerid]==1){
								CurrentTaxiRate[playerid] = 5000 + floatround(5000*(float(CREDITCOST)/100));
								OldTaxiRate[playerid] = 5000;
								MoneyCheck = bank[playerid];
							} else {
							    CurrentTaxiRate[playerid] = 5000;
							    MoneyCheck = GetPlayerMoney(playerid);
							}
							if (MoneyCheck < CurrentTaxiRate[playerid]){
   								format(strings, sizeof(strings), "* You do not have enough cash money for the trip, you need $%d.",CurrentTaxiRate[playerid]);
								SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
								RequestedTaxi[playerid] = 0;
								TaxiUsedPoor[playerid]--;
								TaxiUpcomingDrive[playerid]=0;
								TaxiLocname[playerid]="";
								TaxiCreditcard[playerid]=0;
								break;
							}
						}
					}
					if (TaxiUpcomingDrive[playerid] == 3){
					    taxinumber=TaxiUsedRich[playerid] - 1;
						if (propertyOwner[P_TAXICOMP] == playerid){
							if(TaxiCreditcard[playerid]==1){
								CurrentTaxiRate[playerid] = TaxiPriceOwner[taxinumber] + floatround(TaxiPriceOwner[taxinumber]*(float(CREDITCOST)/100));
								OldTaxiRate[playerid] = TaxiPriceOwner[taxinumber];
								MoneyCheck = bank[playerid];
							} else {
							    CurrentTaxiRate[playerid] = TaxiPriceOwner[taxinumber];
							    MoneyCheck = GetPlayerMoney(playerid);
							}
							if (MoneyCheck < CurrentTaxiRate[playerid]){
	  							format(strings, sizeof(strings), "* You do not have enough cash money for the trip, you need $%d.",CurrentTaxiRate[playerid]);
								SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
								RequestedTaxi[playerid] = 0;
								if (TaxiUsedRich[playerid] < 5){ TaxiUsedRich[playerid]--;}
								TaxiUpcomingDrive[playerid]=0;
								TaxiLocname[playerid]="";
								TaxiCreditcard[playerid]=0;
								break;
							}
						} else {
							if(TaxiCreditcard[playerid]==1){
								CurrentTaxiRate[playerid] = TaxiPricePlayer[taxinumber] + floatround(TaxiPricePlayer[taxinumber]*(float(CREDITCOST)/100));
								OldTaxiRate[playerid]=TaxiPricePlayer[taxinumber];
								MoneyCheck = bank[playerid];
							} else {
							    CurrentTaxiRate[playerid] = TaxiPriceOwner[taxinumber];
							    MoneyCheck = GetPlayerMoney(playerid);
							}
							if (MoneyCheck < CurrentTaxiRate[playerid]){
 								format(strings, sizeof(strings), "* You do not have enough cash money for the trip, you need $%d.",CurrentTaxiRate[playerid]);
								SendClientMessage(playerid, COLOR_SYSTEM_PW , strings);
								RequestedTaxi[playerid] = 0;
								if (TaxiUsedRich[playerid] < 5){ TaxiUsedRich[playerid]--;}
								TaxiUpcomingDrive[playerid]=0;
								TaxiLocname[playerid]="";
								TaxiCreditcard[playerid]=0;
								break;
							}
						}
					}
					if (IsPlayerConnected(playerid) && Z250[playerid] > 900) {
			 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, we cannot pick you up indoors. Please stand outside to order the taxi.");
			 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Your current request has been cancelled.");
						RequestedTaxi[playerid] = 0;
						TaxiCreditcard[playerid]=0;
						break;
					} else {
	   	        	    GetPlayerName(playerid, playername, sizeof(playername));
						RequestedTaxi[playerid] = 0;
						format(strings, sizeof(strings), "--- Player %s (id: %d) took the taxi to the %s", playername,playerid,TaxiLocname[playerid]);
						printf(strings);
						SetPlayerInterior(playerid, InteriorID[playerid]);
						SetPlayerPos(playerid, PF[playerid], QF[playerid], RF[playerid] + 2);
						SetCameraBehindPlayer(playerid);
						PlayerPlaySound(playerid,1140,PF[playerid], QF[playerid], RF[playerid]);
						if (propertyOwner[P_TAXICOMP] < 999) {
					        taxiownerid=propertyOwner[P_TAXICOMP];
				 	   		GetPlayerName(taxiownerid, taxiowner, sizeof(taxiowner));
						} else {
						    taxiownerid=999;
						}
						if (TaxiUpcomingDrive[playerid] == 1){
							format(strings, sizeof(strings), "* Player %s took a free taxiride to the %s", playername, TaxiLocname[playerid]);
							SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
							if (TaxiUsedNew[playerid] == 3){
								format(strings, sizeof(strings), "* You used your 3 free taxirides, from now on you'll have to pay for the taxi.");
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
								format(strings, sizeof(strings), "* Check /taxirates for the prices you'll have to pay.");
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							} else {
								format(strings, sizeof(strings), "* You have %d more free taxi rides.",3-TaxiUsedNew[playerid]);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							}
						}
						if (TaxiUpcomingDrive[playerid] == 2){
							format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because the player took a taxi.", playerid, CurrentTaxiRate[playerid], GetPlayerMoney(playerid));
			    	        if(TaxiCreditcard[playerid]==1){
								bank[playerid] -= CurrentTaxiRate[playerid];
							} else {
								StatGivePlayerMoney(playerid, -CurrentTaxiRate[playerid], strings);
							}
							format(strings, sizeof(strings), "* Player %s took a reduced price taxiride to the %s", playername, TaxiLocname[playerid]);
							SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
							if (TaxiUsedPoor[playerid]==3){
								format(strings, sizeof(strings), "* You used your 3 reduced taxirides, from now on you'll have to pay  the full price for the taxi.");
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
								format(strings, sizeof(strings), "* Check /taxirates for the prices you'll have to pay.");
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							} else {
								format(strings, sizeof(strings), "* You have %d more reduced taxi rides.",3-TaxiUsedPoor[playerid]);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							}
							if (taxiownerid != 999){
								format(strings, sizeof(strings), "* You payed $%d to the taxidiver for her services.", 5000);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
								if (jailed[taxiownerid] == 0) {
									format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because player-id %d took a taxi.", taxiowner, 2500, GetPlayerMoney(playerid), playerid);
									StatGivePlayerMoney(taxiownerid, 2500, strings);
									format(strings, sizeof(strings), "* You received $%d from %s for your services.", 2500, playername);
									SendClientMessage(taxiownerid, COLOR_SYSTEM_GM , strings);
								} else {
									SendClientMessage(taxiownerid, COLOR_SYSTEM_GM , "* You received nothing, since you are doing time in jail.");
								}
						    } else {
								format(strings, sizeof(strings), "* You payed $%d to the taxidiver for her services.", CurrentTaxiRate[playerid]);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							}
						}
						if (TaxiUpcomingDrive[playerid] == 3){
						    taxinumber=TaxiUsedRich[playerid] - 1;
							if (taxiownerid == playerid && taxicheck == 0){
				    	        if(TaxiCreditcard[playerid]==1){
									bank[playerid] -= CurrentTaxiRate[playerid];
								} else {
									format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because the player took a taxi.", playerid, CurrentTaxiRate[playerid], GetPlayerMoney(playerid));
									StatGivePlayerMoney(playerid, -CurrentTaxiRate[playerid], strings);
								}
								format(strings, sizeof(strings), "* Player %s took a taxiride to the %s", playername, TaxiLocname[playerid]);
								SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
								taxinumber++;
								format(strings, sizeof(strings), "* The rate for your next taxi ride is $%d.",TaxiPriceOwner[taxinumber]);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
								taxicheck = 1;
							}
							format(strings, sizeof(strings), "* You payed $%d to the taxidiver for her services.", CurrentTaxiRate[playerid]);
							SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							if (taxiownerid != 999 && taxicheck == 0){
				    	        if(TaxiCreditcard[playerid]==1){
									bank[playerid] -= CurrentTaxiRate[playerid];
								} else {
									format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because the player took a taxi.", playerid, CurrentTaxiRate[playerid], GetPlayerMoney(playerid));
									StatGivePlayerMoney(playerid, -CurrentTaxiRate[playerid], strings);
								}
								format(strings, sizeof(strings), "* Player %s took a taxiride to the %s", playername, TaxiLocname[playerid]);
								SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
								if (jailed[taxiownerid] == 0) {
									reward=TaxiPriceReward[taxinumber];
									format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because player-d %d took a taxi.", taxiownerid, reward, GetPlayerMoney(taxiownerid), playerid);
									StatGivePlayerMoney(taxiownerid, reward, strings);
									format(strings, sizeof(strings), "* You received $%d for your services..",reward);
									SendClientMessage(taxiownerid, COLOR_SYSTEM_GM , strings);
								} else {
									SendClientMessage(taxiownerid, COLOR_SYSTEM_GM , "* You received nothing, since you are doing time in jail.");
								}
								if (taxinumber < 4) {taxinumber++;}
								format(strings, sizeof(strings), "* The rate for your next taxi ride is $%d.",TaxiPricePlayer[taxinumber]);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
								taxicheck = 1;
							}
							if (taxiownerid == 999 && taxicheck == 0){
								format(strings, sizeof(strings), "* Money decreased for player-id %d by $%d (old: $%d), because the player took a taxi.", playerid, CurrentTaxiRate[playerid], GetPlayerMoney(playerid));
				    	        if(TaxiCreditcard[playerid]==1){
									bank[playerid] -= CurrentTaxiRate[playerid];
								} else {
									StatGivePlayerMoney(playerid, -CurrentTaxiRate[playerid], strings);
								}
								format(strings, sizeof(strings), "* Player %s took a taxiride to the %s", playername, TaxiLocname[playerid]);
								SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
								if (taxinumber < 4) taxinumber++;
								format(strings, sizeof(strings), "* The rate for your next taxi ride is $%d.",TaxiPricePlayer[taxinumber]);
								SendClientMessage(playerid, COLOR_SYSTEM_GM , strings);
							}
						}
						if(TaxiCreditcard[playerid]==1){
						    if(OldTaxiRate[playerid] != 0){
								if(propertyOwner[P_BANKADMIN] < 999){
									creditcardpayment=CurrentTaxiRate[playerid] - OldTaxiRate[playerid];
					    	        CashForBank = floatround(creditcardpayment / 6);
									format(strings, sizeof(strings), "* Money increased for player-id %d by $%d (old: $%d), because the player received creditcard commissions.", propertyOwner[P_BANKADMIN], CashForBank, GetPlayerMoney(playerid));
									StatGivePlayerMoney(propertyOwner[P_BANKADMIN], CashForBank, strings);
									format(strings, sizeof(strings), "* You received $%d out of creditcard commissions", CashForBank);
									SendClientMessage(propertyOwner[P_BANKADMIN],COLOR_SYSTEM_PM , strings);
								}
							}
							TaxiCreditcard[playerid]=0;
						}
					}
            	}
			}

			if (RequestedTaxi2[playerid] == 1) {
			    WaitingTime2[playerid] --;

				format(strings,sizeof(strings),"The taxi will arrive in %d",WaitingTime2[playerid]);
				GameTextForPlayer(playerid,strings,1000,5);
    	        if (WaitingTime2[playerid] == 1)
        	    {
					PlayerPlaySound(playerid,1147,X250[playerid],Y250[playerid],Z250[playerid]);
				}
    	        if (WaitingTime2[playerid] == 0) {
					if (IsPlayerConnected(playerid) && Z250[playerid] > 900) {
			 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Sorry sir, we cannot pick you up indoors. Please stand outside to order the taxi.");
			 			SendClientMessage(playerid, COLOR_SYSTEM_PW , "* Your current request has been cancelled.");
						RequestedTaxi2[playerid] = 0;
						break;
					} else {
						PFold[playerid]=X250[playerid];
						QFold[playerid]=Y250[playerid];
						RFold[playerid]=Z250[playerid];
	   	        	    GetPlayerName(playerid, playername, sizeof(playername));
						RequestedTaxi2[playerid] = 0;
						format(strings, sizeof(strings), "--- Player %s (id: %d) took the taxi to the %s", playername,playerid,TaxiLocname[playerid]);
						printf(strings);
						SetPlayerInterior(playerid, InteriorID[playerid]);
						SetPlayerPos(playerid, PF[playerid], QF[playerid], RF[playerid] + 2);
						SetCameraBehindPlayer(playerid);
						PlayerPlaySound(playerid,1140,PF[playerid], QF[playerid], RF[playerid]);
						VisitingPrison[playerid] = 1;
						format(strings, sizeof(strings), "* Player %s took a free taxiride to the %s", playername, TaxiLocname[playerid]);
						SendClientMessageToAll(COLOR_SYSTEM_GM , strings);
						SendClientMessage(playerid, COLOR_SYSTEM_PM, "* You can leave the prison using the command /leave or committing suicide.");
					}
				}
			}
		}
	}
	return 1;
}
